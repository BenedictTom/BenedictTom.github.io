<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>SpringDataJpa | Joie's Blog</title><meta name="keywords" content="JPA,ORM"><meta name="author" content="Joie"><meta name="copyright" content="Joie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="SpringDataJpa"><meta name="application-name" content="SpringDataJpa"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="SpringDataJpa"><meta property="og:url" content="http://example.com/2025/07/31/SpringDataJpa/index.html"><meta property="og:site_name" content="Joie's Blog"><meta property="og:description" content="JPA 与 JDBC 全方位对比JPA（Java Persistence API）和 JDBC（Java Database Connectivity）都是 Java 中用于与数据库交互的技术，但它们在设计理念、使用场景和功能特性上有着明显的不同。以下是 JPA 和 JDBC 的全方位对比： 1. 设"><meta property="og:locale" content="en"><meta property="og:image" content="https://img.picgo.net/2025/07/31/OIP-C-1c4afe270c9ab00e7.webp"><meta property="article:author" content="Joie"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.picgo.net/2025/07/31/OIP-C-1c4afe270c9ab00e7.webp"><meta name="description" content="JPA 与 JDBC 全方位对比JPA（Java Persistence API）和 JDBC（Java Database Connectivity）都是 Java 中用于与数据库交互的技术，但它们在设计理念、使用场景和功能特性上有着明显的不同。以下是 JPA 和 JDBC 的全方位对比： 1. 设"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/07/31/SpringDataJpa/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"Here","backTitle":"Welcome"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Joie","link":"Link: ","source":"Source: Joie's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Joie\'s Blog',
  title: 'SpringDataJpa',
  postAI: '',
  pageFillDescription: 'JPA 与 JDBC 全方位对比, 1. 设计理念, 2. 抽象层次, 3. 使用方式, 4. 性能与灵活性, 5. 数据库移植性, 6. 学习曲线, 7. 应用场景, ORM框架, ORM框架的特点, MyBatis是否属于ORM框架, SpringDataJpa 与 Mybatis对比差异点, 1. 设计理念, 2. 数据库操作方式, 3. 学习曲线, 4. 灵活性和控制力, 5. 性能优化, 6. 适用场景, SpringDataJpa 与 Mybatis Plus对比差异点, 主要差异点, 1. 设计理念和抽象层次, 2. 自动生成CRUD的实现方式, 3. 灵活性与性能优化, 4. 学习曲线, 5. 适用场景, Repository, Repository接口, 主要扩展接口, 自定义查询, 总结, 只要定义方法？不需要实现, 这是怎么做到的？, 举个例子, 如何使用？, 总结, 方法名称解析器, 1. 主查询关键字 (Query Keywords - Start), 2. 条件关键字 (Criteria Keywords - Within the By part), 2.1 比较操作符 (Comparison), 2.2 模糊匹配 (String Matching), 2.3 集合操作 (Collectionx2FMembership), 2.4 其他, 3. 逻辑连接符 (Logical Keywords), 4. 排序 (Ordering), 5. 限制结果数量 (Limiting), 重要提示, 返回List, 1. IterableltTgt, 2. CollectionltTgt 及其子接口 (ListltTgt SetltTgt), 关键区别与选择建议, Spring Null-Safety 注解详解, 3. 运行时检查机制, QuerydslPredicateExecutor, 主要特点, 接口方法, 使用示例, 注意事项, query注解, 主要功能, 使用示例, 1. JPQL 查询, 2. 原生SQL查询, 3. 更新和删除操作, 参数绑定, 分页和排序, 总结, 投影, 1. 基于接口的投影 (Interface-based Projection), 2. 基于类的投影 (Class-based Projection x2F DTO Projection), 3. 动态投影 (Dynamic Projection), 总结与全方位对比和都是中用于与数据库交互的技术但它们在设计理念使用场景和功能特性上有着明显的不同以下是和的全方位对比设计理念是一种较低级别的提供了直接与数据库进行通信的方法它要求开发者手动编写查询并处理结果集是一个高级别的对象关系映射规范它允许开发者通过操作实体类来间接操作数据库而无需手动编写语句抽象层次属于低级提供对数据库的直接访问开发者需要管理数据库连接执行查询处理异常等是一个高层次的框架隐藏了许多复杂性比如事务管理和缓存机制等简化了数据库操作使用方式典型的代码包括获取数据库连接创建语句对象执行查询遍历结果集等步骤使用实体类和来进行数据持久化操作支持查询语言性能与灵活性由于可以直接控制语句因此可以实现更精细的性能优化适用于对性能有严格要求的场景虽然也提供了一些性能优化机制如二级缓存但由于其自动化的特性在某些情况下可能会引入额外的开销数据库移植性通常依赖于具体的数据库方言如果要更换数据库可能需要重写部分语句提供了更好的数据库移植性因为它的查询语言是基于实体类而不是具体的数据库表结构学习曲线相对简单直观但对于复杂的数据库操作代码量会增加且容易出错学习曲线较陡峭但一旦掌握了概念能够快速开发和维护大型项目应用场景适合需要高度定制化和性能优化的应用程序尤其是当应用程序的逻辑非常依赖于特定的查询时更适合面向对象的设计模式以及那些需要快速迭代和频繁更改的数据模型的应用程序总结来说更加灵活但在代码量和维护成本上较高而提供了更高的抽象层次简化了开发流程但在某些高性能需求下可能不如那样高效选择哪种技术取决于项目的具体需求和团队的技术偏好框架对象关系映射是一种编程技术用于实现面向对象编程语言里的类与基于关系模型的数据库中表之间的转换通过开发者可以使用面向对象的方式来操作数据库而不需要直接编写语句来执行创建读取更新删除操作框架通常会自动处理数据类型转换关联查询等复杂问题并提供了一种更高效且易于维护的方式来访问数据库框架的特点抽象化数据库操作允许开发者以面向对象的方式思考和编写代码而不是以数据库表格为中心自动化对象关系映射简化了实体类到数据库表的映射过程减少了手动编写的语句提高开发效率减少重复性的数据库访问代码让开发者专注于业务逻辑支持多种数据库许多框架能够相对容易地切换不同的数据库系统提高了应用的可移植性是否属于框架是一个持久层框架它在一定程度上实现了的功能但又不完全符合传统意义上的定义不会自动为你的对象模型生成而是让你自己编写或使用注解来定义如何将对象映射到数据库记录这种方式给予了开发者更多的控制权特别是在需要优化查询性能或者处理复杂的时因此有时被描述为半自动的框架它确实提供了对象和关系数据库之间映射的能力但是相比如这样的全功能框架要求开发者更多地参与的编写和优化工作这使得在灵活性方面表现出色特别适合那些对有高度定制需求的项目总结来说虽然不是传统意义上的框架但它确实提供了的一部分核心功能并在社区中广受欢迎与对比差异点和是两个非常流行的持久层框架但它们的设计理念和使用场景有着显著的不同以下是它们的主要差异点设计理念基于规范旨在通过简化数据访问层的开发来提高生产效率它提供了强大的抽象层允许开发者以面向对象的方式操作数据库并且可以减少手动编写语句的需求是一个持久层框架它将查询与对象映射起来允许开发者直接编写语句并将其结果映射到对象上这种方式给予了开发者对的高度控制权数据库操作方式主要依赖于或进行数据库操作此外它还支持自动生成一些简单的操作方法极大地减少了模板代码的数量要求开发者编写具体的语句包括和等操作这为复杂查询和性能优化提供了更大的灵活性学习曲线由于其高度抽象化的特点初学者可能需要一定时间去理解的核心概念如实体仓库接口实体管理器等学习曲线相对平缓因为开发者可以直接使用熟悉的语言不过理解和正确配置的映射关系也需一定的学习成本灵活性和控制力提供了一种高层次的数据访问抽象对于大多数通用场景而言足够灵活但在处理复杂查询时可能需要额外的工作量在编写方面提供了极大的自由度和控制力非常适合需要执行复杂查询或对有特殊需求的应用场景性能优化通过延迟加载二级缓存等机制提供了一定程度的性能优化但对于特定情况下的优化可能不如灵活允许开发者精确地控制语句从而更容易实现性能优化适用场景适用于追求快速开发维护简便的企业级应用特别是那些遵循领域驱动设计原则的项目更适合那些需要高效执行复杂查询对语句有严格控制要求或者需要移植性较低的项目总的来说选择还是取决于项目的具体需求团队的技术栈偏好以及对开发效率和性能优化之间的权衡与对比差异点和都是用于简化应用程序中数据访问层开发的框架它们都能够自动生成基本的操作尽管两者都能显著减少开发者的工作量但在实现方式灵活性功能特性等方面存在差异主要差异点设计理念和抽象层次基于规范提供了一个高层次的抽象使得开发者可以几乎不用写任何语句就能完成数据库操作它利用了对象关系映射的概念将实体类直接映射到数据库表并提供了强大的查询方法生成机制作为的增强工具它保留了原有的灵活性允许开发者手动编写语句同时也通过插件的形式提供了诸如代码生成器分页插件等功能来减少重复工作虽然也能自动生成接口但相比它给予了开发者更多对语句的控制权自动生成的实现方式只需要定义一个继承自或其子接口如的接口不需要实现任何方法会自动为这些接口生成相应的实现这极大地简化了代码量并且支持通过方法名自动生成查询通过代码生成器可以快速生成实体类接口以及层的基本代码虽然减少了手动编码的工作量但仍需一定的配置来定制化生成的内容此外也提供了一些基础的接口可以直接使用灵活性与性能优化由于高度抽象化对于复杂的查询可能需要额外的工作量例如使用注解或者不过它也提供了二级缓存等机制帮助提高性能因为允许直接编写语句所以在处理复杂查询和性能优化方面更为灵活和强大可以根据具体需求精确调整语句以达到最佳性能学习曲线对于初学者来说理解和掌握的核心概念如实体仓库接口实体管理器等可能需要一定的时间相对容易上手特别是对于已经熟悉的开发者而言只需了解其提供的增强功能即可快速应用适用场景适合那些追求快速开发维护简便的企业级应用尤其是遵循领域驱动设计原则的项目更适合那些需要高效执行复杂查询对语句有严格控制要求或者需要移植性较低的项目在中是一个核心概念它提供了一种机制来管理数据使得开发者可以更专注于业务逻辑而不是底层的数据访问细节接口是的核心接口之一它定义了最基本的操作方法下面是对及其相关概念的介绍接口接口本身是一个标记接口并没有包含任何方法它的主要作用是标识出某个接口是一个仓库接口从而让能够识别并为其创建实现这里代表实体类型而代表该实体类型的主键类型主要扩展接口尽管接口本身很简单但它有几个重要的子接口提供了更加丰富的功能继承自提供了基本的操作方法保存单个实体根据查找实体检查是否存在指定的实体查找所有实体返回实体总数根据删除实体删除实体删除所有实体扩展了增加了分页和排序的功能根据给定的排序规则查询所有实体分页查询所有实体进一步扩展了添加了一些特定于的方法如刷新持久化上下文批量删除等刷新持久化上下文保存并刷新实体批量删除实体其他方法自定义查询除了使用上述预定义的方法之外还支持通过方法名来自动生成查询例如如果你定义了一个名为的方法会自动为你生成相应的查询逻辑来查找具有指定姓氏的所有实体此外还可以使用注解直接在方法上编写或原生查询总结接口及其子接口为提供了强大的基础使得开发者可以通过声明式的方式来访问数据库极大地简化了数据访问层的开发工作通过继承这些接口开发者可以获得开箱即用的功能同时还能利用提供的高级特性如动态查询生成分页排序以及自定义查询等只要定义方法不需要实现在中你只需要在继承了或其子接口如的接口中声明一个方法而不需要提供任何实现会自动为你生成这个方法的实现这就是的核心魅力之一约定优于配置这是怎么做到的这个过程主要依赖于以下几个关键技术接口代理当你的应用启动时容器会扫描所有标记了注解或通过配置扫描到的接口对于每个继承了的接口比如你的会利用动态代理或生成一个该接口的运行时实现类代理类这个生成的代理类包含了所有你在接口中声明的方法的具体实现方法名解析有一套非常智能的解析器它会解析你定义的方法名它会将方法名拆解成有意义的单词使用作为关键字前缀接着它会根据实体类通过接口的泛型参数确定的属性名来匹配方法名中的剩余部分最后它根据这些信息自动生成对应的查询举个例子假设你有以下实体类然后你定义一个接口继承了这意味着它自动拥有了等基础方法最简单的方法名解析含义查找所有属性等于传入参数的自动生成的多条件查询方法名解析自动生成的使用比较操作符等方法名解析自动生成的方法名解析等同于自动生成的排序方法名解析自动生成的限制结果数量方法名解析含义查找年龄最大的一个用户自动生成的并设置结果限制如何使用你只需要在你的或中注入这个然后就可以直接调用这些方法了会注入自动生成的实现直接调用会执行自动生成的查询总结你只定义接口和方法签名你不需要写实现文件在运行时生成实现利用代理技术方法名遵循特定约定解析方法名推断出你要执行的查询逻辑自动生成根据解析结果生成标准的查询语句开箱即用你可以在任何注入了的地方直接调用这些方法这种方式极大地减少了样板代码让你可以更专注于业务逻辑而不是重复编写简单的数据库查询当然对于非常复杂的查询你仍然可以使用注解来手动编写或原生方法名称解析器在中方法名解析是一种强大的功能它允许你通过遵循特定的命名约定来定义查询方法而无需手动编写或会根据方法名自动生成相应的查询方法名解析主要由关键字和属性名组成主查询关键字这些关键字定义了查询的类型通常作为方法名的前缀最常用用于查找实体可以省略直接用例如同语义上更强调读取同语义上更强调获取同同返回满足条件的实体数量类型例如检查是否存在满足条件的实体返回例如检查是否存在删除满足条件的实体返回被删除的实体或数量例如删除创建时间早于指定日期的所有实体注意在生成查询时效果基本相同则改变了查询的目的条件关键字在之后你可以使用以下关键字来构建查询条件它们通常与实体的属性名结合使用比较操作符相等通常可省略例如三者等价不等于或例如在某个范围内需要两个参数例如小于例如小于等于例如大于例如大于等于例如同常用于日期例如同常用于日期例如为例如不为例如模糊匹配模糊匹配通常需要在参数中手动添加例如调用时传入不模糊匹配以开头例如以结尾例如包含例如自动添加集合操作在某个集合内参数通常是一个例如不在某个集合内例如其他匹配布尔值例如逻辑连接符逻辑与例如逻辑或例如排序按指定属性升序排列按指定属性降序排列可以链式使用多个排序条件例如例如限制结果数量限制返回结果的数量可以与数字结合使用例如返回年龄最大的一个用户例如返回指定状态的最新创建的个用户例如返回姓氏匹配的前个用户重要提示属性名匹配关键字后的部分必须精确匹配实体类中的属性名遵循规范区分大小写会查找名为的属性驼峰命名方法名通常使用驼峰命名法参数顺序方法的参数必须按照它们在方法名中出现的顺序来声明复杂查询对于极其复杂的查询建议使用注解来编写或原生以获得更好的性能和可读性文档参考的官方文档提供了最完整和权威的关键字列表及用法返回在中接口的方法返回类型非常灵活和及其子接口如是两种最常用的返回多个实体对象的类型它们的选择取决于你的具体需求定义是集合框架中的一个基础接口任何实现了的类都可以使用循环进行遍历特点最基础的抽象只定义了一个核心方法用于获取一个对象来遍历元素它不关心元素的顺序是否允许重复是否有索引等特性轻量级因为它是最基础的接口所以作为返回类型非常通用和轻量延迟加载友好当查询结果是懒加载时只保证能遍历而不会预先将所有数据加载到内存中虽然实现通常会加载功能有限除了遍历和获取它没有提供等方法在中的使用接口中的方法就返回任何你希望返回一个可遍历结果集但不关心具体集合类型或不需要集合特定功能如的自定义查询方法都可以使用示例返回所有用户你可以用遍历根据姓氏查找返回可遍历的用户集合使用及其子接口定义是的子接口提供了比更丰富的操作如等和是最重要的两个子接口特点有序元素按照插入顺序或指定顺序如排列可重复允许存储重复的元素有索引可以通过索引访问元素常用实现适用场景当你需要保持查询结果的顺序尤其是使用了或者需要通过索引来访问元素时无序通常元素没有特定的顺序保持插入顺序保持排序唯一不允许存储重复的元素重复的判断基于和方法适用场景当你希望查询结果自动去重或者你关心的是元素的唯一性而不是顺序时在中的使用接口中的方法返回因为它继承了后者通常期望一个有序的列表尤其是在分页时你可以明确地将自定义查询方法的返回类型声明为或以表达你的意图或利用其特定功能示例明确返回一个列表保持顺序明确返回一个集合自动去重如果查询可能产生重复但通常不会如果查询结果天然有序或你需要索引访问使用可以获取大小可以通过索引访问保证了用户是唯一的关键区别与选择建议特性抽象层级最基础只保证可遍历更高级提供丰富操作功能仅支持遍历支持等顺序不保证保证有序通常不保证除外重复元素不保证保证唯一允许重复内存概念上更轻量但实现通常加载所有同上常用场景通用遍历不关心具体集合特性需要索引访问自动去重明确表达意图选择建议通用遍历如果你只需要遍历结果不关心顺序大小或是否重复使用是安全且通用的选择需要顺序或索引如果查询使用了或你需要通过索引访问元素优先使用需要去重如果你希望结果集自动排除重复项虽然数据库查询通常不会返回重复实体除非有特殊使用需要集合方法如果你需要调用等方法使用或其子接口遵循约定如果你继承的是其默认的返回为了保持一致性你的自定义查询方法也常返回尤其是涉及排序时总结是最基础的返回类型适用于简单的遍历场景和提供了更强的语义和更丰富的功能在实际开发中因为其有序性和易用性支持索引在返回多个实体时使用得非常广泛注解详解作用这是一个包级别的注解通常放在文件中效果它为该包及其子包下的所有类和接口中所有没有明确标注的方法参数和返回值设定一个默认行为即它们不允许为目的避免在每个方法上重复写实现非空是常态的约定作用直接标注在方法的参数或返回值上效果明确声明这个参数不能传入或者这个方法的返回值不能是注意如果包上已经有那么方法参数和返回值默认就是的所以通常不需要显式写出除非你想在某个的包里明确一个非空方法作用直接标注在方法的参数或返回值上效果明确声明这个参数可以传入或者这个方法的返回值可以是目的覆盖的默认行为或者在没有的包里明确指出某个地方可以为运行时检查机制当你在包上启用了后会在运行时对方法进行代理执行以下检查参数检查如果一个参数被或受影响标记但你传入了会在方法执行前抛出返回值检查如果一个方法的返回值被或受影响标记但数据库查询没有找到任何结果即结果为或空集合会抛出例外情况如果返回类型是等包装器类型即使方法被标记查询无结果时也不会抛异常而是返回等这是这些包装器类型的预期行为是提供的一个接口它允许你在中集成的强大查询功能通过继承这个接口你可以轻松地为你的添加动态查询支持而无需手动编写查询方法下面是对的详细介绍主要特点动态查询允许根据运行时条件构建查询而不是预先定义的查询方法类型安全生成的类型提供了编译期检查减少了运行时错误的可能性简化查询逻辑减少了大量样板代码使开发者能够更专注于业务逻辑接口方法定义了几个核心方法这些方法可以用来执行基于的查询操作根据给定的谓词返回所有匹配的实体在新版本中可能已被弃用或替换为其他形式返回与给定匹配的第一个实体注意在处理多个匹配项时的行为可能会有所不同取决于具体的实现细节检查是否存在任何满足给定的实体计算满足给定的实体数量和等基本方法不会直接出现在中但如果你让你的同时继承自或类似的接口那么这些方法也会可用使用示例首先你需要确保项目中已经配置好对的支持并且相应的类已经被正确生成假设我们有一个实体类然后创建一个接口并继承自定义查询方法可以在这里定义接下来你可以在服务层使用来执行动态查询在这个例子中被用来根据提供的参数动态构建查询条件这样做的好处是无论用户提供的是部分还是全部搜索条件代码都能很好地适应注意事项依赖管理确保项目中包含了正确的相关依赖并且你的构建工具如或配置正确以生成类性能考虑尽管提供了强大的查询能力但在构建复杂查询时仍需考虑性能问题特别是当涉及到大量的条件或嵌套查询时学习曲线对于初次接触的开发者来说理解和掌握其语法和最佳实践可能需要一些时间总之提供了一种灵活类型安全的方式来执行动态查询特别适合那些需要根据用户输入或其他运行时条件来构建查询的应用场景注解在中注解是一个非常强大的工具它允许开发者直接定义或原生查询这为执行更复杂的查询提供了极大的灵活性而不仅仅是依赖于提供的方法命名约定来生成查询主要功能自定义查询通过注解你可以定义任意复杂的查询逻辑支持和原生可以使用进行面向对象的查询也可以选择使用原生语句直接操作数据库表参数绑定支持命名参数和位置参数两种方式便于动态地向查询中插入变量值使用示例查询这里表示第一个方法参数即你也可以使用命名参数的方式是命名参数标记了传入的参数名与查询中的参数名对应原生查询如果你需要执行原生查询可以通过设置来实现注意当使用原生时你需要直接引用数据库表名和列名而不是实体类及其属性名更新和删除操作除了查询注解还可以用于执行更新和删除操作这里注解表明这是一个修改操作对于这种类型的查询必须加上注解并且通常还需要事务管理参数绑定位置参数如上所示通过加数字表示参数的位置命名参数使用加参数名这种方式更加直观尤其是在有多个参数的情况下表达式在某些情况下可以使用来构建查询字符串分页和排序注解也支持分页和排序这里参数使得我们可以轻松实现分页查询类似的可以使用对象来指定排序规则总结注解极大地增强了的功能使我们能够编写灵活高效的查询无论是简单的查询还是复杂的多表联查都可以通过它来实现同时结合命名参数位置参数以及对原生的支持让数据访问层的开发既方便又强大不过在享受其便利的同时也要注意保持查询的可读性和维护性特别是在编写复杂查询时投影在中投影是一种强大的功能它允许你从数据库查询中只选择你需要的字段而不是加载整个实体对象这可以显著提高性能减少数据传输和内存占用并让你更灵活地组织返回的数据结构投影主要分为三种类型基于接口的投影基于类的投影和动态投影基于接口的投影这是最简单和常用的投影方式你定义一个接口其中包含你希望从实体中获取的属性的方法会为这个接口生成一个实现类该实现类在查询时只选择接口中定义的字段特点只读投影接口是只读的不能用于更新封闭投影默认情况下接口投影是封闭的这意味着即使你定义了方法但如果实体中没有字段或对应的查询会失败你不能随意添加实体中不存在的属性开放投影通过在接口方法上使用注解可以创建开放投影允许包含计算值或来自其他来源的值示例定义投影接口注意方法名必须与实体属性的方法名完全匹配在中使用查询将只和字段使用开放投影示例使用这是一个计算属性不是实体的直接字段也可以引用其他的方法基于类的投影这种方式是通过定义一个具体的类通常是或来接收查询结果你需要为这个类提供一个构造函数其参数顺序和类型必须与查询子句中的字段顺序和类型匹配特点更灵活可以包含自定义的构造函数逻辑可变性类的属性可以是可变的有尽管通常设计为不可变类型安全构造函数参数提供了编译时检查需要构造函数必须有一个构造函数匹配的字段示例定义类构造函数的参数顺序必须与子句中的字段顺序完全一致在中使用需要配合使用使用使用更简洁方法签名不变但构造函数匹配的隐式构造函数动态投影动态投影允许你在调用方法时动态地决定返回哪种投影类型这是通过将投影类型作为方法的泛型参数传递来实现的特点高度灵活同一个方法可以根据需要返回不同的投影需要参数方法必须接受一个类型的参数来指定返回的投影类型示例定义多个投影接口或类在中定义动态投影方法可以是接口或类使用动态决定返回类型想要接口投影想要投影注意动态投影方法通常需要配合注解来确保的字段能匹配目标投影类型总结投影类型优点缺点适用场景接口投影简单无需额外类支持计算属性只读封闭性默认方法名必须匹配快速获取实体的子集字段包含简单计算逻辑投影类型安全构造函数编译检查可包含复杂逻辑支持需要定义额外的类和匹配的构造函数需要将数据传递到服务层或视图层结构相对固定动态投影极致灵活一个方法支持多种返回类型使用稍复杂需要传入参数同一查询需要根据上下文返回不同数据结构的场景选择哪种投影方式取决于你的具体需求性能要求数据结构的复杂性是否需要计算属性以及灵活性要求合理使用投影是优化应用性能的关键技巧之一参考资料集成官方文档',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-31 18:32:39',
  postMainColor: '#80a340ff',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">个人主页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://benedicttom.github.io/home/" title="个人主页"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Joie's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CI-CD/" style="font-size: 1.05rem;">CI/CD<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 1.05rem;">ElasticSearch<sup>4</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/Http/" style="font-size: 1.05rem;">Http<sup>1</sup></a><a href="/tags/JPA/" style="font-size: 1.05rem;">JPA<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>6</sup></a><a href="/tags/Mysql/" style="font-size: 1.05rem;">Mysql<sup>2</sup></a><a href="/tags/ORM/" style="font-size: 1.05rem;">ORM<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>3</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>4</sup></a><a href="/tags/Spring-Boot/" style="font-size: 1.05rem;">Spring Boot<sup>1</sup></a><a href="/tags/SpringData/" style="font-size: 1.05rem;">SpringData<sup>1</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 1.05rem;">中间件<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 1.05rem;">云原生<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 1.05rem;">八股<sup>1</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3/" style="font-size: 1.05rem;">力扣<sup>10</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>7</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 1.05rem;">定时任务<sup>3</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>7</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">开发工具<sup>2</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">推荐<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>4</sup></a><a href="/tags/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">权限校验<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 1.05rem;">树<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.05rem;">消息队列<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 1.05rem;">缓存<sup>1</sup></a><a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 1.05rem;">运维<sup>2</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">July 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">28</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">June 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/ORM/" itemprop="url">ORM</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JPA/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JPA</span></a><a class="article-meta__tags" href="/tags/ORM/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>ORM</span></a></span></div></div><h1 class="post-title" itemprop="name headline">SpringDataJpa</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-31T08:03:07.464Z" title="Created 2025-07-31 16:03:07">2025-07-31</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-31T10:32:39.892Z" title="Updated 2025-07-31 18:32:39">2025-07-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.picgo.net/2025/07/31/OIP-C-1c4afe270c9ab00e7.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/07/31/SpringDataJpa/"><header><a class="post-meta-categories" href="/categories/ORM/" itemprop="url">ORM</a><a href="/tags/JPA/" tabindex="-1" itemprop="url">JPA</a><a href="/tags/ORM/" tabindex="-1" itemprop="url">ORM</a><h1 id="CrawlerTitle" itemprop="name headline">SpringDataJpa</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Joie</span><time itemprop="dateCreated datePublished" datetime="2025-07-31T08:03:07.464Z" title="Created 2025-07-31 16:03:07">2025-07-31</time><time itemprop="dateCreated datePublished" datetime="2025-07-31T10:32:39.892Z" title="Updated 2025-07-31 18:32:39">2025-07-31</time></header><h2 id="JPA-与-JDBC-全方位对比"><a href="#JPA-与-JDBC-全方位对比" class="headerlink" title="JPA 与 JDBC 全方位对比"></a>JPA 与 JDBC 全方位对比</h2><p>JPA（Java Persistence API）和 JDBC（Java Database Connectivity）都是 Java 中用于与数据库交互的技术，但它们在设计理念、使用场景和功能特性上有着明显的不同。以下是 JPA 和 JDBC 的全方位对比：</p>
<h3 id="1-设计理念"><a href="#1-设计理念" class="headerlink" title="1. 设计理念"></a>1. 设计理念</h3><ul>
<li><strong>JDBC</strong>：是一种较低级别的 API，提供了直接与数据库进行通信的方法。它要求开发者手动编写 SQL 查询并处理结果集。</li>
<li><strong>JPA</strong>：是一个高级别的对象关系映射（ORM）规范，它允许开发者通过操作实体类来间接操作数据库，而无需手动编写SQL语句。</li>
</ul>
<h3 id="2-抽象层次"><a href="#2-抽象层次" class="headerlink" title="2. 抽象层次"></a>2. 抽象层次</h3><ul>
<li><strong>JDBC</strong>：属于低级API，提供对数据库的直接访问。开发者需要管理数据库连接、执行查询、处理异常等。</li>
<li><strong>JPA</strong>：是一个高层次的框架，隐藏了许多复杂性，比如事务管理和缓存机制等，简化了数据库操作。</li>
</ul>
<h3 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3. 使用方式"></a>3. 使用方式</h3><ul>
<li><strong>JDBC</strong>：典型的代码包括获取数据库连接、创建语句对象、执行查询、遍历结果集等步骤。</li>
<li><strong>JPA</strong>：使用实体类和EntityManager来进行数据持久化操作，支持JPQL（Java Persistence Query Language）查询语言。</li>
</ul>
<h3 id="4-性能与灵活性"><a href="#4-性能与灵活性" class="headerlink" title="4. 性能与灵活性"></a>4. 性能与灵活性</h3><ul>
<li><strong>JDBC</strong>：由于可以直接控制SQL语句，因此可以实现更精细的性能优化，适用于对性能有严格要求的场景。</li>
<li><strong>JPA</strong>：虽然也提供了一些性能优化机制（如二级缓存），但由于其自动化的特性，在某些情况下可能会引入额外的开销。</li>
</ul>
<h3 id="5-数据库移植性"><a href="#5-数据库移植性" class="headerlink" title="5. 数据库移植性"></a>5. 数据库移植性</h3><ul>
<li><strong>JDBC</strong>：通常依赖于具体的数据库方言，如果要更换数据库可能需要重写部分SQL语句。</li>
<li><strong>JPA</strong>：提供了更好的数据库移植性，因为它的查询语言是基于实体类而不是具体的数据库表结构。</li>
</ul>
<h3 id="6-学习曲线"><a href="#6-学习曲线" class="headerlink" title="6. 学习曲线"></a>6. 学习曲线</h3><ul>
<li><strong>JDBC</strong>：相对简单直观，但对于复杂的数据库操作，代码量会增加，且容易出错。</li>
<li><strong>JPA</strong>：学习曲线较陡峭，但一旦掌握了概念，能够快速开发和维护大型项目。</li>
</ul>
<h3 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7. 应用场景"></a>7. 应用场景</h3><ul>
<li><strong>JDBC</strong>：适合需要高度定制化和性能优化的应用程序，尤其是当应用程序的逻辑非常依赖于特定的SQL查询时。</li>
<li><strong>JPA</strong>：更适合面向对象的设计模式，以及那些需要快速迭代和频繁更改的数据模型的应用程序。</li>
</ul>
<p>总结来说，JDBC 更加灵活，但在代码量和维护成本上较高；而 JPA 提供了更高的抽象层次，简化了开发流程，但在某些高性能需求下可能不如 JDBC 那样高效。选择哪种技术取决于项目的具体需求和团队的技术偏好。</p>
<h2 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h2><p>ORM（对象关系映射，Object-Relational Mapping）是一种编程技术，用于实现面向对象编程语言里的类与基于关系模型的数据库中表之间的转换。通过ORM，开发者可以使用面向对象的方式来操作数据库，而不需要直接编写SQL语句来执行CRUD（创建、读取、更新、删除）操作。ORM框架通常会自动处理数据类型转换、关联查询等复杂问题，并提供了一种更高效且易于维护的方式来访问数据库。</p>
<h3 id="ORM框架的特点"><a href="#ORM框架的特点" class="headerlink" title="ORM框架的特点"></a>ORM框架的特点</h3><ul>
<li><strong>抽象化数据库操作</strong>：允许开发者以面向对象的方式思考和编写代码，而不是以数据库表格为中心。</li>
<li><strong>自动化对象&#x2F;关系映射</strong>：简化了实体类到数据库表的映射过程，减少了手动编写的SQL语句。</li>
<li><strong>提高开发效率</strong>：减少重复性的数据库访问代码，让开发者专注于业务逻辑。</li>
<li><strong>支持多种数据库</strong>：许多ORM框架能够相对容易地切换不同的数据库系统，提高了应用的可移植性。</li>
</ul>
<h3 id="MyBatis是否属于ORM框架"><a href="#MyBatis是否属于ORM框架" class="headerlink" title="MyBatis是否属于ORM框架"></a>MyBatis是否属于ORM框架</h3><p>MyBatis是一个持久层框架，它在一定程度上实现了ORM的功能，但又不完全符合传统意义上的ORM定义。MyBatis不会自动为你的对象模型生成SQL，而是让你自己编写SQL或使用注解来定义如何将对象映射到数据库记录。这种方式给予了开发者更多的控制权，特别是在需要优化查询性能或者处理复杂的SQL时。</p>
<p>因此，MyBatis有时被描述为“半自动”的ORM框架。它确实提供了对象和关系数据库之间映射的能力，但是相比如Hibernate这样的全功能ORM框架，MyBatis要求开发者更多地参与SQL的编写和优化工作。这使得MyBatis在灵活性方面表现出色，特别适合那些对SQL有高度定制需求的项目。总结来说，虽然MyBatis不是传统意义上的ORM框架，但它确实提供了ORM的一部分核心功能，并在Java社区中广受欢迎。</p>
<h2 id="SpringDataJpa-与-Mybatis对比，差异点"><a href="#SpringDataJpa-与-Mybatis对比，差异点" class="headerlink" title="SpringDataJpa 与 Mybatis对比，差异点"></a>SpringDataJpa 与 Mybatis对比，差异点</h2><p>Spring Data JPA 和 MyBatis 是两个非常流行的Java持久层框架，但它们的设计理念和使用场景有着显著的不同。以下是它们的主要差异点：</p>
<h3 id="1-设计理念-1"><a href="#1-设计理念-1" class="headerlink" title="1. 设计理念"></a>1. 设计理念</h3><ul>
<li><strong>Spring Data JPA</strong>：基于JPA规范，旨在通过简化数据访问层的开发来提高生产效率。它提供了强大的抽象层，允许开发者以面向对象的方式操作数据库，并且可以减少手动编写SQL语句的需求。</li>
<li><strong>MyBatis</strong>：是一个持久层框架，它将SQL查询与Java对象映射起来，允许开发者直接编写SQL语句并将其结果映射到Java对象上。这种方式给予了开发者对SQL的高度控制权。</li>
</ul>
<h3 id="2-数据库操作方式"><a href="#2-数据库操作方式" class="headerlink" title="2. 数据库操作方式"></a>2. 数据库操作方式</h3><ul>
<li><strong>Spring Data JPA</strong>：主要依赖于JPQL（Java Persistence Query Language）或Criteria API进行数据库操作。此外，它还支持自动生成一些简单的CRUD操作方法，极大地减少了模板代码的数量。</li>
<li><strong>MyBatis</strong>：要求开发者编写具体的SQL语句，包括SELECT、INSERT、UPDATE和DELETE等操作。这为复杂查询和性能优化提供了更大的灵活性。</li>
</ul>
<h3 id="3-学习曲线"><a href="#3-学习曲线" class="headerlink" title="3. 学习曲线"></a>3. 学习曲线</h3><ul>
<li><strong>Spring Data JPA</strong>：由于其高度抽象化的特点，初学者可能需要一定时间去理解JPA的核心概念，如实体、仓库接口（Repository）、实体管理器（EntityManager）等。</li>
<li><strong>MyBatis</strong>：学习曲线相对平缓，因为开发者可以直接使用熟悉的SQL语言。不过，理解和正确配置MyBatis的映射关系也需一定的学习成本。</li>
</ul>
<h3 id="4-灵活性和控制力"><a href="#4-灵活性和控制力" class="headerlink" title="4. 灵活性和控制力"></a>4. 灵活性和控制力</h3><ul>
<li><strong>Spring Data JPA</strong>：提供了一种高层次的数据访问抽象，对于大多数通用场景而言足够灵活，但在处理复杂查询时可能需要额外的工作量。</li>
<li><strong>MyBatis</strong>：在SQL编写方面提供了极大的自由度和控制力，非常适合需要执行复杂查询或对SQL有特殊需求的应用场景。</li>
</ul>
<h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><ul>
<li><strong>Spring Data JPA</strong>：通过延迟加载、二级缓存等机制提供了一定程度的性能优化，但对于特定情况下的优化可能不如MyBatis灵活。</li>
<li><strong>MyBatis</strong>：允许开发者精确地控制SQL语句，从而更容易实现性能优化。</li>
</ul>
<h3 id="6-适用场景"><a href="#6-适用场景" class="headerlink" title="6. 适用场景"></a>6. 适用场景</h3><ul>
<li><strong>Spring Data JPA</strong>：适用于追求快速开发、维护简便的企业级应用，特别是那些遵循领域驱动设计原则的项目。</li>
<li><strong>MyBatis</strong>：更适合那些需要高效执行复杂查询、对SQL语句有严格控制要求，或者需要移植性较低的项目。</li>
</ul>
<p>总的来说，选择Spring Data JPA还是MyBatis取决于项目的具体需求、团队的技术栈偏好以及对开发效率和性能优化之间的权衡。</p>
<h2 id="SpringDataJpa-与-Mybatis-Plus对比，差异点"><a href="#SpringDataJpa-与-Mybatis-Plus对比，差异点" class="headerlink" title="SpringDataJpa 与 Mybatis Plus对比，差异点"></a>SpringDataJpa 与 Mybatis Plus对比，差异点</h2><p>Spring Data JPA 和 MyBatis Plus 都是用于简化Java应用程序中数据访问层开发的框架，它们都能够自动生成基本的CRUD操作。尽管两者都能显著减少开发者的工作量，但在实现方式、灵活性、功能特性等方面存在差异。</p>
<h3 id="主要差异点"><a href="#主要差异点" class="headerlink" title="主要差异点"></a>主要差异点</h3><h4 id="1-设计理念和抽象层次"><a href="#1-设计理念和抽象层次" class="headerlink" title="1. 设计理念和抽象层次"></a>1. <strong>设计理念和抽象层次</strong></h4><ul>
<li><strong>Spring Data JPA</strong>：基于JPA规范，提供了一个高层次的抽象，使得开发者可以几乎不用写任何SQL语句就能完成数据库操作。它利用了ORM（对象关系映射）的概念，将实体类直接映射到数据库表，并提供了强大的查询方法生成机制。</li>
<li><strong>MyBatis Plus</strong>：作为MyBatis的增强工具，它保留了MyBatis原有的灵活性，允许开发者手动编写SQL语句，同时也通过插件的形式提供了诸如代码生成器、分页插件等功能来减少重复工作。虽然也能自动生成CRUD接口，但相比Spring Data JPA，它给予了开发者更多对SQL语句的控制权。</li>
</ul>
<h4 id="2-自动生成CRUD的实现方式"><a href="#2-自动生成CRUD的实现方式" class="headerlink" title="2. 自动生成CRUD的实现方式"></a>2. <strong>自动生成CRUD的实现方式</strong></h4><ul>
<li><strong>Spring Data JPA</strong>：只需要定义一个继承自<code>Repository</code>或其子接口（如<code>JpaRepository</code>）的接口，不需要实现任何方法，Spring Data JPA会自动为这些接口生成相应的实现。这极大地简化了代码量，并且支持通过方法名自动生成查询。</li>
<li><strong>MyBatis Plus</strong>：通过代码生成器可以快速生成实体类、Mapper接口以及Service层的基本代码。虽然减少了手动编码的工作量，但仍需一定的配置来定制化生成的内容。此外，MyBatis Plus也提供了一些基础的CRUD接口，可以直接使用。</li>
</ul>
<h4 id="3-灵活性与性能优化"><a href="#3-灵活性与性能优化" class="headerlink" title="3. 灵活性与性能优化"></a>3. <strong>灵活性与性能优化</strong></h4><ul>
<li><strong>Spring Data JPA</strong>：由于高度抽象化，对于复杂的查询可能需要额外的工作量，例如使用@Query注解或者JPQL。不过，它也提供了二级缓存等机制帮助提高性能。</li>
<li><strong>MyBatis Plus</strong>：因为允许直接编写SQL语句，所以在处理复杂查询和性能优化方面更为灵活和强大。可以根据具体需求精确调整SQL语句以达到最佳性能。</li>
</ul>
<h4 id="4-学习曲线"><a href="#4-学习曲线" class="headerlink" title="4. 学习曲线"></a>4. <strong>学习曲线</strong></h4><ul>
<li><strong>Spring Data JPA</strong>：对于初学者来说，理解和掌握JPA的核心概念（如实体、仓库接口、实体管理器等）可能需要一定的时间。</li>
<li><strong>MyBatis Plus</strong>：相对容易上手，特别是对于已经熟悉MyBatis的开发者而言，只需了解其提供的增强功能即可快速应用。</li>
</ul>
<h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. <strong>适用场景</strong></h4><ul>
<li><strong>Spring Data JPA</strong>：适合那些追求快速开发、维护简便的企业级应用，尤其是遵循领域驱动设计原则的项目。</li>
<li><strong>MyBatis Plus</strong>：更适合那些需要高效执行复杂查询、对SQL语句有严格控制要求，或者需要移植性较低的项目。</li>
</ul>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>在Spring Data JPA中，<code>Repository</code>是一个核心概念，它提供了一种机制来管理数据，使得开发者可以更专注于业务逻辑而不是底层的数据访问细节。<code>Repository</code>接口是Spring Data的核心接口之一，它定义了最基本的CRUD操作方法。下面是对<code>Repository</code>及其相关概念的介绍：</p>
<h3 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h3><p><code>Repository</code>接口本身是一个标记接口，并没有包含任何方法。它的主要作用是标识出某个接口是一个仓库接口，从而让Spring Data能够识别并为其创建实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>T</code>代表实体类型，而<code>ID</code>代表该实体类型的主键类型。</p>
<h3 id="主要扩展接口"><a href="#主要扩展接口" class="headerlink" title="主要扩展接口"></a>主要扩展接口</h3><p>尽管<code>Repository</code>接口本身很简单，但它有几个重要的子接口提供了更加丰富的功能：</p>
<ol>
<li><p><strong>CrudRepository</strong>：继承自<code>Repository</code>，提供了基本的CRUD操作方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>; <span class="comment">// 保存单个实体</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>; <span class="comment">// 根据id查找实体</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>; <span class="comment">// 检查是否存在指定id的实体</span></span><br><span class="line">    Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>; <span class="comment">// 查找所有实体</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>; <span class="comment">// 返回实体总数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>; <span class="comment">// 根据id删除实体</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>; <span class="comment">// 删除实体</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>; <span class="comment">// 删除所有实体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PagingAndSortingRepository</strong>：扩展了<code>CrudRepository</code>，增加了分页和排序的功能。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>; <span class="comment">// 根据给定的排序规则查询所有实体</span></span><br><span class="line">    Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>; <span class="comment">// 分页查询所有实体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JpaRepository</strong>：进一步扩展了<code>PagingAndSortingRepository</code>，添加了一些特定于JPA的方法，如刷新持久化上下文、批量删除等。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>; <span class="comment">// 刷新持久化上下文</span></span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span>; <span class="comment">// 保存并刷新实体</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span>; <span class="comment">// 批量删除实体</span></span><br><span class="line">    <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h3><p>除了使用上述预定义的方法之外，Spring Data JPA还支持通过方法名来自动生成查询。例如，如果你定义了一个名为<code>findByLastName</code>的方法，Spring Data JPA会自动为你生成相应的查询逻辑来查找具有指定姓氏的所有实体。此外，还可以使用<code>@Query</code>注解直接在方法上编写JPQL或原生SQL查询。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Repository</code>接口及其子接口为Spring Data JPA提供了强大的基础，使得开发者可以通过声明式的方式来访问数据库，极大地简化了数据访问层的开发工作。通过继承这些接口，开发者可以获得开箱即用的CRUD功能，同时还能利用Spring Data JPA提供的高级特性，如动态查询生成、分页、排序以及自定义查询等。</p>
<h2 id="只要定义方法？不需要实现"><a href="#只要定义方法？不需要实现" class="headerlink" title="只要定义方法？不需要实现"></a>只要定义方法？不需要实现</h2><p>在 Spring Data JPA 中，<strong>你只需要在继承了 <code>Repository</code>（或其子接口如 <code>CrudRepository</code>, <code>JpaRepository</code>）的接口中声明一个方法，而不需要提供任何实现</strong>。Spring Data JPA 会自动为你生成这个方法的实现。</p>
<p>这就是 Spring Data JPA 的核心魅力之一：<strong>约定优于配置</strong>（Convention over Configuration）。</p>
<hr>
<h3 id="这是怎么做到的？"><a href="#这是怎么做到的？" class="headerlink" title="这是怎么做到的？"></a>这是怎么做到的？</h3><p>这个过程主要依赖于以下几个关键技术：</p>
<ol>
<li><p><strong>接口代理 (Interface Proxy)</strong>：</p>
<ul>
<li>当你的 Spring 应用启动时，Spring 容器会扫描所有标记了 <code>@Repository</code> 注解（或通过 <code>@EnableJpaRepositories</code> 配置扫描到）的接口。</li>
<li>对于每个继承了 <code>Repository</code> 的接口（比如你的 <code>UserRepository</code>），Spring Data JPA 会利用 <strong>Java 动态代理</strong> 或 <strong>CGLIB</strong> 生成一个该接口的运行时实现类（代理类）。</li>
<li>这个生成的代理类包含了所有你在接口中声明的方法的具体实现。</li>
</ul>
</li>
<li><p><strong>方法名解析 (Query Derivation from Method Names)</strong>：</p>
<ul>
<li>Spring Data JPA 有一套非常智能的<strong>解析器</strong>，它会解析你定义的方法名。</li>
<li>它会将方法名拆解成有意义的单词（使用 <code>findBy</code>, <code>readBy</code>, <code>getBy</code>, <code>queryBy</code>, <code>searchBy</code>, <code>countBy</code>, <code>existsBy</code> 作为关键字前缀）。</li>
<li>接着，它会根据实体类（通过接口的泛型参数 <code>&lt;T&gt;</code> 确定）的属性名来匹配方法名中的剩余部分。</li>
<li>最后，它根据这些信息自动生成对应的 JPQL (Java Persistence Query Language) 查询。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设你有以下实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors, getters, setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你定义一个 Repository 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository 继承了 JpaRepository&lt;User, Long&gt;</span></span><br><span class="line"><span class="comment">// 这意味着它自动拥有了 findById, save, deleteById 等基础CRUD方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 最简单的 findByXXX</span></span><br><span class="line">    <span class="comment">// 方法名: findByLastName</span></span><br><span class="line">    <span class="comment">// 解析: find + By + LastName</span></span><br><span class="line">    <span class="comment">// 含义: 查找所有 lastName 属性等于传入参数的 User</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL: SELECT u FROM User u WHERE u.lastName = ?1</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 多条件查询 (And/Or)</span></span><br><span class="line">    <span class="comment">// 方法名: findByFirstNameAndLastName</span></span><br><span class="line">    <span class="comment">// 解析: find + By + FirstName + And + LastName</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL: SELECT u FROM User u WHERE u.firstName = ?1 AND u.lastName = ?2</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByFirstNameAndLastName</span><span class="params">(String firstName, String lastName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用比较操作符 (GreaterThan, LessThan, Between, Like, In, IsNull 等)</span></span><br><span class="line">    <span class="comment">// 方法名: findByAgeGreaterThan</span></span><br><span class="line">    <span class="comment">// 解析: find + By + Age + GreaterThan</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL: SELECT u FROM User u WHERE u.age &gt; ?1</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByAgeGreaterThan</span><span class="params">(Integer age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法名: findByLastNameContaining</span></span><br><span class="line">    <span class="comment">// 解析: find + By + LastName + Containing (等同于 LIKE %?%)</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL: SELECT u FROM User u WHERE u.lastName LIKE %?1%</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByLastNameContaining</span><span class="params">(String lastName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 排序 (OrderBy)</span></span><br><span class="line">    <span class="comment">// 方法名: findByLastNameOrderByFirstNameAsc</span></span><br><span class="line">    <span class="comment">// 解析: find + By + LastName + OrderBy + FirstName + Asc</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL: SELECT u FROM User u WHERE u.lastName = ?1 ORDER BY u.firstName ASC</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByLastNameOrderByFirstNameAsc</span><span class="params">(String lastName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 限制结果数量 (Top/First)</span></span><br><span class="line">    <span class="comment">// 方法名: findFirstByOrderByAgeDesc</span></span><br><span class="line">    <span class="comment">// 解析: find + First + By + OrderBy + Age + Desc</span></span><br><span class="line">    <span class="comment">// 含义: 查找年龄最大的一个用户</span></span><br><span class="line">    <span class="comment">// 自动生成的 JPQL (并设置结果限制): SELECT u FROM User u ORDER BY u.age DESC LIMIT 1</span></span><br><span class="line">    User <span class="title function_">findFirstByOrderByAgeDesc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>你只需要在你的 Service 或 Controller 中注入这个 <code>UserRepository</code>，然后就可以直接调用这些方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// Spring 会注入自动生成的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsersByLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用！Spring Data JPA 会执行自动生成的查询</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findByLastName(lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAdultsSortedByName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByLastNameOrderByFirstNameAsc(lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>你只定义接口和方法签名</strong>：你不需要写 <code>.java</code> 实现文件。</li>
<li><strong>Spring Data JPA 在运行时生成实现</strong>：利用代理技术。</li>
<li><strong>方法名遵循特定约定</strong>：Spring Data JPA 解析方法名，推断出你要执行的查询逻辑。</li>
<li><strong>自动生成 JPQL</strong>：根据解析结果，生成标准的 JPQL 查询语句。</li>
<li><strong>开箱即用</strong>：你可以在任何注入了 Repository 的地方直接调用这些方法。</li>
</ul>
<p>这种方式极大地减少了样板代码（boilerplate code），让你可以更专注于业务逻辑，而不是重复编写简单的数据库查询。当然，对于非常复杂的查询，你仍然可以使用 <code>@Query</code> 注解来手动编写 JPQL 或原生 SQL。</p>
<h2 id="方法名称解析器"><a href="#方法名称解析器" class="headerlink" title="方法名称解析器"></a>方法名称解析器</h2><p>在 Spring Data JPA 中，方法名解析（Query Derivation）是一种强大的功能，它允许你通过遵循特定的命名约定来定义查询方法，而无需手动编写 JPQL 或 SQL。Spring Data JPA 会根据方法名自动生成相应的查询。</p>
<p>方法名解析主要由**关键字（Keywords）<strong>和</strong>属性名（Property Names）**组成。</p>
<h3 id="1-主查询关键字-Query-Keywords-Start"><a href="#1-主查询关键字-Query-Keywords-Start" class="headerlink" title="1. 主查询关键字 (Query Keywords - Start)"></a>1. 主查询关键字 (Query Keywords - Start)</h3><p>这些关键字定义了查询的类型，通常作为方法名的前缀：</p>
<ul>
<li><strong><code>find...By</code></strong>: 最常用，用于查找实体。可以省略 <code>find</code>，直接用 <code>...By</code>。<ul>
<li>例如：<code>findByLastName</code>, <code>readByFirstName</code>, <code>getByAge</code>, <code>queryByEmail</code>, <code>searchByAddress</code></li>
</ul>
</li>
<li><strong><code>read...By</code></strong>: 同 <code>find...By</code>，语义上更强调“读取”。</li>
<li><strong><code>get...By</code></strong>: 同 <code>find...By</code>，语义上更强调“获取”。</li>
<li><strong><code>query...By</code></strong>: 同 <code>find...By</code>。</li>
<li><strong><code>search...By</code></strong>: 同 <code>find...By</code>。</li>
<li><strong><code>count...By</code></strong>: 返回满足条件的实体数量（<code>long</code> 类型）。<ul>
<li>例如：<code>countByStatus</code> -&gt; <code>SELECT COUNT(u) FROM User u WHERE u.status = ?1</code></li>
</ul>
</li>
<li><strong><code>exists...By</code></strong>: 检查是否存在满足条件的实体，返回 <code>boolean</code>。<ul>
<li>例如：<code>existsByEmail</code> -&gt; <code>SELECT u.id FROM User u WHERE u.email = ?1</code> (检查是否存在)</li>
</ul>
</li>
<li><strong><code>delete...By</code></strong> &#x2F; <strong><code>remove...By</code></strong>: 删除满足条件的实体，返回被删除的实体或数量。<ul>
<li>例如：<code>deleteByCreatedAtBefore(Date date)</code> -&gt; 删除创建时间早于指定日期的所有实体。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>: <code>find</code>, <code>read</code>, <code>get</code>, <code>query</code>, <code>search</code> 在生成查询时效果基本相同。<code>count</code>, <code>exists</code>, <code>delete</code>, <code>remove</code> 则改变了查询的目的。</p>
</blockquote>
<h3 id="2-条件关键字-Criteria-Keywords-Within-the-“By”-part"><a href="#2-条件关键字-Criteria-Keywords-Within-the-“By”-part" class="headerlink" title="2. 条件关键字 (Criteria Keywords - Within the “By” part)"></a>2. 条件关键字 (Criteria Keywords - Within the “By” part)</h3><p>在 <code>By</code> 之后，你可以使用以下关键字来构建查询条件。它们通常与实体的属性名结合使用。</p>
<h4 id="2-1-比较操作符-Comparison"><a href="#2-1-比较操作符-Comparison" class="headerlink" title="2.1 比较操作符 (Comparison)"></a>2.1 比较操作符 (Comparison)</h4><ul>
<li><strong><code>Is</code>, <code>Equals</code></strong>: 相等 (<code>=</code>)。<code>Is</code> 通常可省略。<ul>
<li>例如：<code>findByStatus</code>, <code>findByStatusIs</code>, <code>findByStatusEquals</code> (三者等价)</li>
</ul>
</li>
<li><strong><code>IsNot</code>, <code>Not</code></strong>: 不等于 (<code>&lt;&gt;</code> 或 <code>!=</code>)。<ul>
<li>例如：<code>findByStatusIsNot(ACTIVE)</code></li>
</ul>
</li>
<li><strong><code>Between</code></strong>: 在某个范围内 (<code>BETWEEN</code>)。需要两个参数。<ul>
<li>例如：<code>findByAgeBetween(int minAge, int maxAge)</code></li>
</ul>
</li>
<li><strong><code>LessThan</code></strong>: 小于 (<code>&lt;</code>)。<ul>
<li>例如：<code>findByAgeLessThan(18)</code></li>
</ul>
</li>
<li><strong><code>LessThanEqual</code></strong>: 小于等于 (<code>&lt;=</code>)。<ul>
<li>例如：<code>findByAgeLessThanEqual(18)</code></li>
</ul>
</li>
<li><strong><code>GreaterThan</code></strong>: 大于 (<code>&gt;</code>)。<ul>
<li>例如：<code>findByAgeGreaterThan(65)</code></li>
</ul>
</li>
<li><strong><code>GreaterThanEqual</code></strong>: 大于等于 (<code>&gt;=</code>)。<ul>
<li>例如：<code>findByAgeGreaterThanEqual(65)</code></li>
</ul>
</li>
<li><strong><code>After</code></strong>: 同 <code>GreaterThan</code> (常用于日期)。<ul>
<li>例如：<code>findByCreatedAtAfter(Date date)</code></li>
</ul>
</li>
<li><strong><code>Before</code></strong>: 同 <code>LessThan</code> (常用于日期)。<ul>
<li>例如：<code>findByCreatedAtBefore(Date date)</code></li>
</ul>
</li>
<li><strong><code>IsNull</code></strong>: 为 <code>NULL</code>。<ul>
<li>例如：<code>findByMiddleNameIsNull()</code></li>
</ul>
</li>
<li><strong><code>IsNotNull</code>, <code>NotNull</code></strong>: 不为 <code>NULL</code>。<ul>
<li>例如：<code>findByMiddleNameIsNotNull()</code></li>
</ul>
</li>
</ul>
<h4 id="2-2-模糊匹配-String-Matching"><a href="#2-2-模糊匹配-String-Matching" class="headerlink" title="2.2 模糊匹配 (String Matching)"></a>2.2 模糊匹配 (String Matching)</h4><ul>
<li><strong><code>Like</code></strong>: 模糊匹配 (<code>LIKE</code>)。通常需要在参数中手动添加 <code>%</code>。<ul>
<li>例如：<code>findByDescriptionLike(String desc)</code> -&gt; 调用时传入 <code>&quot;%keyword%&quot;</code></li>
</ul>
</li>
<li><strong><code>NotLike</code></strong>: 不模糊匹配 (<code>NOT LIKE</code>)。</li>
<li><strong><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></strong>: 以…开头 (<code>LIKE &#39;value%&#39;</code>)。<ul>
<li>例如：<code>findByFirstNameStartingWith(String prefix)</code></li>
</ul>
</li>
<li><strong><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></strong>: 以…结尾 (<code>LIKE &#39;%value&#39;</code>)。<ul>
<li>例如：<code>findByLastNameEndingWith(String suffix)</code></li>
</ul>
</li>
<li><strong><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></strong>: 包含 (<code>LIKE &#39;%value%&#39;</code>)。<ul>
<li>例如：<code>findByLastNameContaining(String infix)</code> -&gt; 自动添加 <code>%</code></li>
</ul>
</li>
</ul>
<h4 id="2-3-集合操作-Collection-Membership"><a href="#2-3-集合操作-Collection-Membership" class="headerlink" title="2.3 集合操作 (Collection&#x2F;Membership)"></a>2.3 集合操作 (Collection&#x2F;Membership)</h4><ul>
<li><strong><code>In</code></strong>: 在某个集合内 (<code>IN (...)</code>)。参数通常是一个 <code>Collection</code>。<ul>
<li>例如：<code>findByStatusIn(List&lt;Status&gt; statuses)</code></li>
</ul>
</li>
<li><strong><code>NotIn</code></strong>: 不在某个集合内 (<code>NOT IN (...)</code>)。<ul>
<li>例如：<code>findByStatusNotIn(List&lt;Status&gt; statuses)</code></li>
</ul>
</li>
</ul>
<h4 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h4><ul>
<li><strong><code>True</code></strong>, <strong><code>False</code></strong>: 匹配布尔值。<ul>
<li>例如：<code>findByActiveTrue()</code>, <code>findByActiveFalse()</code></li>
</ul>
</li>
</ul>
<h3 id="3-逻辑连接符-Logical-Keywords"><a href="#3-逻辑连接符-Logical-Keywords" class="headerlink" title="3. 逻辑连接符 (Logical Keywords)"></a>3. 逻辑连接符 (Logical Keywords)</h3><ul>
<li><strong><code>And</code></strong>: 逻辑与 (<code>AND</code>)。<ul>
<li>例如：<code>findByFirstNameAndLastName(String firstName, String lastName)</code></li>
</ul>
</li>
<li><strong><code>Or</code></strong>: 逻辑或 (<code>OR</code>)。<ul>
<li>例如：<code>findByFirstNameOrLastName(String firstName, String lastName)</code></li>
</ul>
</li>
</ul>
<h3 id="4-排序-Ordering"><a href="#4-排序-Ordering" class="headerlink" title="4. 排序 (Ordering)"></a>4. 排序 (Ordering)</h3><ul>
<li><strong><code>OrderBy...Asc</code></strong>: 按指定属性升序排列。</li>
<li><strong><code>OrderBy...Desc</code></strong>: 按指定属性降序排列。</li>
<li>可以链式使用多个排序条件。<ul>
<li>例如：<code>findByLastNameOrderByFirstNameAsc(String lastName)</code></li>
<li>例如：<code>findByStatusOrderByCreatedAtDescIdAsc(Status status)</code></li>
</ul>
</li>
</ul>
<h3 id="5-限制结果数量-Limiting"><a href="#5-限制结果数量-Limiting" class="headerlink" title="5. 限制结果数量 (Limiting)"></a>5. 限制结果数量 (Limiting)</h3><ul>
<li><strong><code>First</code></strong>, <strong><code>Top</code></strong>: 限制返回结果的数量。可以与数字结合使用。<ul>
<li>例如：<code>findFirstByOrderByAgeDesc()</code> -&gt; 返回年龄最大的一个用户。</li>
<li>例如：<code>findTop3ByStatusOrderByCreatedAtDesc(Status status)</code> -&gt; 返回指定状态的最新创建的3个用户。</li>
<li>例如：<code>findFirst10ByLastName(String lastName)</code> -&gt; 返回姓氏匹配的前10个用户。</li>
</ul>
</li>
</ul>
<h3 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h3><ol>
<li><strong>属性名匹配</strong>: 关键字后的部分必须<strong>精确匹配</strong>实体类（Entity）中的属性名（遵循 JavaBean 规范，区分大小写）。Spring Data JPA 会查找名为 <code>lastName</code> 的属性（<code>getLastName()</code> &#x2F; <code>setLastName()</code>）。</li>
<li><strong>驼峰命名</strong>: 方法名通常使用驼峰命名法（CamelCase）。</li>
<li><strong>参数顺序</strong>: 方法的参数必须按照它们在方法名中出现的顺序来声明。</li>
<li><strong>复杂查询</strong>: 对于极其复杂的查询，建议使用 <code>@Query</code> 注解来编写 JPQL 或原生 SQL，以获得更好的性能和可读性。</li>
<li><strong>文档参考</strong>: Spring Data JPA 的官方文档提供了最完整和权威的关键字列表及用法。</li>
</ol>
<h2 id="返回List"><a href="#返回List" class="headerlink" title="返回List"></a>返回List</h2><p>在 Spring Data JPA 中，Repository 接口的方法返回类型非常灵活，<code>Iterable&lt;T&gt;</code> 和 <code>Collection&lt;T&gt;</code>（及其子接口如 <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>）是两种最常用的返回多个实体对象的类型。它们的选择取决于你的具体需求。</p>
<hr>
<h3 id="1-Iterable"><a href="#1-Iterable" class="headerlink" title="1. Iterable&lt;T&gt;"></a>1. <code>Iterable&lt;T&gt;</code></h3><ul>
<li><strong>定义</strong>: <code>Iterable</code> 是 Java 集合框架中的一个<strong>基础接口</strong>。任何实现了 <code>Iterable</code> 的类都可以使用 <code>for-each</code> 循环进行遍历。</li>
<li><strong>特点</strong>:<ul>
<li><strong>最基础的抽象</strong>: <code>Iterable</code> 只定义了一个核心方法 <code>iterator()</code>，用于获取一个 <code>Iterator</code> 对象来遍历元素。它不关心元素的顺序、是否允许重复、是否有索引等特性。</li>
<li><strong>轻量级</strong>: 因为它是最基础的接口，所以作为返回类型非常通用和轻量。</li>
<li><strong>延迟加载友好</strong>: 当查询结果是懒加载（Lazy Loading）时，<code>Iterable</code> 只保证能遍历，而不会预先将所有数据加载到内存中（虽然 JPA 实现通常会加载）。</li>
<li><strong>功能有限</strong>: 除了遍历 (<code>forEach</code>) 和获取 <code>Iterator</code>，它没有提供 <code>size()</code>, <code>contains()</code> 等方法。</li>
</ul>
</li>
<li><strong>在 Spring Data JPA 中的使用</strong>:<ul>
<li><code>CrudRepository&lt;T, ID&gt;</code> 接口中的 <code>findAll()</code> 方法就返回 <code>Iterable&lt;T&gt;</code>。</li>
<li>任何你希望返回一个可遍历结果集，但不关心具体集合类型或不需要集合特定功能（如 <code>size()</code>, <code>get(index)</code>）的自定义查询方法，都可以使用 <code>Iterable&lt;T&gt;</code>。</li>
<li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 返回所有用户，你可以用 for-each 遍历</span></span><br><span class="line">    Iterable&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据姓氏查找，返回可遍历的用户集合</span></span><br><span class="line">    Iterable&lt;User&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Iterable&lt;User&gt; users = userRepository.findByLastName(<span class="string">&quot;Smith&quot;</span>);</span><br><span class="line">users.forEach(user -&gt; System.out.println(user.getFirstName()));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-Collection-及其子接口-List-Set"><a href="#2-Collection-及其子接口-List-Set" class="headerlink" title="2. Collection&lt;T&gt; 及其子接口 (List&lt;T&gt;, Set&lt;T&gt;)"></a>2. <code>Collection&lt;T&gt;</code> 及其子接口 (<code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>)</h3><ul>
<li><strong>定义</strong>: <code>Collection</code> 是 <code>Iterable</code> 的子接口，提供了比 <code>Iterable</code> 更丰富的操作，如 <code>size()</code>, <code>isEmpty()</code>, <code>contains()</code>, <code>add()</code>, <code>remove()</code> 等。<code>List</code> 和 <code>Set</code> 是 <code>Collection</code> 最重要的两个子接口。</li>
<li><strong>特点</strong>:<ul>
<li><strong><code>List&lt;T&gt;</code></strong>:<ul>
<li><strong>有序</strong>: 元素按照插入顺序或指定顺序（如 <code>OrderBy</code>）排列。</li>
<li><strong>可重复</strong>: 允许存储重复的元素。</li>
<li><strong>有索引</strong>: 可以通过索引 (<code>get(index)</code>) 访问元素。</li>
<li><strong>常用实现</strong>: <code>ArrayList</code>, <code>LinkedList</code>。</li>
<li><strong>适用场景</strong>: 当你需要保持查询结果的顺序（尤其是使用了 <code>OrderBy</code>），或者需要通过索引来访问元素时。</li>
</ul>
</li>
<li><strong><code>Set&lt;T&gt;</code></strong>:<ul>
<li><strong>无序 (通常)</strong>: 元素没有特定的顺序（<code>LinkedHashSet</code> 保持插入顺序，<code>TreeSet</code> 保持排序）。</li>
<li><strong>唯一</strong>: 不允许存储重复的元素。重复的判断基于 <code>equals()</code> 和 <code>hashCode()</code> 方法。</li>
<li><strong>适用场景</strong>: 当你希望查询结果自动去重，或者你关心的是元素的唯一性而不是顺序时。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 Spring Data JPA 中的使用</strong>:<ul>
<li><code>JpaRepository&lt;T, ID&gt;</code> 接口中的 <code>findAll()</code> 方法返回 <code>List&lt;T&gt;</code>，因为它继承了 <code>PagingAndSortingRepository</code>，后者通常期望一个有序的列表（尤其是在分页时）。</li>
<li>你可以明确地将自定义查询方法的返回类型声明为 <code>List&lt;T&gt;</code> 或 <code>Set&lt;T&gt;</code>，以表达你的意图或利用其特定功能。</li>
<li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 明确返回一个列表，保持顺序</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByLastNameOrderByFirstNameAsc</span><span class="params">(String lastName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确返回一个集合，自动去重（如果查询可能产生重复，但通常不会）</span></span><br><span class="line">    Set&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果查询结果天然有序或你需要索引访问</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop10ByOrderByScoreDesc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">List&lt;User&gt; sortedUsers = userRepository.findByLastNameOrderByFirstNameAsc(<span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sortedUsers.size(); <span class="comment">// 可以获取大小</span></span><br><span class="line"><span class="type">User</span> <span class="variable">firstUser</span> <span class="operator">=</span> sortedUsers.get(<span class="number">0</span>); <span class="comment">// 可以通过索引访问</span></span><br><span class="line"></span><br><span class="line">Set&lt;User&gt; activeUsers = userRepository.findByStatus(UserStatus.ACTIVE);</span><br><span class="line"><span class="comment">// activeUsers 保证了用户是唯一的</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="关键区别与选择建议"><a href="#关键区别与选择建议" class="headerlink" title="关键区别与选择建议"></a>关键区别与选择建议</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Iterable&lt;T&gt;</code></th>
<th align="left"><code>Collection&lt;T&gt;</code> &#x2F; <code>List&lt;T&gt;</code> &#x2F; <code>Set&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层级</strong></td>
<td align="left">最基础，只保证可遍历</td>
<td align="left">更高级，提供丰富操作</td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">仅支持遍历 (<code>forEach</code>, <code>iterator</code>)</td>
<td align="left">支持 <code>size()</code>, <code>isEmpty()</code>, <code>contains()</code>, <code>get(index)</code> (List) 等</td>
</tr>
<tr>
<td align="left"><strong>顺序</strong></td>
<td align="left">不保证</td>
<td align="left"><code>List</code> 保证有序，<code>Set</code> 通常不保证（<code>LinkedHashSet</code>, <code>TreeSet</code> 除外）</td>
</tr>
<tr>
<td align="left"><strong>重复元素</strong></td>
<td align="left">不保证</td>
<td align="left"><code>Set</code> 保证唯一，<code>List</code> 允许重复</td>
</tr>
<tr>
<td align="left"><strong>内存</strong></td>
<td align="left">概念上更轻量（但JPA实现通常加载所有）</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="left"><strong>常用场景</strong></td>
<td align="left">通用遍历，不关心具体集合特性</td>
<td align="left">需要 <code>size()</code>、索引访问(<code>List</code>)、自动去重(<code>Set</code>)、明确表达意图</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>:</p>
<ol>
<li><strong>通用遍历</strong>: 如果你只需要遍历结果，不关心顺序、大小或是否重复，使用 <code>Iterable&lt;T&gt;</code> 是安全且通用的选择。</li>
<li><strong>需要顺序或索引</strong>: 如果查询使用了 <code>OrderBy</code> 或你需要通过索引访问元素，<strong>优先使用 <code>List&lt;T&gt;</code></strong>。</li>
<li><strong>需要去重</strong>: 如果你希望结果集自动排除重复项（虽然数据库查询通常不会返回重复实体，除非有特殊 JOIN），使用 <code>Set&lt;T&gt;</code>。</li>
<li><strong>需要集合方法</strong>: 如果你需要调用 <code>size()</code>, <code>isEmpty()</code>, <code>contains()</code> 等方法，使用 <code>Collection&lt;T&gt;</code> 或其子接口。</li>
<li><strong>遵循约定</strong>: 如果你继承的是 <code>JpaRepository</code>，其默认的 <code>findAll()</code> 返回 <code>List&lt;T&gt;</code>，为了保持一致性，你的自定义查询方法也常返回 <code>List&lt;T&gt;</code>，尤其是涉及排序时。</li>
</ol>
<p><strong>总结</strong>: <code>Iterable&lt;T&gt;</code> 是最基础的返回类型，适用于简单的遍历场景。<code>List&lt;T&gt;</code> 和 <code>Set&lt;T&gt;</code> 提供了更强的语义和更丰富的功能。在实际开发中，<code>List&lt;T&gt;</code> 因为其有序性和易用性（支持索引），在返回多个实体时使用得非常广泛。</p>
<h2 id="Spring-Null-Safety-注解详解"><a href="#Spring-Null-Safety-注解详解" class="headerlink" title="Spring Null-Safety 注解详解"></a>Spring Null-Safety 注解详解</h2><ul>
<li><p><strong><code>@NonNullApi</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 这是一个<strong>包级别的注解</strong>（通常放在 <code>package-info.java</code> 文件中）。</li>
<li><strong>效果</strong>: 它为该包（及其子包）下的所有类和接口中，所有<strong>没有明确标注</strong> <code>@Nullable</code> 的方法<strong>参数</strong>和<strong>返回值</strong>，<strong>设定一个默认行为</strong>——即它们<strong>不允许为 <code>null</code></strong>。</li>
<li><strong>目的</strong>: 避免在每个方法上重复写 <code>@NonNull</code>，实现“非空是常态”的约定。</li>
</ul>
</li>
<li><p><strong><code>@NonNull</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 直接标注在<strong>方法的参数</strong>或<strong>返回值</strong>上。</li>
<li><strong>效果</strong>: 明确声明这个参数<strong>不能传入 <code>null</code></strong>，或者这个方法的返回值<strong>不能是 <code>null</code></strong>。</li>
<li><strong>注意</strong>: 如果包上已经有 <code>@NonNullApi</code>，那么方法参数和返回值默认就是 <code>@NonNull</code> 的，所以通常不需要显式写出，除非你想在某个 <code>@Nullable</code> 的包里明确一个非空方法。</li>
</ul>
</li>
<li><p><strong><code>@Nullable</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 直接标注在<strong>方法的参数</strong>或<strong>返回值</strong>上。</li>
<li><strong>效果</strong>: 明确声明这个参数<strong>可以传入 <code>null</code></strong>，或者这个方法的返回值<strong>可以是 <code>null</code></strong>。</li>
<li><strong>目的</strong>: 覆盖 <code>@NonNullApi</code> 的默认行为，或者在没有 <code>@NonNullApi</code> 的包里明确指出某个地方可以为 null。</li>
</ul>
</li>
</ul>
<h3 id="3-运行时检查机制"><a href="#3-运行时检查机制" class="headerlink" title="3. 运行时检查机制"></a>3. 运行时检查机制</h3><p>当你在包上启用了 <code>@NonNullApi</code> 后，Spring Data JPA 会在运行时对 Repository 方法进行代理，执行以下检查：</p>
<ul>
<li><strong>参数检查</strong>:<ul>
<li>如果一个参数被 <code>@NonNull</code> (或受 <code>@NonNullApi</code> 影响) 标记，但你传入了 <code>null</code>，Spring 会在方法执行前抛出 <code>IllegalArgumentException</code>。</li>
</ul>
</li>
<li><strong>返回值检查</strong>:<ul>
<li>如果一个方法的返回值被 <code>@NonNull</code> (或受 <code>@NonNullApi</code> 影响) 标记，但数据库查询<strong>没有找到任何结果</strong>（即结果为 <code>null</code> 或空集合），Spring 会抛出 <code>EmptyResultDataAccessException</code>。</li>
<li><strong>例外情况</strong>: 如果返回类型是 <code>Optional&lt;T&gt;</code>, <code>Future&lt;T&gt;</code>, <code>CompletableFuture&lt;T&gt;</code>, <code>Stream&lt;T&gt;</code> 等“包装器”（wrapper）类型，即使方法被 <code>@NonNull</code> 标记，查询无结果时也不会抛异常，而是返回 <code>Optional.empty()</code>, <code>Stream.empty()</code> 等，这是这些包装器类型的预期行为。</li>
</ul>
</li>
</ul>
<h2 id="QuerydslPredicateExecutor"><a href="#QuerydslPredicateExecutor" class="headerlink" title="QuerydslPredicateExecutor"></a>QuerydslPredicateExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuerydslPredicateExecutor</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(Predicate predicate)</span>;  (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Predicate predicate)</span>;   (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">count</span><span class="params">(Predicate predicate)</span>;            (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Predicate predicate)</span>;        (<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>QuerydslPredicateExecutor</code> 是 Spring Data 提供的一个接口，它允许你在 Repository 中集成 Querydsl 的强大查询功能。通过继承这个接口，你可以轻松地为你的 Repository 添加动态查询支持，而无需手动编写查询方法。下面是对 <code>QuerydslPredicateExecutor</code> 的详细介绍。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li><strong>动态查询</strong>: 允许根据运行时条件构建查询，而不是预先定义的查询方法。</li>
<li><strong>类型安全</strong>: Querydsl 生成的 Q 类型提供了编译期检查，减少了运行时错误的可能性。</li>
<li><strong>简化查询逻辑</strong>: 减少了大量样板代码，使开发者能够更专注于业务逻辑。</li>
</ul>
<h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p><code>QuerydslPredicateExecutor&lt;T&gt;</code> 定义了几个核心方法，这些方法可以用来执行基于 Predicate 的查询操作：</p>
<ol>
<li><p><strong><code>Iterable&lt;T&gt; findAll(Predicate predicate)</code></strong>:</p>
<ul>
<li>根据给定的 <code>Predicate</code>（谓词）返回所有匹配的实体。</li>
</ul>
</li>
<li><p><strong><code>T findOne(Predicate predicate)</code></strong> (在新版本中可能已被弃用或替换为其他形式):</p>
<ul>
<li>返回与给定 <code>Predicate</code> 匹配的第一个实体。注意，在处理多个匹配项时的行为可能会有所不同，取决于具体的实现细节。</li>
</ul>
</li>
<li><p><strong><code>boolean exists(Predicate predicate)</code></strong>:</p>
<ul>
<li>检查是否存在任何满足给定 <code>Predicate</code> 的实体。</li>
</ul>
</li>
<li><p><strong><code>long count(Predicate predicate)</code></strong>:</p>
<ul>
<li>计算满足给定 <code>Predicate</code> 的实体数量。</li>
</ul>
</li>
<li><p><strong><code>Optional&lt;T&gt; findById(ID id)</code></strong> 和 <strong><code>void deleteById(ID id)</code></strong> 等基本 CRUD 方法<strong>不会直接出现在 <code>QuerydslPredicateExecutor</code> 中</strong>，但如果你让你的 Repository 同时继承自 <code>JpaRepository</code> 或类似的接口，那么这些方法也会可用。</p>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>首先，你需要确保项目中已经配置好对 Querydsl 的支持，并且相应的 Q 类已经被正确生成。</p>
<p>假设我们有一个 <code>User</code> 实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">// Getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建一个 Repository 接口并继承 <code>QuerydslPredicateExecutor&lt;User&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.querydsl.QuerydslPredicateExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义查询方法可以在这里定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，你可以在服务层使用 <code>UserRepository</code> 来执行动态查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.querydsl.core.BooleanBuilder;</span><br><span class="line"><span class="keyword">import</span> com.querydsl.core.types.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;User&gt; <span class="title function_">findUsersByConditions</span><span class="params">(String firstName, String lastName)</span> &#123;</span><br><span class="line">        <span class="type">BooleanBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BooleanBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (firstName != <span class="literal">null</span> &amp;&amp; !firstName.isEmpty()) &#123;</span><br><span class="line">            builder.and(QUser.user.firstName.eq(firstName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastName != <span class="literal">null</span> &amp;&amp; !lastName.isEmpty()) &#123;</span><br><span class="line">            builder.and(QUser.user.lastName.eq(lastName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll(builder.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>BooleanBuilder</code> 被用来根据提供的参数动态构建查询条件。这样做的好处是，无论用户提供的是部分还是全部搜索条件，代码都能很好地适应。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>依赖管理</strong>: 确保项目中包含了正确的 Querydsl 相关依赖，并且你的构建工具（如 Maven 或 Gradle）配置正确以生成 Q 类。</li>
<li><strong>性能考虑</strong>: 尽管 Querydsl 提供了强大的查询能力，但在构建复杂查询时仍需考虑性能问题，特别是当涉及到大量的 OR 条件或嵌套查询时。</li>
<li><strong>学习曲线</strong>: 对于初次接触 Querydsl 的开发者来说，理解和掌握其语法和最佳实践可能需要一些时间。</li>
</ul>
<p>总之，<code>QuerydslPredicateExecutor</code> 提供了一种灵活、类型安全的方式来执行动态查询，特别适合那些需要根据用户输入或其他运行时条件来构建查询的应用场景。</p>
<h2 id="query注解"><a href="#query注解" class="headerlink" title="query注解"></a>query注解</h2><p>在Spring Data JPA中，<code>@Query</code> 注解是一个非常强大的工具，它允许开发者直接定义JPQL（Java Persistence Query Language）或原生SQL查询。这为执行更复杂的查询提供了极大的灵活性，而不仅仅是依赖于Spring Data JPA提供的方法命名约定来生成查询。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li><strong>自定义查询</strong>：通过 <code>@Query</code> 注解，你可以定义任意复杂的查询逻辑。</li>
<li><strong>支持JPQL和原生SQL</strong>：可以使用JPQL进行面向对象的查询，也可以选择使用原生SQL语句直接操作数据库表。</li>
<li><strong>参数绑定</strong>：支持命名参数和位置参数两种方式，便于动态地向查询中插入变量值。</li>
</ul>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="1-JPQL-查询"><a href="#1-JPQL-查询" class="headerlink" title="1. JPQL 查询"></a>1. JPQL 查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email = ?1&quot;)</span></span><br><span class="line">    User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>?1</code> 表示第一个方法参数，即 <code>String email</code>。你也可以使用命名参数的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email = :email&quot;)</span></span><br><span class="line">    User <span class="title function_">findByEmail</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>:email</code> 是命名参数，<code>@Param(&quot;email&quot;)</code> 标记了传入的参数名与查询中的参数名对应。</p>
<h4 id="2-原生SQL查询"><a href="#2-原生SQL查询" class="headerlink" title="2. 原生SQL查询"></a>2. 原生SQL查询</h4><p>如果你需要执行原生SQL查询，可以通过设置 <code>nativeQuery=true</code> 来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM USERS u WHERE u.email = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByEmailAddress</span><span class="params">(String emailAddress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，当使用原生SQL时，你需要直接引用数据库表名和列名，而不是实体类及其属性名。</p>
<h4 id="3-更新和删除操作"><a href="#3-更新和删除操作" class="headerlink" title="3. 更新和删除操作"></a>3. 更新和删除操作</h4><p>除了查询，<code>@Query</code> 注解还可以用于执行更新和删除操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;update User u set u.status = ?1 where u.id = ?2&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateUserStatus</span><span class="params">(String status, Long id)</span>;</span><br></pre></td></tr></table></figure>

<p>这里，<code>@Modifying</code> 注解表明这是一个修改操作。对于这种类型的查询，必须加上 <code>@Modifying</code> 注解，并且通常还需要事务管理。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><ul>
<li><strong>位置参数</strong>：如上所示，通过 <code>?</code> 加数字表示参数的位置。</li>
<li><strong>命名参数</strong>：使用 <code>:</code> 加参数名，这种方式更加直观，尤其是在有多个参数的情况下。</li>
<li><strong>SpEL表达式</strong>：在某些情况下，可以使用Spring Expression Language (SpEL) 来构建查询字符串。</li>
</ul>
<h3 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h3><p><code>@Query</code> 注解也支持分页和排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.lastname = :lastname&quot;)</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>

<p>这里，<code>Pageable</code> 参数使得我们可以轻松实现分页查询。类似的，可以使用 <code>Sort</code> 对象来指定排序规则。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>@Query</code> 注解极大地增强了Spring Data JPA的功能，使我们能够编写灵活、高效的查询。无论是简单的查询还是复杂的多表联查，都可以通过它来实现。同时，结合命名参数、位置参数以及对原生SQL的支持，让数据访问层的开发既方便又强大。不过，在享受其便利的同时，也要注意保持查询的可读性和维护性，特别是在编写复杂查询时。</p>
<h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>在 Spring Data JPA 中，<strong>投影（Projection）</strong> 是一种强大的功能，它允许你从数据库查询中只选择你需要的字段，而不是加载整个实体对象。这可以显著提高性能（减少数据传输和内存占用），并让你更灵活地组织返回的数据结构。</p>
<p>投影主要分为三种类型：<strong>基于接口的投影（Interface-based Projection）</strong>、<strong>基于类的投影（Class-based Projection &#x2F; DTO Projection）</strong> 和 <strong>动态投影（Dynamic Projection）</strong>。</p>
<hr>
<h3 id="1-基于接口的投影-Interface-based-Projection"><a href="#1-基于接口的投影-Interface-based-Projection" class="headerlink" title="1. 基于接口的投影 (Interface-based Projection)"></a>1. 基于接口的投影 (Interface-based Projection)</h3><p>这是最简单和常用的投影方式。你定义一个接口，其中包含你希望从实体中获取的属性的 getter 方法。Spring Data JPA 会为这个接口生成一个实现类，该实现类在查询时只选择接口中定义的字段。</p>
<p><strong>特点</strong>:</p>
<ul>
<li><strong>只读</strong>: 投影接口是只读的，不能用于更新。</li>
<li><strong>封闭投影 (Closed Projection)</strong>: 默认情况下，接口投影是封闭的。这意味着即使你定义了 <code>getDetails()</code> 方法，但如果 <code>User</code> 实体中没有 <code>details</code> 字段或对应的 getter，查询会失败。你不能随意添加实体中不存在的属性。</li>
<li><strong>开放投影 (Open Projection)</strong>: 通过在接口方法上使用 <code>@Value</code> 注解，可以创建开放投影，允许包含计算值或来自其他来源的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义投影接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserNameOnly</span> &#123;</span><br><span class="line">    String <span class="title function_">getFirstName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getLastName</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 注意：方法名必须与实体属性的 getter 方法名完全匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 Repository 中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 查询将只 SELECT firstName 和 lastName 字段</span></span><br><span class="line">    List&lt;UserNameOnly&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line">List&lt;UserNameOnly&gt; users = userRepository.findByLastName(<span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (UserNameOnly user : users) &#123;</span><br><span class="line">    System.out.println(user.getFirstName() + <span class="string">&quot; &quot;</span> + user.getLastName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开放投影示例 (使用 <code>@Value</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserSummary</span> &#123;</span><br><span class="line">    String <span class="title function_">getFirstName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getLastName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是一个计算属性，不是 User 实体的直接字段</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;target.firstName + &#x27; &#x27; + target.lastName&#125;&quot;)</span></span><br><span class="line">    String <span class="title function_">getFullName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以引用其他 bean 的方法</span></span><br><span class="line">    <span class="comment">// @Value(&quot;#&#123;@myService.someMethod(target)&#125;&quot;)</span></span><br><span class="line">    <span class="comment">// String getCustomProperty();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-基于类的投影-Class-based-Projection-DTO-Projection"><a href="#2-基于类的投影-Class-based-Projection-DTO-Projection" class="headerlink" title="2. 基于类的投影 (Class-based Projection &#x2F; DTO Projection)"></a>2. 基于类的投影 (Class-based Projection &#x2F; DTO Projection)</h3><p>这种方式是通过定义一个具体的类（通常是 POJO 或 record）来接收查询结果。你需要为这个类提供一个构造函数，其参数顺序和类型必须与 JPQL 查询 <code>SELECT</code> 子句中的字段顺序和类型匹配。</p>
<p><strong>特点</strong>:</p>
<ul>
<li><strong>更灵活</strong>: 可以包含自定义的构造函数逻辑。</li>
<li><strong>可变性</strong>: DTO 类的属性可以是可变的（有 setter），尽管通常设计为不可变。</li>
<li><strong>类型安全</strong>: 构造函数参数提供了编译时检查。</li>
<li><strong>需要构造函数</strong>: 必须有一个构造函数匹配 <code>SELECT</code> 的字段。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 DTO 类 (Data Transfer Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNameAndAge</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数的参数顺序必须与 JPQL SELECT 子句中的字段顺序完全一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserNameAndAge</span><span class="params">(String firstName, String lastName, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 Repository 中使用 (需要配合 @Query)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u.firstName, u.lastName, u.age FROM User u WHERE u.lastName = ?1&quot;)</span></span><br><span class="line">    List&lt;UserNameAndAge&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line">List&lt;UserNameAndAge&gt; users = userRepository.findByLastName(<span class="string">&quot;Smith&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用 Record (Java 14+)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 record 更简洁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">UserNameAndAgeRecord</span><span class="params">(String firstName, String lastName, Integer age)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repository 方法签名不变，但构造函数匹配 record 的隐式构造函数</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT u.firstName, u.lastName, u.age FROM User u WHERE u.lastName = ?1&quot;)</span></span><br><span class="line">List&lt;UserNameAndAgeRecord&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-动态投影-Dynamic-Projection"><a href="#3-动态投影-Dynamic-Projection" class="headerlink" title="3. 动态投影 (Dynamic Projection)"></a>3. 动态投影 (Dynamic Projection)</h3><p>动态投影允许你在调用 Repository 方法时，动态地决定返回哪种投影类型。这是通过将投影类型作为方法的<strong>泛型参数</strong>传递来实现的。</p>
<p><strong>特点</strong>:</p>
<ul>
<li><strong>高度灵活</strong>: 同一个方法可以根据需要返回不同的投影。</li>
<li><strong>需要 Class 参数</strong>: 方法必须接受一个 <code>Class&lt;T&gt;</code> 类型的参数来指定返回的投影类型。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义多个投影 (接口或类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserNameOnly</span> &#123;</span><br><span class="line">    String <span class="title function_">getFirstName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getLastName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSummaryDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserSummaryDto</span><span class="params">(String fullName, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fullName = fullName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 Repository 中定义动态投影方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// T 可以是 UserNameOnly (接口) 或 UserSummaryDto (类)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">findByEmail</span><span class="params">(String email, Class&lt;T&gt; type)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 (动态决定返回类型)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demonstrateDynamicProjection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 想要接口投影</span></span><br><span class="line">        <span class="type">UserNameOnly</span> <span class="variable">user1</span> <span class="operator">=</span> userRepository.findByEmail(<span class="string">&quot;john@example.com&quot;</span>, UserNameOnly.class);</span><br><span class="line">        System.out.println(user1.getFirstName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要 DTO 投影</span></span><br><span class="line">        <span class="type">UserSummaryDto</span> <span class="variable">user2</span> <span class="operator">=</span> userRepository.findByEmail(<span class="string">&quot;john@example.com&quot;</span>, UserSummaryDto.class);</span><br><span class="line">        System.out.println(user2.getFullName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 动态投影方法通常需要配合 <code>@Query</code> 注解来确保 SELECT 的字段能匹配目标投影类型。</p>
<hr>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">投影类型</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>接口投影</strong></td>
<td align="left">简单，无需额外类，支持 <code>@Value</code> 计算属性。</td>
<td align="left">只读，封闭性（默认），方法名必须匹配。</td>
<td align="left">快速获取实体的子集字段，包含简单计算逻辑。</td>
</tr>
<tr>
<td align="left"><strong>DTO 投影</strong></td>
<td align="left">类型安全，构造函数编译检查，可包含复杂逻辑，支持 record。</td>
<td align="left">需要定义额外的类和匹配的构造函数。</td>
<td align="left">需要将数据传递到服务层或视图层，结构相对固定。</td>
</tr>
<tr>
<td align="left"><strong>动态投影</strong></td>
<td align="left">极致灵活，一个方法支持多种返回类型。</td>
<td align="left">使用稍复杂，需要传入 <code>Class</code> 参数。</td>
<td align="left">同一查询需要根据上下文返回不同数据结构的场景。</td>
</tr>
</tbody></table>
<p>选择哪种投影方式取决于你的具体需求：性能要求、数据结构的复杂性、是否需要计算属性以及灵活性要求。合理使用投影是优化 Spring Data JPA 应用性能的关键技巧之一。</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li>Springboot 集成 JPA：<a target="_blank" rel="noopener" href="https://springdoc.cn/spring-boot-and-spring-data-jpa/">https://springdoc.cn/spring-boot-and-spring-data-jpa/</a></li>
<li>SpringDataJpa官方文档：<a target="_blank" rel="noopener" href="https://springdoc.cn/spring-data-jpa">https://springdoc.cn/spring-data-jpa</a></li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Joie</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/07/31/SpringDataJpa/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/07/31/SpringDataJpa/')">SpringDataJpa</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/07/31/SpringDataJpa/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=SpringDataJpa&amp;url=http://example.com/2025/07/31/SpringDataJpa/&amp;pic=https://img.picgo.net/2025/07/31/OIP-C-1c4afe270c9ab00e7.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JPA/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JPA<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/ORM/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>ORM<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://origin.picgo.net/2025/08/08/2738901-20230326221925205-10674419245f2fcf4ef2c78d84.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/29/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C_%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8+AOP/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/07/28/92d72a800c774c71ace0837f371d2c4716c648473f7f5f0d.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">优雅处理 HTTP 请求</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/01/%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86Entity%E8%BD%AC%E6%8D%A2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.616pic.com/ys_bnew_img/00/25/56/FgPV3rWoMg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">优雅处理Entity转换</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Joie</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/BenedictTom" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/372204786" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JPA-%E4%B8%8E-JDBC-%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AF%B9%E6%AF%94"><span class="toc-number">1.</span> <span class="toc-text">JPA 与 JDBC 全方位对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1. 设计理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2. 抽象层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4. 性能与灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">5. 数据库移植性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF"><span class="toc-number">1.6.</span> <span class="toc-text">6. 学习曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.</span> <span class="toc-text">7. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">ORM框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ORM%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">ORM框架的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8EORM%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.</span> <span class="toc-text">MyBatis是否属于ORM框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringDataJpa-%E4%B8%8E-Mybatis%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%B7%AE%E5%BC%82%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">SpringDataJpa 与 Mybatis对比，差异点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5-1"><span class="toc-number">3.1.</span> <span class="toc-text">1. 设计理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 数据库操作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF"><span class="toc-number">3.3.</span> <span class="toc-text">3. 学习曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%81%B5%E6%B4%BB%E6%80%A7%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8A%9B"><span class="toc-number">3.4.</span> <span class="toc-text">4. 灵活性和控制力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">5. 性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.6.</span> <span class="toc-text">6. 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringDataJpa-%E4%B8%8E-Mybatis-Plus%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%B7%AE%E5%BC%82%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">SpringDataJpa 与 Mybatis Plus对比，差异点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%B7%AE%E5%BC%82%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">主要差异点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. 设计理念和抽象层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90CRUD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">2. 自动生成CRUD的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. 灵活性与性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.1.4.</span> <span class="toc-text">4. 学习曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.5.</span> <span class="toc-text">5. 适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repository"><span class="toc-number">5.</span> <span class="toc-text">Repository</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Repository%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">Repository接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">主要扩展接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.3.</span> <span class="toc-text">自定义查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%A6%81%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%EF%BC%9F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">只要定义方法？不需要实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">这是怎么做到的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">6.2.</span> <span class="toc-text">举个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">方法名称解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97-Query-Keywords-Start"><span class="toc-number">7.1.</span> <span class="toc-text">1. 主查询关键字 (Query Keywords - Start)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AD%97-Criteria-Keywords-Within-the-%E2%80%9CBy%E2%80%9D-part"><span class="toc-number">7.2.</span> <span class="toc-text">2. 条件关键字 (Criteria Keywords - Within the “By” part)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-Comparison"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 比较操作符 (Comparison)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D-String-Matching"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 模糊匹配 (String Matching)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C-Collection-Membership"><span class="toc-number">7.2.3.</span> <span class="toc-text">2.3 集合操作 (Collection&#x2F;Membership)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%85%B6%E4%BB%96"><span class="toc-number">7.2.4.</span> <span class="toc-text">2.4 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%9E%E6%8E%A5%E7%AC%A6-Logical-Keywords"><span class="toc-number">7.3.</span> <span class="toc-text">3. 逻辑连接符 (Logical Keywords)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%92%E5%BA%8F-Ordering"><span class="toc-number">7.4.</span> <span class="toc-text">4. 排序 (Ordering)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C%E6%95%B0%E9%87%8F-Limiting"><span class="toc-number">7.5.</span> <span class="toc-text">5. 限制结果数量 (Limiting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%8F%90%E7%A4%BA"><span class="toc-number">7.6.</span> <span class="toc-text">重要提示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9EList"><span class="toc-number">8.</span> <span class="toc-text">返回List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Iterable"><span class="toc-number">8.1.</span> <span class="toc-text">1. Iterable&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Collection-%E5%8F%8A%E5%85%B6%E5%AD%90%E6%8E%A5%E5%8F%A3-List-Set"><span class="toc-number">8.2.</span> <span class="toc-text">2. Collection&lt;T&gt; 及其子接口 (List&lt;T&gt;, Set&lt;T&gt;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.3.</span> <span class="toc-text">关键区别与选择建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Null-Safety-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">Spring Null-Safety 注解详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">3. 运行时检查机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QuerydslPredicateExecutor"><span class="toc-number">10.</span> <span class="toc-text">QuerydslPredicateExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.</span> <span class="toc-text">主要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">接口方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.3.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#query%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">query注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">11.1.</span> <span class="toc-text">主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">11.2.</span> <span class="toc-text">使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JPQL-%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.2.1.</span> <span class="toc-text">1. JPQL 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E7%94%9FSQL%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.2.2.</span> <span class="toc-text">2. 原生SQL查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">11.2.3.</span> <span class="toc-text">3. 更新和删除操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">11.3.</span> <span class="toc-text">参数绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">11.4.</span> <span class="toc-text">分页和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">11.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1"><span class="toc-number">12.</span> <span class="toc-text">投影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8A%95%E5%BD%B1-Interface-based-Projection"><span class="toc-number">12.1.</span> <span class="toc-text">1. 基于接口的投影 (Interface-based Projection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E6%8A%95%E5%BD%B1-Class-based-Projection-DTO-Projection"><span class="toc-number">12.2.</span> <span class="toc-text">2. 基于类的投影 (Class-based Projection &#x2F; DTO Projection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E6%8A%95%E5%BD%B1-Dynamic-Projection"><span class="toc-number">12.3.</span> <span class="toc-text">3. 动态投影 (Dynamic Projection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">12.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/ElasticSearch%E6%9F%A5%E8%AF%A2/" title="ElasticSearch查询"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/08/2738901-20230326221925205-10674419245f2fcf4ef2c78d84.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch查询"/></a><div class="content"><a class="title" href="/2025/08/08/ElasticSearch%E6%9F%A5%E8%AF%A2/" title="ElasticSearch查询">ElasticSearch查询</a><time datetime="2025-08-08T09:54:26.365Z" title="Created 2025-08-08 17:54:26">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/ElasticSearch/" title="ElasticSearch基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/08/2738901-20230326221925205-10674419245f2fcf4ef2c78d84.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch基础"/></a><div class="content"><a class="title" href="/2025/08/08/ElasticSearch/" title="ElasticSearch基础">ElasticSearch基础</a><time datetime="2025-08-08T06:59:21.191Z" title="Created 2025-08-08 14:59:21">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/Es_SpringData/" title="Es_SpringData"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/08/2738901-20230326221925205-10674419245f2fcf4ef2c78d84.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Es_SpringData"/></a><div class="content"><a class="title" href="/2025/08/08/Es_SpringData/" title="Es_SpringData">Es_SpringData</a><time datetime="2025-08-08T04:04:22.200Z" title="Created 2025-08-08 12:04:22">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/08/Es_7.x_Vs_8.x/" title="Es_7.x_Vs_8.x"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/08/2738901-20230326221925205-10674419245f2fcf4ef2c78d84.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Es_7.x_Vs_8.x"/></a><div class="content"><a class="title" href="/2025/08/08/Es_7.x_Vs_8.x/" title="Es_7.x_Vs_8.x">Es_7.x_Vs_8.x</a><time datetime="2025-08-08T02:40:23.836Z" title="Created 2025-08-08 10:40:23">2025-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/Redis_Hash/" title="Redis_Hash"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/07/1eb94f064cf74b04865bdaf1b3c8e9be6939674b9205c975.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis_Hash"/></a><div class="content"><a class="title" href="/2025/08/07/Redis_Hash/" title="Redis_Hash">Redis_Hash</a><time datetime="2025-08-07T10:06:45.396Z" title="Created 2025-08-07 18:06:45">2025-08-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Joie" target="_blank">Joie</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">30</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">19</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">个人主页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://benedicttom.github.io/home/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CI-CD/" style="font-size: 0.88rem;">CI/CD<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 0.88rem;">ElasticSearch<sup>4</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/Http/" style="font-size: 0.88rem;">Http<sup>1</sup></a><a href="/tags/JPA/" style="font-size: 0.88rem;">JPA<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>6</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>2</sup></a><a href="/tags/ORM/" style="font-size: 0.88rem;">ORM<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>3</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>4</sup></a><a href="/tags/Spring-Boot/" style="font-size: 0.88rem;">Spring Boot<sup>1</sup></a><a href="/tags/SpringData/" style="font-size: 0.88rem;">SpringData<sup>1</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 0.88rem;">中间件<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 0.88rem;">云原生<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 0.88rem;">八股<sup>1</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3/" style="font-size: 0.88rem;">力扣<sup>10</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>7</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 0.88rem;">定时任务<sup>3</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>7</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">开发工具<sup>2</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">推荐<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>4</sup></a><a href="/tags/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">权限校验<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 0.88rem;">树<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">消息队列<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 0.88rem;">缓存<sup>1</sup></a><a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 0.88rem;">运维<sup>2</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Joie 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>