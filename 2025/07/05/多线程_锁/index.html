<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>多线程_锁 | Joie's Blog</title><meta name="keywords" content="多线程,并发"><meta name="author" content="Joie"><meta name="copyright" content="Joie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="多线程_锁"><meta name="application-name" content="多线程_锁"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="多线程_锁"><meta property="og:url" content="http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/index.html"><meta property="og:site_name" content="Joie's Blog"><meta property="og:description" content="synchronizedsynchronized 是 Java 编程语言中的一个关键字，用于实现线程同步（Thread Synchronization），以确保多个线程在并发访问共享资源时的正确性和可见性。它是 Java 提供的一种内置锁机制，也被称为监视器锁（Monitor Lock）或对象锁（I"><meta property="og:locale" content="en"><meta property="og:image" content="https://img.picgo.net/2025/07/07/0963a560354758f9ef0c7067907aa1405fffec21d4abeea6.png"><meta property="article:author" content="Joie"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.picgo.net/2025/07/07/0963a560354758f9ef0c7067907aa1405fffec21d4abeea6.png"><meta name="description" content="synchronizedsynchronized 是 Java 编程语言中的一个关键字，用于实现线程同步（Thread Synchronization），以确保多个线程在并发访问共享资源时的正确性和可见性。它是 Java 提供的一种内置锁机制，也被称为监视器锁（Monitor Lock）或对象锁（I"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"Here","backTitle":"Welcome"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Joie","link":"Link: ","source":"Source: Joie's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Joie\'s Blog',
  title: '多线程_锁',
  postAI: '',
  pageFillDescription: 'synchronized, 一、作用, 二、使用方式, 1. 同步方法（Synchronized Method）, 2. 同步代码块（Synchronized Block）, 3. 静态方法同步, 三、锁的特性, 1. 可重入（Reentrant）, 2. 不可中断（Non-interruptible）, 3. 非公平锁（Non-Fair）, 四、底层原理简述, 五、优缺点对比, 六、替代方案, 七、总结, syn-ed, 使用锁, 同步块, 同步方法, ✅ synchronized 锁对象的写法, 🧠 为什么推荐使用一个专用的对象来加锁？, ❗ 不建议这样写：, ✅ 推荐做法：, 📌 实际应用场景举例, 场景1：保护共享变量, 场景2：多资源同步控制, 场景3：防止类级别的同步污染, 🔍 总结：锁对象的使用是否常见？, 对象头, 对象头结构, Mark Word 的作用, Monitor 锁, 锁升级机制, 锁升级过程, 1. 偏向锁（Biased Locking）, 目标, 工作原理, 特点, 2. 轻量级锁（Lightweight Locking）, 目标, 工作原理, 特点, 3. 重量级锁（Heavyweight Locking）, 目标, 工作原理, 特点, 锁升级流程图解, 1. 什么是 Lock Record？, 2. Lock Record 的结构, 3. Lock Record 在锁升级过程中的作用, 场景：线程 T1 尝试获取轻量级锁, 场景：线程 T1 释放轻量级锁, 4. Lock Record 与偏向锁的关系, 5. 为什么 Lock Record 放在栈上？, 6. 总结, 核心答案：, 详细解析：锁的演变过程与 Mark Word 的变化, 阶段 1 无锁 (Normal), 阶段 2 偏向锁 (Biased Locking), 阶段 3 轻量级锁 (Lightweight Locking), 阶段 4 重量级锁 (Heavyweight Locking x2F Inflation), 回答你的具体问题, 类比理解, 总结, 总结, 什么是锁重入？, 示例代码：, 锁计数器, 锁重入的应用场景, 总结, 自旋优化, 自旋锁的基本概念, 自旋优化的工作原理, 关键点：, 在Java中的应用, 注意事项, 为什么调用 hashCode 会导致偏向锁被禁用？, 总结, 🧠 为什么需要批量重偏向？, 🔍 批量重偏向的核心思想, 📈 批量重偏向的触发条件, 示例流程如下：, 🧩 关键概念总结, ⚙️ 如何观察和控制批量重偏向？, 1. 查看当前是否启用偏向锁（Java 8+ 默认开启）：, 2. 控制偏向锁延迟启动时间（默认是 4 秒）：, 3. 查看偏向锁相关的统计信息（需要启用诊断选项）：, ✅ 总结一句话：, 🔍 问题核心：, ✅ 简短回答：, 🧠 偏向锁撤销 ≠ 锁升级, 🧪 示例场景回顾, 🔁 偏向锁是可以重新获得的！, 📌 举个例子说明更清楚：, 🧩 什么时候才会真正升级为轻量级锁？, ✅ 总结一句话：, ✅ 简短回答：, 🧠 为什么不能立刻偏向 T2？, 1. 避免频繁撤销和重偏向带来的开销, 2. 防止误判：可能是偶发性竞争而非真正的多线程交替使用, 3. 批量处理更高效：减少 Safepoint 次数, 📈 批量重偏向的工作流程（详细）, 🧩 补充：如果撤销特别频繁怎么办？, 🔥 批量撤销（Bulk Revocation）, ⚙️ 如何查看x2F调整这些参数？, ✅ 总结一句话：, 🧠 什么是偏向锁撤销？, 📌 关键点：, 🔁 偏向锁撤销的典型触发场景, 🧪 场景模拟：, 🚀 偏向锁撤销流程详解（从 T2 的角度）, ✅ 第一步：检查对象头 Mark Word, ✅ 第二步：判断是否可以撤销, ✅ 第三步：进入 Safepoint（全局停顿）, ✅ 第四步：撤销偏向锁, ✅ 第五步：恢复线程执行并尝试获取锁, ⚙️ 撤销后的状态变化（以 64 位 JVM 为例）, 📈 批量撤销 vs 单个撤销, 🎯 为什么偏向锁撤销代价高？, ✅ 总结：偏向锁撤销的关键流程, 💡 补充建议, 撤销了t1t2获得了锁如果还没升级轻量级锁 那是什么锁, 撤销后的锁状态, 🧪 场景回顾, 撤销过程简述：, 🔍 撤销后的锁状态分析, 1. 直接进入轻量级锁, 2. 保持中立状态（Neutral Bias State）并重新偏向, 3. CAS 竞争失败后升级为轻量级锁, 4. 批量重偏向, ✅ 总结：T2 获得锁的具体情况, 关键点：, ✅ 你的问题本质：, 🧠 答案一句话总结：, 🔍 具体分析, 📌 1. 偏向锁撤销 ≠ 锁升级为轻量级锁, 📌 2. 单个对象是否可以重新偏向？, ✅ 条件一：没有其他线程竞争, ✅ 条件二：该类尚未触发批量重偏向或批量撤销, 📌 3. 什么时候才能批量重偏向？, 🧪 示例说明, 📌 总结一下关键区别：, ✅ 最后总结一句话：, 如果如果t2 撤销了t1的偏向然后会进行一个单对象偏向 并计数如果后面这个对象又被t1 请求了t1会撤销t2的偏向单对象偏向到t1. 并计数。这个理解对吧, ✅ 你的理解总结如下：, ✅ 答案一句话总结：, 🧠 更详细解释, 📌 1. 偏向锁是线程 + epoch绑定的, 📌 2. 单个对象可以反复偏向不同线程, 示例流程：, 📌 3. 类撤销计数器的作用, 📈 撤销计数器与偏向锁状态变化的关系, ⚙️ 补充说明：为什么允许单对象重偏向？, ✅ 总结一下你的理解是否正确：, 💡 推荐实践建议, 1. 偏向锁的基本假设, 2. 线程B如何检测线程A是否释放锁？, 步骤1：检查Mark Word的线程ID, 步骤2：触发偏向锁撤销（Revoke）, 3. 关键问题：如何知道线程A是否退出同步块？, 为什么需要暂停线程A（STW）？, 4. 流程图, 5. 性能优化：批量重偏向与撤销, 6. 总结, 关键结论, 详细流程分析, 1. 偏向锁场景下 Lock Record 的作用, 2. 线程B如何检测锁是否释放？, 3. 轻量级锁场景下的 Lock Record, 为什么偏向锁不立即清除 Mark Word 的线程ID？, 示例代码与内存变化, 总结, 1. 轻量级锁的基本原理, 2. 轻量级锁的撤销（升级为重量级锁）, 2.1 触发条件, 2.2 撤销流程, 3. 轻量级锁 vs 重量级锁, 4. 示例代码分析, 5. 关键点总结, 精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析：, 关键结论, 完整流程分析, 1. 初始状态（线程A持有轻量级锁）, 2. 线程B尝试获取锁（触发锁膨胀）, 3. 锁膨胀（升级为重量级锁）, 4. 关键点澄清, 流程图解, 为什么需要重量级锁？, 总结, 锁消除, 🧠 锁消除的本质, 🔍 锁消除的前提：逃逸分析（Escape Analysis）, 逃逸分析的三种状态：, 🧪 示例说明, 示例 1：锁可以被消除的情况, 示例 2：锁不能被消除的情况, ⚙️ 如何开启锁消除？, 📈 性能影响与适用场景, ✅ 总结一句话：, 基本概念, 使用场景, 示例代码, 注意事项, 模式描述, 实现方式, 关键点, Park 和 Unpark 的基本概念, LockSupport 提供的方法, 示例代码, 特点, 1. 死锁（Deadlock）, 2. 活锁（Livelock）, 3. 饥饿（Starvation）, 一、基础架构, 1. 核心接口：Lock, 2. 锁的实现类, 二、具体设计, 1. ReentrantLock 设计细节, 2. ReentrantReadWriteLock 设计细节, 3. StampedLock 设计细节, 三、场景应用, 1. 使用 ReentrantLock 替代 synchronized, 2. 使用 ReadWriteLock 在读多写少的情况下提高性能, 3. 使用 StampedLock 在读多写少且适合乐观锁的场景, ReentrantLock原理。, 🧠 背景知识：AQS 是什么？, 🔍 方法签名解析, 📦 方法作用总结, 🔁 主要流程详解（逐行分析）, 变量定义, 🔁 循环体说明：, 1. 获取当前节点的前驱节点 p, 2. 尝试获取锁（只有头节点的下一个节点才有资格抢锁）, 3. 获取失败后的处理, a. shouldParkAfterFailedAcquire(p node), b. parkAndCheckInterrupt(), 🛑 finally 块中的异常处理, 📐 CLH 队列结构简述, ✅ 总结一句话：, 🚀 扩展建议, 🧠 作用：判断当前线程是否应该被阻塞挂起, 🔁 参数说明, 📌 返回值含义, ✅ 逐段解析代码, 第一步：检查前驱节点的状态（waitStatus）, 第二步：处理前驱节点被取消的情况（waitStatus gt 0）, 第三步：设置前驱节点为 SIGNAL, 📐 Node.waitStatus 的几个关键值, 🔄 流程图示意, 🎯 举个例子（ReentrantLock 非公平锁）, 🧩 总结一句话：, 主要特点, 常用方法, 使用示例, 适用场景是编程语言中的一个关键字用于实现线程同步以确保多个线程在并发访问共享资源时的正确性和可见性它是提供的一种内置锁机制也被称为监视器锁或对象锁一作用的主要作用是保证原子性确保某段代码在同一时刻只能被一个线程执行保证可见性当一个线程修改了共享变量的值其他线程可以立即看到这个修改保证有序性防止指令重排序带来的问题二使用方式同步方法对于实例方法锁是当前对象对于静态方法锁是当前类的对象即同步代码块更灵活地指定锁对象避免对整个方法加锁提高性能推荐做法优先使用同步代码块而不是同步整个方法静态方法同步只能有一个线程执行该方法锁的是而非某个对象实例三锁的特性可重入的是可重入锁也就是说同一个线程可以多次进入已经被自己持有的同步块允许再次获取锁不可中断如果一个线程因为等待获取锁而阻塞它不能通过调用来中断非公平锁是非公平锁即不保证等待时间最长的线程最先获得锁四底层原理简述每个对象都有一个与之关联的监视器由维护当线程进入块或方法时它会尝试获取对象的监视器锁如果锁未被占用则线程获得锁并继续执行如果锁已被其他线程持有则当前线程进入阻塞状态直到锁被释放五优缺点对比特点优点缺点使用简单语法简洁易于理解粒度大容易影响性能可重入支持同一线程多次进入自动释放锁进入和退出自动管理无法尝试锁不能尝试获取锁而不阻塞无法超时不支持超时机制无法中断获取锁过程中不能被中断六替代方案从开始包提供了更强大的锁机制如这些锁提供了更多功能比如尝试锁超时可中断等适用于更复杂的并发场景七总结是中最基础的线程同步机制适合简单的并发控制场景但在高并发或需要高级功能如尝试锁超时读写分离时推荐使用或其他并发工具类使用锁同步块锁对象理论上可以是任意的唯一对象是可重入不公平的重量级锁原则上锁对象建议使用共享资源在实例方法中使用作为锁对象锁住的正好是共享资源在静态方法中使用类名字节码作为锁对象因为静态成员属于类被所有实例对象共享所以需要锁住类同步代码块格式锁对象访问共享资源的核心代码实例修饰则元素是属于类本身的不属于对象与类一起加载一次只有一个同步方法把出现线程安全问题的核心方法锁起来每次只能一个线程进入访问修饰的方法的不具备继承性所以子类是线程不安全的如果子类的方法也被修饰两个锁对象其实是一把锁而且是子类对象作为锁用法直接给方法加上一个修饰符同步方法修饰符返回值类型方法名方法参数方法体同步静态方法修饰符返回值类型方法名方法参数方法体同步方法底层也是有锁对象的如果方法是实例方法同步方法默认用作为的锁对象等价于如果方法是静态方法同步方法默认用类名作为的锁对象等价于锁对象的写法同步代码块只有持有对象的线程可以执行这段代码这里我们创建了一个私有的的对象专门用于加锁使用这种方式的好处是不干扰其他无关同步操作并且可以精确地控制锁的粒度为什么推荐使用一个专用的对象来加锁不建议这样写同步代码块虽然语法上没问题但存在潜在问题如果这个类被其他模块继承或扩展外部可能也在用加锁造成锁冲突容易引起锁竞争降低并发性能粒度过大影响程序效率推荐做法同步代码块更安全不会与其他同步代码块产生冲突更灵活可以为不同的资源定义不同的锁对象更高效减小锁的粒度提升并发性能实际应用场景举例场景保护共享变量目的确保多个线程对的访问是同步的场景多资源同步控制使用资源使用资源目的不同资源使用不同的锁互不影响场景防止类级别的同步污染如果你有一个工具类里面有些方法需要同步但你不想影响整个类或对象实例只同步关键部分总结锁对象的使用是否常见项目是否推荐原因锁住不推荐容易引发锁冲突和不必要的锁竞争锁住专用对象如非常推荐控制粒度精细安全性高灵活性强锁住类的对象如视情况而定多用于静态方法同步所以结论是使用锁一个专门的对象是非常常见且推荐的做法尤其在需要更细粒度控制并发行为时对象头在中每个对象都有一个与之关联的对象头这是为了实现某些特性如锁机制垃圾回收等而添加的一些元数据对于同步机制来说尤其是关键字所依赖的监视器锁对象头中的信息尤为重要对象头结构对象头主要包括两部分和此外在某些情况下还可能包括数组长度等额外信息这是对象头中最重要的部分用于存储对象的运行时数据如哈希码分代年龄锁状态标志线程持有的锁偏向线程偏向时间戳等它的大小因实现和平台的不同而异通常为位或位指向该对象对应的类在方法区中的地址通过这个指针可以访问到对象的类型信息以及方法表等重要数据的作用是一个非常重要的概念它根据对象的状态复用不同的字段来节省空间在支持偏向锁轻量级锁重量级锁的中可能会包含以下几种信息无锁状态存储对象的哈希值年龄等偏向锁状态存储偏向线程偏向时间戳等信息轻量级锁状态指向栈中锁记录的指针重量级锁状态指向对象的指针锁是一种同步机制它提供了比简单锁定更复杂的语义每个对象都可以作为一个来使用这也是为什么我们说使用的是对象级别的锁主要由以下几个部分组成等待获取锁的所有线程队列调用了方法后进入等待状态的线程集合当前持有锁的线程当一个线程尝试进入方法或代码块时如果此时没有其他线程占有该锁则该线程可以获得锁并继续执行否则该线程将被放入等待锁释放类似地当调用方法时线程会被移动到直到另一个线程调用或方法唤醒它锁升级机制为了提高性能现代提供了从偏向锁到轻量级锁再到重量级锁的锁升级机制偏向锁假设基本上不存在竞争因此只需要简单的检查是否有别的线程尝试获取过这个锁即可轻量级锁当有轻微的竞争出现时采用操作尝试获取锁重量级锁当竞争加剧时升级为真正的操作系统层面的互斥锁涉及到上下文切换等开销较大的操作这种逐步升级的设计旨在优化多线程环境下的性能表现使得大多数情况下无需付出高昂的代价就能完成同步操作每个对象都可以关联一个对象也是其实例存储在堆中如果使用给对象上锁重量级之后该对象头的中就被设置指向对象的指针这就是重量级锁结构最后两位是锁标志位位虚拟机工作流程开始时中为当执行就会将的所有者置为中只能有一个对象的指向把对象原有的存入线程栈中的锁记录中轻量级锁部分详解在上锁的过程也执行就会进入双向链表执行完同步代码块的内容根据对象头中地址寻找设置为空把线程栈的锁记录中的对象头的值设置回唤醒中等待的线程来竞争锁竞争是非公平的如果这时有新的线程想要获取锁可能直接就抢占到了阻塞队列的线程就会继续阻塞中的是以前获得过锁但条件不满足进入状态的线程机制注意必须是进入同一个对象的才有上述的效果不加的对象不会关联监视器不遵从以上规则在中为了优化同步机制的性能实现了锁升级的概念锁升级是从偏向锁到轻量级锁再到重量级锁的过程这个过程旨在减少线程间的竞争和上下文切换从而提高程序的整体性能以下是锁升级的具体过程及其解释锁升级过程偏向锁目标减少无竞争情况下的同步开销如果一个线程获得了锁并且之后没有其他线程尝试获取该锁则该锁会保持偏向状态工作原理当一个线程第一次访问同步代码块或方法时会在对象头的中记录该线程的和偏向时间戳如果后续该线程再次请求同一个锁只需检查对象头中的线程是否与当前线程匹配而无需执行任何操作或其他复杂的同步操作如果另一个线程尝试获取偏向锁那么会撤销偏向锁并将锁升级为轻量级锁特点高效对于只有一个线程访问共享资源的情况非常高效低开销几乎不产生额外的开销因为不需要原子操作来保证同步轻量级锁目标在有少量线程竞争的情况下提供一种比重量级锁更高效的同步方式避免使用操作系统级别的互斥量减少线程阻塞和唤醒带来的开销工作原理当一个线程尝试获取一个已经被其他线程持有的偏向锁时会撤销偏向锁并将锁升级为轻量级锁轻量级锁通过比较并交换操作来尝试获得锁如果成功则直接进入临界区如果失败则表示存在竞争需要继续尝试或者等待每个持有轻量级锁的线程都会在其栈帧中创建一个锁记录并将对象头的复制到这个锁记录中如果锁竞争加剧即多个线程频繁地争夺同一个锁会将锁升级为重量级锁特点适用于低到中等程度的竞争当只有少数几个线程试图同时访问同一资源时轻量级锁表现良好较低的上下文切换开销相比重量级锁减少了线程阻塞和唤醒的次数重量级锁目标处理高竞争场景确保只有一个线程能够访问共享资源其他线程必须等待直到锁被释放使用操作系统的互斥量实现允许线程进入等待状态以节省资源工作原理当轻量级锁无法满足需求即多个线程频繁争用同一个锁时会将锁升级为重量级锁在重量级锁状态下所有未获得锁的线程都将被放入等待队列中直到当前持有锁的线程释放锁为止重量级锁涉及到操作系统层面的调度可能会导致线程的挂起和恢复这会导致较高的上下文切换开销特点适用于高竞争场景当多个线程频繁争夺同一个锁时重量级锁可以保证数据的一致性和完整性较高的开销由于涉及到操作系统级别的互斥量因此会有较大的开销锁升级流程图解偏向锁单线程访问遇到竞争轻量级锁少量线程竞争竞争加剧重量级锁多线程竞争好的我们来深入讲解一下与对象关联的锁记录这是理解轻量级锁和偏向锁升级机制的核心概念之一什么是定义有时也称为或中的帧是在线程的调用栈上分配的一小块内存区域目的它是实现轻量级锁和偏向锁撤销后升级的关键数据结构它主要用于在对象头被修改时保存对象头的原始状态即的副本位置它位于获取锁的线程的栈帧中是线程私有的这意味着每个尝试获取锁的线程如果成功进入轻量级锁或以上状态都会在自己的栈上拥有一个或多个的结构一个典型的主要包含两个部分被置换的这是中最重要的部分它存储了在加锁操作之前对象头中的完整内容例如如果对象之前处于无锁状态就保存了包含哈希码分代年龄无锁标志等信息的完整如果对象之前是偏向锁状态会保存偏向锁模式下的包含偏向线程时间戳等所有者指针可选实现相关在某些实现或调试信息中可能还会包含一个指向其所关联对象的指针但这并非所有实现都显式包含因为关联关系通常通过其他方式维护在锁升级过程中的作用主要在轻量级锁的获取和释放过程中扮演核心角色场景线程尝试获取轻量级锁前提对象当前处于无锁状态或偏向锁已被撤销创建在自己的栈帧中分配一个复制将对象当前的复制到这个新创建的的字段中替换使用操作试图将对象头的替换为一个指向自己栈中这个的指针成功说明没有竞争获得了轻量级锁此时对象头的指向了栈中的进入临界区失败说明有竞争另一个线程也在尝试获取会进行自旋等待或升级为重量级锁场景线程释放轻量级锁准备退出同步块准备释放锁恢复使用操作试图将中的交换回对象头的中成功说明在此期间没有其他线程成功修改过对象头即没有发生竞争解锁成功对象恢复到无锁状态失败说明有其他线程可能已经将锁升级为重量级锁此时对象头的可能已经指向一个对象不能简单地恢复需要通过更复杂的重量级锁释放流程来处理与偏向锁的关系偏向锁本身不直接使用在偏向锁状态下线程通过检查对象头的中的线程来判断是否可以无开销地进入临界区不需要在栈上创建但偏向锁撤销后会用到当发生竞争需要撤销偏向锁并升级时会在安全点检查持有偏向锁的线程的栈如果发现仍然持有这个锁即的栈中有一个其指向了该对象这说明还没有释放锁此时会强制将其持有的偏向锁转换为轻量级锁这个转换过程就涉及到创建或利用已有的并将对象头的从偏向模式修改为指向这个的指针简单说是偏向锁升级为轻量级锁过程中的桥梁和容器为什么放在栈上线程私有栈是线程私有的因此天然是线程私有的避免了多线程访问本身的同步开销生命周期匹配的生命周期通常与获取锁的代码块方法调用的栈帧生命周期一致当方法执行完毕栈帧被弹出也随之自动销毁无需额外的内存管理快速访问访问线程栈上的数据非常快这有助于减少轻量级锁的开销总结是在线程栈上分配的一块内存它的核心作用是保存对象头的副本它是实现轻量级锁的基础通过操作将对象头的替换为指向的指针来标记锁的持有者并在解锁时尝试将恢复回去它在偏向锁升级过程中扮演关键角色是将偏向锁状态转换为轻量级锁状态的容器它的存在使得轻量级锁可以在不涉及操作系统互斥量的情况下通过和自旋来高效地处理短暂的线程竞争理解是理解对象头以及锁升级无锁偏向锁轻量级锁重量级锁完整链条的关键一环核心答案轻量级锁的信息是存储在锁记录中而不是存储在里面应该是的笔误让我们详细梳理一下轻量级锁的机制和的作用是什么是对象头的一部分它是一个存储对象运行时元数据的内存区域这些元数据包括哈希码对象的分代年龄锁状态标志锁的类型无锁偏向锁轻量级锁重量级锁偏向线程指向锁记录或互斥量的指针等的内容会根据对象的锁状态和的运行状态动态变化轻量级锁的加锁过程与的关系当一个线程尝试获取一个处于无锁或偏向锁但能成功撤销状态的对象锁时会尝试将其升级为轻量级锁关键步骤创建锁记录该线程会在自己的栈帧中分配一块空间称为锁记录复制线程将对象当前的复制到这个锁记录中这个被复制的被称为被置换的替换线程使用操作试图将对象头中的替换为一个指向自己栈帧中这个锁记录的指针成功与失败成功如果成功说明没有其他线程竞争这个锁该线程获得了轻量级锁可以进入临界区执行此时对象头的指向了线程栈中的锁记录失败如果失败说明有其他线程也在尝试获取锁竞争发生当前线程会进行自旋尝试再次或者在自旋一定次数后将锁膨胀为重量级锁为什么说轻量级锁不会存储在里面是误解这个说法本身是不准确的更准确的说法是轻量级锁的状态信息是通过来体现和管理的在轻量级锁状态下的内容发生了改变它不再直接包含哈希码年龄等信息而是存储了一个指向栈中锁记录的指针同时锁记录中保存了原始的所以是轻量级锁机制中核心的动态变化的部分它指向了锁的持有者线程栈中的锁记录而不是不存储轻量级锁轻量级锁的解锁过程当线程退出同步块时需要释放轻量级锁它会使用操作试图将锁记录中的交换回对象头的中如果成功说明在此期间没有其他线程尝试获取过这个锁没有竞争解锁完成对象恢复到无锁状态如果失败说明在持有锁期间已经有其他线程尝试过获取锁可能已经膨胀为重量级锁此时需要在释放锁后由进行后续的重量级锁释放操作总结轻量级锁的信息是存储在和共同构成的结构中的在轻量级锁状态下其值是一个指向栈中锁记录的指针中存储了原始的因此是轻量级锁机制中不可或缺的一部分它用于标识锁的状态和指向锁记录而不是不存储轻量级锁所以正确的理解是轻量级锁利用的指针指向线程栈中的而保存了原始的内容你提出了一个非常精准且关键的问题这涉及到对底层实现中到底是什么以及对象头如何演变的深刻理解你的直觉是对的但需要澄清一个常见的误解让我们一步步拆解核心答案对象中的对象本身不是对象对象是被同步的对象它的对象头被用来存储锁状态信息是一个独立的由管理的对象它通常不位于堆上或位于一个特殊的区域是重量级锁的执行引擎在轻量级锁阶段操作的是对象的没有额外的对象被创建只有当锁升级为重量级锁时才会分配一个独立的对象并将对象的指向这个详细解析锁的演变过程与的变化假设我们有一个对象并执行阶段无锁状态对象尚未被任何线程同步内容存储对象的哈希码分代年龄信息等锁状态标志为无锁不存在对象和任何都没有关联阶段偏向锁触发线程第一次进入操作修改对象的内容被设置为偏向模式并记录下的线程和一个时间戳仍然没有创建原理再次进入时只需检查的线程是否是自己无需任何同步操作不存在阶段轻量级锁触发线程尝试进入但发现对象已被偏向操作撤销偏向在安全点撤销的偏向锁将对象的恢复到可偏向但未偏向的状态获取轻量级锁或在撤销后重新竞争在自己的栈帧中创建一个复制将对象当前的撤销后的值复制到自己的的字段中替换使用操作将对象的替换为指向自己栈中的指针内容现在对象的存储的是一个指向栈中的指针锁状态标志为轻量级锁仍然不存在这是关键点轻量级锁完全依赖对象自身的和线程栈上的来实现没有引入额外的对象阶段重量级锁触发发现自旋次数过多决定将锁升级操作分配从缓存池或堆外内存中分配一个全新的对象我们称之为修改对象的使用操作将对象的从指向的替换为指向的指针锁状态标志变为重量级锁初始化设置因为才是当前持有者进入阻塞将自己放入并调用操作系统原语将自己阻塞内容对象的现在存储的是一个指向独立对象的指针现在才创建是一个独立的重量级的同步控制器回答你的具体问题比如我直接执行对象不是直接把对象作为对象吗不完全是对象是被同步的实体它的对象头特别是是锁状态的门面和指针在偏向锁和轻量级锁阶段对象通过其直接管理锁状态存储线程或指向在重量级锁阶段对象的不再直接管理锁而是变成了一个指向真正锁管理者的指针对象就像一个门牌号告诉你真正的锁办公室在哪里在轻量级锁中用的是哪个对象的是这个对象吗是的在轻量级锁阶段操作的就是对象自身的具体来说就是将对象的从存储哈希码等信息改为存储一个指向获取锁的线程的栈帧中的指针这个里保存了对象的快照类比理解想象对象是一栋房子无锁房子没人管门上贴着房子的编号和基本信息的初始内容偏向锁房子给了张三一把专属钥匙门上写着此房偏向张三记录轻量级锁李四也想进张三把门锁了把钥匙房子的快照信息放进自己口袋门上贴了张纸条钥匙在张三口袋里指向李四在门外轻轻敲门自旋等张三出来重量级锁李四等烦了叫来了物业物业在小区门口建了一个独立的门卫室把房子的正式钥匙挂在门卫室墙上门卫室墙上写着此房钥匙在此持有者张三房子原来的门上贴了新的纸条此房的门卫室在栋号对象的指向李四去门卫室登记坐在椅子上等着阻塞在不再敲门总结对象的是锁状态的指示器在偏向锁和轻量级锁阶段直接存储锁信息线程或指向栈上的指针在重量级锁阶段存储一个指向独立对象的指针是一个独立于对象的由管理的对象是重量级锁的大脑和队列管理者因此对象并不是直接用对象当作而是利用对象的作为跳板或指针在需要时链接到真正的重量级锁控制器总结偏向锁适用于几乎没有竞争的场景旨在消除同步原语的开销轻量级锁适用于有一定竞争但不是非常激烈的场景利用操作来避免昂贵的操作系统互斥量重量级锁适用于高度竞争的场景尽管开销较大但能有效管理多个线程对同一资源的访问需要注意的是锁可以从偏向锁升级为轻量级锁再升级为重量级锁但是不能降级一旦锁升级为重量级锁它将一直保持这种状态直到重启或类加载器卸载相关类此外从开始默认情况下启用了偏向锁但在某些特定环境下如频繁的锁撤销可能需要禁用偏向锁以获得更好的性能可以通过参数来关闭偏向锁在中是一种内置锁机制用于确保多个线程在访问共享资源时的同步性一个重要的特性是可重入性这意味着同一个线程可以多次获取同一个锁而不会发生死锁什么是锁重入锁重入是指当一个线程已经持有了某个对象的锁并试图再次获取该对象的锁时允许这个操作成功完成而不是阻塞或抛出异常这种机制保证了即使在一个方法调用另一个也需要相同锁的方法时也不会导致死锁示例代码在这个例子中如果一个线程调用了它会获得当前对象的锁并执行其中的代码当内部调用时由于也是同步方法需要获取同样的锁但是因为支持重入所以这个线程可以再次获取相同的锁而不会被阻塞锁计数器为了实现重入维护了一个与锁关联的计数器每当一个线程获取到锁时计数器加一每当线程释放锁时计数器减一只有当计数器归零时表示锁完全释放其他等待该锁的线程才能获取到锁例如线程首次获取锁计数器从变为再次获取同一锁计数器从变为当完成同步代码块或方法第一次释放锁计数器从变为最后一次释放锁计数器从变为锁完全释放锁重入的应用场景锁重入主要应用于以下几种情况递归调用同步方法或代码块如上面的例子所示一个方法内部调用另一个需要相同锁的方法嵌套同步块在一个同步方法或代码块内使用另一个需要相同锁的同步块同步逻辑继承层次中的同步方法子类覆盖父类的方法时如果两个方法都需要同步则可能涉及到锁重入的情况同步逻辑调用父类的同步方法子类额外的同步逻辑总结锁重入是的一个重要特性允许同一个线程多次获取同一个锁而不导致死锁通过维护一个计数器来跟踪锁的获取次数确保每次获取都有相应的释放操作最终使得锁能够正确地被释放这种机制使得开发人员可以在编写多线程程序时更加灵活地使用同步方法和代码块特别是在递归调用嵌套同步块以及继承层次结构中同步方法的情况下自旋优化自旋优化是一种针对多线程同步机制的优化策略主要用于减少线程在等待获取锁时进入阻塞状态所带来的开销传统上当一个线程尝试获取已经被其他线程持有的锁时它会被挂起并放入等待队列中直到锁被释放这一过程涉及到上下文切换即操作系统需要保存当前线程的状态并将资源分配给另一个线程这会带来一定的性能开销自旋锁的基本概念自旋锁是指当一个线程尝试获取锁但未能成功时不会立即进入阻塞状态而是通过循环的方式忙等持续检查锁是否可用一旦锁变为可用状态该线程就可以立即获得锁并继续执行这种方法可以避免昂贵的上下文切换适用于锁被占用时间非常短的场景自旋优化的工作原理自旋优化通常与轻量级锁结合使用在某些情况下会在尝试获取轻量级锁时先进行短暂的自旋操作而不是直接进入阻塞状态如果在这段时间内锁变为可用则线程可以直接获取锁而无需经历阻塞和唤醒的过程如果自旋一定次数后仍未获取到锁则线程最终会被挂起关键点减少上下文切换自旋期间线程保持活跃减少了从运行态到等待态再回到运行态的转换适合短时间等待对于那些预计锁很快就会被释放的情况特别有效资源消耗由于自旋是主动的轮询检查因此可能会浪费周期尤其是在长时间等待的情况下在中的应用在中自旋优化并不是直接暴露给开发者的功能而是内部的一种优化策略具体来说可能会在以下几种情况下采用自旋优化轻量级锁在尝试获取轻量级锁失败时可能会让线程先自旋一段时间希望持有锁的线程能够尽快释放锁偏向锁撤销当偏向锁需要撤销时可能会允许其他竞争线程先自旋而不是立即升级为重量级锁值得注意的是从开始默认情况下不再启用偏向锁并且可以通过参数调整相关行为例如来控制偏向锁的使用或来设置偏向锁启动延迟注意事项尽管自旋优化可以在某些特定场景下提高性能但它并不总是最佳选择特别是对于锁被长时间占用的情况自旋会导致不必要的资源浪费因此现代实现了更复杂的锁机制如适应性自旋根据历史统计信息动态决定是否应该让线程自旋以及自旋多久在中偏向锁是一种优化技术旨在减少无竞争同步的开销当一个线程第一次访问同步代码块或方法时会尝试使用偏向锁来标记这个对象是被该线程所偏好的从而避免后续对该锁的竞争检查然而在某些情况下偏向锁会被撤销其中一个常见的场景就是调用了对象的方法为什么调用会导致偏向锁被禁用偏向锁的工作原理偏向锁通过在对象头的中记录持有锁的线程来实现这意味着在偏向锁状态下需要存储线程和偏向时间戳等信息的需求当你调用一个对象的方法时需要返回一个整数值该值通常基于对象的身份哈希码即对象在内存中的地址对于普通对象这个哈希码是由自动生成并缓存的如果对象处于偏向锁状态它的已经被用于存储偏向锁的信息如线程此时没有足够的空间同时存储哈希码和偏向锁信息偏向锁与的冲突因为偏向锁需要占用中原本可能用来存储哈希码的空间所以在调用方法时必须撤销偏向锁以便腾出空间来计算和存储哈希码撤销偏向锁意味着将对象的状态从偏向锁转换为轻量级锁或重量级锁具体取决于当前是否有其他线程在等待获取该锁性能考虑调用导致偏向锁被撤销虽然可能会引入一些额外的开销但这通常是必要的因为保证了哈希码的正确性和一致性比保持偏向锁更重要此外这种情况相对较少发生大多数对象在其生命周期中不会调用方法总结偏向锁利用对象头的来存储偏向信息如线程以减少同步操作的开销调用方法需要使用对象头中的部分空间来存储哈希码这就与偏向锁所需的存储空间产生了冲突为了确保哈希码能够正确地生成和存储在检测到方法被调用时会撤销偏向锁将对象的锁定状态升级为轻量级锁或者重量级锁因此当你知道某个对象将会频繁地调用方法时应该意识到这可能会导致偏向锁被撤销进而影响性能优化的效果不过在实际应用中这种影响通常是可接受的因为偏向锁主要是针对几乎没有锁竞争的情况设计的而这些情况下的调用频率一般较低非常好的问题批量重偏向是对偏向锁优化机制的一种高级改进目的是在某些特定场景下避免频繁撤销偏向锁带来的性能损耗它主要出现在多个对象被偏向同一个线程后又陆续被其他线程访问的情况下为什么需要批量重偏向我们先回顾一下偏向锁的两个关键点偏向锁一旦被另一个线程访问就会被撤销并升级为轻量级锁撤销操作是有成本的需要停止所有线程进行偏向锁撤销影响性能但如果多个对象都被偏向线程然后这些对象又被线程访问那么每次都要撤销一次偏向锁这会导致大量重复的撤销操作这时候就引入了批量重偏向来解决这个问题批量重偏向的核心思想当检测到某类对象比如的实例正在被某个线程偏向并且有另一个线程正在尝试获取这些对象的锁时可以将这一批对象统一重新偏向到新线程而不是一个个地撤销偏向锁并升级为轻量级锁这样做的好处是减少撤销次数避免锁升级继续保持偏向锁状态提高并发性能批量重偏向的触发条件内部有一个计数器来统计某个类的对象发生偏向锁撤销的次数当达到一定阈值默认是次时就会触发批量重偏向示例流程如下线程获取多个实例的偏向锁线程开始访问这些对象第次访问时触发偏向锁撤销到第次撤销时发现这个类的对象频繁发生偏向锁撤销决定对这个类的所有未使用的实例进行批量重偏向把它们的偏向锁目标改为后续访问这些对象时不再需要撤销偏向锁而是直接获得偏向锁关键概念总结名称含义偏向锁撤销当另一个线程尝试获取已被偏向的锁时会撤销偏向锁批量重偏向检测到某一类对象频繁被撤销偏向锁后统一将这些对象的偏向锁重新指向新的线程批量撤销如果竞争太激烈直接对该类的所有对象撤销偏向锁不再使用偏向锁机制如何观察和控制批量重偏向你可以通过以下方式查看或调整相关参数查看当前是否启用偏向锁默认开启输出类似控制偏向锁延迟启动时间默认是秒查看偏向锁相关的统计信息需要启用诊断选项总结一句话批量重偏向是在检测到某一类对象频繁发生偏向锁撤销时主动将这批对象的偏向锁目标更换为当前请求的新线程从而减少后续的撤销次数提升性能的一种优化策略它是偏向锁机制的一个重要补充在多线程交替访问共享资源但竞争不激烈的场景中特别有效这个问题非常关键也非常深入你问的是偏向锁撤销了之后不是就升级为轻量级锁了吗为什么还能回退到偏向锁我们来详细分析一下这个过程问题核心偏向锁被撤销后是否可以重新变为偏向锁简短回答是的偏向锁被撤销后并不会立即变成轻量级锁会根据实际情况决定是否恢复偏向锁比如批量重偏向或者直接升级为轻量级重量级锁偏向锁撤销锁升级很多人误以为只要偏向锁被撤销就会自动升级为轻量级锁其实这是不对的让我们澄清几个关键概念操作含义偏向锁撤销表示某个线程尝试获取一个已经被偏向其他线程的对象锁此时会清除偏向信息如线程这一步只是清理偏向状态并不等于锁升级锁升级升级为轻量级或重量级锁是另一个独立的过程只有在多个线程竞争同一个锁时才会发生示例场景回顾我们来看一个典型的流程获取对象锁对象进入偏向锁状态偏向尝试获取锁发现偏向触发偏向锁撤销此时对象头被清空或标记为不可偏向如果这是第次撤销某个类的对象偏向锁记录撤销次数不立即升级为轻量级锁对象处于可偏向但未偏向的中间状态如果后续有新的线程请求锁且满足条件可能再次偏向该线程即重新启用偏向锁当撤销次数达到阈值默认次触发批量重偏向把这一类对象统一重新偏向当前线程或者触发批量撤销直接禁用这类对象的偏向锁机制偏向锁是可以重新获得的也就是说偏向锁撤销升级为轻量级锁在撤销后如果对象没有被升级为轻量级锁它仍然可以被其他线程重新偏向这就是的一种优化策略延迟锁升级避免不必要的开销举个例子说明更清楚先偏向这些对象开始访问这些对象前次触发撤销第次触发批量重偏向在这个例子中第次访问偏向的对象触发偏向锁撤销第次发现撤销次数达到阈值于是对所属类的所有对象执行批量重偏向将它们偏向后续访问再次访问这些对象时又能以偏向锁方式获取锁不再需要撤销什么时候才会真正升级为轻量级锁只有在以下情况下才会真正将锁从偏向锁升级为轻量级锁多个线程同时竞争同一个对象的锁比如两个线程几乎同时尝试获取锁操作失败多次表示并发竞争激烈批量重偏向失败或被跳过这时候才会放弃使用偏向锁机制升级为轻量级锁通过实现或最终升级为重量级锁操作系统互斥量总结一句话偏向锁撤销锁升级它只是取消偏向并不意味着锁立刻变成轻量级锁会在撤销后观察是否有新的线程频繁访问这些对象如果有还会进行批量重偏向让这些对象重新支持偏向锁机制这样做的目的是避免频繁的偏向锁撤销减少上下文切换和操作提高多线程交替访问下的性能表现这是一个非常深入非常好的问题你问在偏向锁机制中访问偏向的对象时触发了偏向锁撤销那为什么不直接让这个对象偏向而是要等到第次才批量重偏向呢简短回答不会立即把对象从偏向改为偏向是为了防止频繁切换偏向线程带来的性能开销和误判只有当发现某个类的对象被多个线程交替访问的频率较高时才会进行批量重偏向为什么不能立刻偏向我们来逐条分析原因避免频繁撤销和重偏向带来的开销每次偏向锁撤销都需要进行一次全局安全点也就是操作如果每次遇到不同线程就重新偏向会导致大量操作反而降低性能类比就像不要因为一个人偶尔用了一次厕所就给每个新人都换一把厕所钥匙防止误判可能是偶发性竞争而非真正的多线程交替使用第一次发生偏向锁撤销可能只是个偶然事件比如只是临时访问一下后续还是长期使用如果此时就偏向那么下次再访问又要撤销来回折腾得不偿失类比你正在写代码同事借你鼠标用了一下这时候没必要把鼠标的使用权永久移交给他批量处理更高效减少次数是一种追求吞吐量的系统它倾向于将多个类似的小操作合并成一个大操作来优化性能所以设置了一个阈值默认是次当某一类对象发生撤销次数达到这个阈值时才统一进行批量重偏向这是一种典型的延迟优化策略只在真正需要的时候才做昂贵的操作批量重偏向的工作流程详细步骤描述获取锁对象进入偏向状态偏向尝试获取锁发现偏向触发偏向锁撤销第次撤销记录该类对象的撤销次数不做批量重偏向第次撤销达到阈值触发批量重偏向所有未被使用的该类对象被统一偏向当前线程后续访问再次访问这些对象时可以再次以偏向锁方式获得锁补充如果撤销特别频繁怎么办如果某类对象不仅撤销很多而且并发竞争很激烈比如多个线程同时抢锁还有一个更强力的机制批量撤销当撤销次数太多或并发太强时会直接禁用这类对象的偏向锁功能后续所有该类对象的锁都跳过偏向锁阶段直接使用轻量级锁或重量级锁如何查看调整这些参数你可以通过以下参数控制偏向锁的行为默认值默认值还可以启用诊断信息观察偏向锁状态总结一句话不会在第一次撤销偏向锁后就立刻偏向新线程是为了避免不必要的开销和误判只有当检测到某类对象频繁发生偏向锁撤销时才会触发批量重偏向统一将它们偏向新的线程这是一种典型的懒优化延迟决策策略体现了在性能与复杂度之间做出的精妙权衡非常好我们来系统详细地讲解一下偏向锁的撤销流程这是在多线程环境下优化锁性能的一个重要机制什么是偏向锁撤销偏向锁撤销是指当一个线程尝试获取某个对象的锁时发现该对象已经被偏向其他线程了于是触发的一系列操作用于清除偏向状态为后续锁升级做准备关键点偏向锁撤销不是直接升级为轻量级锁它只是取消偏向让对象回到中立状态为后续是否使用轻量级锁或再次偏向做准备撤销过程需要进入安全点也就是全局停顿所以代价较高偏向锁撤销的典型触发场景另一个线程尝试获取已被偏向的对象锁调用或进行批量重偏向或批量撤销我们重点讲解第一种情况另一个线程访问已偏向的对象场景模拟获取锁被偏向等待执行完毕尝试获取锁触发偏向锁撤销偏向锁撤销流程详解从的角度我们分步骤来看如何处理这个撤销过程第一步检查对象头对象头中的包含了偏向锁信息如线程和偏向时间戳发现对象处于偏向状态并且偏向的线程是不是自己第二步判断是否可以撤销如果当前没有其他线程正在并发修改该对象的状态那么可以进行撤销如果对象正被多个线程竞争则可能跳过撤销直接升级为轻量级锁第三步进入全局停顿因为要修改对象头的信息必须确保所有使用该对象的线程都处于安全状态触发一次即暂停所有线程这个过程会带来一定的性能开销第四步撤销偏向锁清除对象头中的偏向标志位清除线程和偏向时间戳将对象状态改为可偏向但未偏向或不可偏向状态如果是批量撤销策略的一部分还可能将整个类的对象统一撤销偏向状态第五步恢复线程执行并尝试获取锁结束线程继续运行继续尝试获取锁此时对象不再是偏向锁状态可能通过操作获取轻量级锁如果有多个线程竞争最终可能升级为重量级锁撤销后的状态变化以位为例锁状态内容无锁状态偏向锁轻量级锁指向栈中的指针重量级锁指向的指针撤销后中不再包含偏向信息变成状态或者直接进入轻量级锁状态批量撤销单个撤销类型描述单个撤销当某类对象发生少量偏向锁撤销时只对当前对象进行撤销批量撤销当某一类对象撤销次数超过阈值默认次会禁用该类的偏向锁机制所有对象直接跳过偏向锁阶段为什么偏向锁撤销代价高原因说明需要进入导致全局停顿影响吞吐量修改对象头必须在下完成否则可能造成数据不一致不一定有用撤销后如果只有一个线程访问又得重新偏向浪费资源总结偏向锁撤销的关键流程线程尝试获取锁发现对象处于偏向状态偏向判断是否满足撤销条件进入清除中的偏向信息退出继续尝试获取锁根据竞争情况决定是否升级为轻量级锁或重量级锁补充建议如果你希望更深入地观察对象头的变化比如查看的内容可以使用工具这是一个非常强大的调试工具以下是一个简单的示例代码初始对象布局加锁后加锁后运行结果可以看到的变化从而验证偏向锁撤销升级的过程撤销了获得了锁如果还没升级轻量级锁那是什么锁在的偏向锁撤销过程中当尝试获取已被偏向的对象锁时会发生偏向锁的撤销撤销后获取到的锁状态取决于具体的竞争情况和的优化策略撤销后的锁状态如果在撤销偏向锁之后还没有升级为轻量级锁那么此时的锁状态实际上是一个无锁但可偏向状态不过这并不意味着实际上是在这种状态下获得锁的让我们详细分析一下撤销后可能发生的情况场景回顾假设我们有如下场景线程获取偏向锁获得偏向锁等待完成线程尝试获取锁触发偏向锁撤销触发偏向锁撤销并尝试获取锁撤销过程简述获取了偏向锁对象被标记为偏向尝试获取锁发现对象已偏向触发偏向锁撤销进入暂停所有线程清除偏向信息继续执行尝试重新获取锁撤销后的锁状态分析撤销偏向锁后根据具体场景和的优化策略可能会出现以下几种情况直接进入轻量级锁如果在撤销偏向锁的过程中检测到存在潜在的竞争比如有其他线程也在等待这个锁可能会直接将锁升级为轻量级锁锁类型轻量级锁实现方式通过操作来尝试获取锁保持中立状态并重新偏向如果撤销偏向锁后没有其他线程竞争该锁可能会选择将对象的状态恢复为中立状态并允许再次偏向该对象锁类型无锁但可偏向说明虽然对象处于中立状态但由于没有竞争允许直接偏向该对象类似于初始的偏向锁状态竞争失败后升级为轻量级锁如果在撤销偏向锁后尝试通过操作获取锁但操作失败即有其他线程也在尝试获取锁则会将锁升级为轻量级锁锁类型轻量级锁说明失败表明存在竞争因此需要使用更复杂的同步机制来管理锁批量重偏向如果发现某一类对象频繁发生偏向锁撤销达到一定阈值默认是次它会进行批量重偏向将这些对象统一偏向新的线程如锁类型偏向锁偏向说明通过批量重偏向避免频繁撤销带来的性能损耗总结获得锁的具体情况根据上述分析当在撤销偏向锁后获得锁时可能遇到以下几种情况情况锁类型描述没有竞争无锁但可偏向或偏向锁偏向如果没有其他线程竞争可能重新偏向该对象轻微竞争轻量级锁如果有轻微竞争可能通过操作获取轻量级锁强烈竞争轻量级锁或重量级锁如果竞争激烈可能将锁升级为轻量级锁甚至重量级锁关键点撤销偏向锁并不会自动升级为轻量级锁而是根据具体情况决定后续步骤如果没有其他线程竞争可以重新偏向该对象继续享受偏向锁的优势如果有竞争则会根据竞争程度选择合适的锁机制轻量级锁或重量级锁非常棒的追问你抓住了偏向锁机制中一个核心但容易混淆的点在什么情况下才会让对象重新偏向另一个线程我们来系统清晰地解释这个问题你的问题本质你说得对前面我提到如果撤销后没有竞争可能会重新偏向该对象但你也记得只有当某个类的对象发生次偏向锁撤销后才会触发批量重偏向所以你问那是不是只有在第次撤销时才允许重新偏向为什么前面又说有可能直接重新偏向答案一句话总结是的只有当某类对象累计发生次偏向锁撤销时才会触发批量重偏向但在某些特定场景下也允许单个对象在撤销后重新偏向新线程这被称为单次重偏向或延迟偏向具体分析偏向锁撤销锁升级为轻量级锁如前所述偏向锁撤销只是清除偏向信息并不意味着立即升级为轻量级锁此时对象进入一种中间状态中立偏向状态表示它可以被再次偏向单个对象是否可以重新偏向答案是可以但这不是默认行为而是取决于以下条件条件一没有其他线程竞争如果当前只有一个线程访问该对象比如是唯一访问者那么可以将它重新偏向给这样做的好处是避免不必要的操作和锁升级提高性能条件二该类尚未触发批量重偏向或批量撤销如果这个类还没有达到撤销次数阈值默认次那么可能尝试让这个对象单独偏向如果已经达到了阈值则统一进行批量重偏向什么时候才能批量重偏向内部维护了一个撤销计数器用于统计某个类的对象发生偏向锁撤销的次数阈值行为撤销次不批量操作可能允许单个对象重新偏向撤销次触发批量重偏向所有未使用的该类对象都偏向当前线程撤销次触发批量撤销禁用该类对象的偏向锁示例说明获取偏向锁尝试获取锁第一次撤销偏向锁在这个例子中被偏向访问时触发第一次撤销因为只撤销了一次还没达到次可能选择将直接偏向而不是升级为轻量级锁但如果我们在多个对象上重复这个过程偏向所有对象访问这些对象第次撤销第次触发批量重偏向这时到第次撤销时发现这是同一个类的对象触发批量重偏向把这一类对象全部偏向后续访问就都可以使用偏向锁了总结一下关键区别类型是否需要达到撤销阈值是否适用于单个对象是否适用于多个对象单次重偏向不需要是否批量重偏向需要默认次否是最后总结一句话并不是必须等到次撤销才允许重新偏向而是在无竞争的情况下也可以让单个对象从状态重新偏向新的线程不过这种单次重偏向是有条件的且优先级低于批量重偏向这样设计的目的是避免不必要的锁升级减少次数保持偏向锁的灵活性和高效性如果如果撤销了的偏向然后会进行一个单对象偏向并计数如果后面这个对象又被请求了会撤销的偏向单对象偏向到并计数这个理解对吧你这个问题非常深刻已经触及了偏向锁机制中最核心最容易被误解的部分偏向锁的单对象重偏向行为和撤销计数器机制你的理解总结如下撤销了的偏向锁后如果无竞争可以对该对象重新偏向自己并记录一次撤销后续又访问该对象时又会撤销的偏向并偏向回再次记录一次撤销这样来回切换每撤销一次都会计入类撤销计数器中如果达到阈值如次就会触发批量重偏向答案一句话总结基本正确但有一些细节需要注意单个对象确实可以在之间来回偏向但每次撤销都会增加对这个类的撤销计数器当撤销次数达到一定阈值默认时会触发批量重偏向如果撤销频繁且并发严重还可能直接进入批量撤销禁用偏向锁更详细解释偏向锁是线程绑定的中每个偏向锁信息不仅包含线程还包括一个叫的时间戳字段用于判断偏向是否过期当发生以下情况之一时对象会被撤销偏向另一个线程尝试获取锁调用了发生了偏向锁需要重新验证有效性单个对象可以反复偏向不同线程这是的一种优化策略称为延迟偏向或可恢复偏向示例流程获取锁被偏向获取锁撤销的偏向被偏向再次获取锁撤销的偏向被偏向在这个过程中在之间来回偏向每次撤销都会触发一次并且每次撤销都会增加该类的撤销计数器如果这类对象的撤销总数达到了次就会触发批量重偏向类撤销计数器的作用不是对每个对象单独统计撤销次数而是对类级别进行统计例如所有的实例共用一个撤销计数器每次某个实例发生偏向锁撤销这个计数器就加一达到阈值后默认觉得这些对象经常被多个线程交替使用就会统一将这批对象偏向当前线程即批量重偏向如果撤销特别多比如次甚至会直接禁用该类的偏向锁撤销计数器与偏向锁状态变化的关系撤销次数行为允许单个对象重新偏向新线程不触发批量操作第一次触发批量重偏向已经处于批量重偏向状态后续对象偏向当前线程触发批量撤销禁用该类的偏向锁补充说明为什么允许单对象重偏向的设计哲学是只有真正需要的时候才做昂贵的操作所以即使发生了几次撤销只要还没达到批量阈值就不会贸然升级为轻量级锁或重量级锁而是先尝试让对象继续使用偏向锁机制这在一些线程交替使用的场景下非常有用比如线程池中的线程轮流执行任务多个消费者轮询同一个队列等总结一下你的理解是否正确说法是否准确说明撤销的偏向锁后可以重新偏向自己正确如果无竞争允许单对象重新偏向再次访问时又能撤销的偏向正确如果无竞争允许再次偏向每次撤销都会计入类的撤销计数器正确是的用于触发批量重偏向撤销达到次会触发批量重偏向正确默认阈值是触发批量重偏向推荐实践建议如果你在开发中遇到以下情况锁对象被多个线程交替访问频繁发生偏向锁撤销日志中出现大量操作你可以考虑使用关闭偏向锁适用于高并发服务或者调整撤销阈值仅调试用在偏向锁的设计中线程如何判断线程是否已经执行完同步代码释放锁并不是通过主动通知或标记实现的而是通过竞争时的锁撤销机制来处理的以下是详细流程偏向锁的基本假设偏向锁的核心思想是锁通常只会被同一个线程重复获取其他线程的竞争是罕见的因此线程获取偏向锁后退出同步块时不会主动清除中的线程即不会显式释放锁线程在尝试获取锁时需要被动触发检查来判断线程是否仍持有锁线程如何检测线程是否释放锁当线程尝试获取一个已偏向线程的锁时会执行以下步骤步骤检查的线程线程读取对象的发现线程指向线程而非自己此时需要判断线程是否仍逻辑上持有锁步骤触发偏向锁撤销会暂停线程通过安全点并检查线程的执行状态如果线程已退出同步块即释放锁线程的栈帧中没有该对象的锁记录会将对象重置为匿名偏向状态线程清零标志位保持线程可以尝试重新偏向将自己的线程写入如果线程仍在同步块中即未释放锁线程的栈帧中存在该对象的锁记录会撤销偏向锁将锁升级为轻量级锁将复制到线程的锁记录中用将替换为指向锁记录的指针轻量级锁状态线程会通过自旋尝试竞争轻量级锁关键问题如何知道线程是否退出同步块通过遍历线程的栈帧检查是否存在该对象的锁记录存在锁记录线程仍在同步块中未释放锁不存在锁记录线程已退出同步块已释放锁为什么需要暂停线程如果不暂停线程可能在检查过程中线程恰好退出同步块导致误判通过安全点暂停线程可以确保检查期间线程的状态稳定流程图线程尝试获取偏向锁读取发现偏向线程线程已退出同步块无锁记录是撤销偏向锁对象重置为匿名偏向状态线程尝试重新偏向否升级为轻量级锁线程自旋竞争如果撤销次数超过阈值触发批量重偏向或批量撤销性能优化批量重偏向与撤销批量重偏向如果同一个类的偏向锁被频繁撤销默认次会认为线程可能不再需要偏向锁允许该类的对象直接偏向新的线程线程而无需每次撤销批量撤销如果撤销次数更高默认次会彻底禁用该类的偏向锁后续所有实例直接使用轻量级锁总结偏向锁的释放是隐式的线程退出同步块后不会主动修改线程通过触发撤销机制检测锁状态暂停线程检查栈帧中的锁记录判断线程是否释放锁升级策略无竞争保持偏向或重新偏向有竞争升级为轻量级锁这种机制在无竞争场景下避免了同步开销而在竞争发生时通过撤销和升级保证正确性是的你的理解是正确的关键结论如果线程已经释放了锁退出同步代码块那么它的栈帧中对应的就会被移除此时其他线程如线程在尝试获取锁时会通过检查线程的栈帧确认是否存在该对象的不存在线程已释放锁对象可重新偏向或升级为轻量级锁存在线程仍持有锁触发锁升级轻量级锁重量级锁详细流程分析偏向锁场景下的作用获取偏向锁时线程首次进入同步块时会在其栈帧中创建一个用于存储锁对象的信息即使偏向锁不严格需要它但仍会生成一个空的作为标记如果后续没有竞争线程再次进入同步块时只需检查中的线程无需操作释放偏向锁时线程退出同步块后会被立即移除栈帧弹出或复用但对象的仍然保持偏向线程的状态不会主动清除线程线程如何检测锁是否释放当线程尝试获取已被线程偏向的锁时会暂停线程检查线程的栈帧如果找不到该对象的说明线程已释放锁会将对象重置为匿名偏向状态允许线程重新偏向如果找到说明线程仍持有锁会撤销偏向锁升级为轻量级锁通过竞争轻量级锁场景下的轻量级锁的会明确存储对象的原对象头的拷贝释放轻量级锁时会将还原回对象头并清除栈帧中的为什么偏向锁不立即清除的线程性能优化偏向锁假设线程可能会重复获取锁保留偏向状态可以避免下次获取时的操作懒清除只有发生竞争时才通过撤销机制清除或升级锁状态示例代码与内存变化匿名偏向线程进入同步块偏向线程栈帧中生成可能为空更新为线程线程退出同步块被移除仍保留线程但锁已逻辑释放线程尝试获取锁触发偏向锁撤销检查线程的栈帧发现无锁已释放重置为匿名偏向或升级为轻量级锁总结场景状态锁状态变化线程持有偏向锁存在标记作用记录线程线程释放锁被移除仍保留线程但锁已逻辑释放线程竞争锁检查线程的栈帧确认无记录撤销偏向锁重置或升级理解这一点对分析锁竞争偏向锁撤销机制至关重要好的轻量级锁的撤销过程是中锁机制的核心部分它发生在多个线程竞争同一个锁时需要将轻量级锁升级为重量级锁通过操作系统互斥量实现下面我会详细讲解整个过程包括触发条件具体步骤和底层实现轻量级锁的基本原理在介绍撤销之前先回顾轻量级锁的运行机制适用场景低竞争环境多个线程交替执行同步代码但不会同时竞争加锁过程线程进入同步块时会在栈帧中创建一个锁记录存储对象的称为通过尝试将对象的替换为指向的指针如果成功线程获得轻量级锁如果失败说明有竞争进入锁膨胀流程轻量级锁的撤销升级为重量级锁当多个线程竞争同一个轻量级锁时会触发锁膨胀将轻量级锁升级为重量级锁具体流程如下触发条件失败线程尝试获取锁时发现已经指向线程的说明线程持有锁自旋失败线程会进行短时间的自旋默认次可通过调整如果自旋后仍未获得锁触发锁膨胀撤销流程分配一个对象重量级锁的核心结构每个对象在锁膨胀后都会关联一个也称为管程或互斥锁包含持有锁的线程如线程竞争锁的阻塞线程队列如线程调用的线程队列修改指向对象对象的会被更新为指向的指针标志位变为表示重量级锁线程的原对象头会被存入线程进入阻塞状态线程尝试获取锁时发现锁已被升级为重量级锁会进入等待操作系统调度可能被挂起线程释放锁线程退出同步块时会调用指令如果为空无竞争的被置为如果不为空如线程在等待唤醒一个线程线程来竞争锁轻量级锁重量级锁特性轻量级锁重量级锁实现方式栈帧操作系统竞争处理自旋少量线程阻塞内核态调度适用场景低竞争线程交替执行高竞争多线程同时抢锁性能开销低用户态操作高涉及内核态切换示例代码分析线程获取轻量级锁成功指向释放锁如果是轻量级锁恢复线程触发锁膨胀失败自旋锁膨胀进入阻塞执行流程线程获取轻量级锁成功线程尝试失败自旋后仍无法获取触发锁膨胀分配线程进入阻塞线程释放锁后唤醒线程关键点总结轻量级锁撤销的触发条件失败自旋失败升级为重量级锁的核心步骤分配对象修改指向竞争线程进入阻塞队列性能影响锁膨胀后线程切换涉及内核态调度开销较大通过这种方式在低竞争时使用轻量级锁高效高竞争时退回到重量级锁保证正确性精确地描述轻量级锁升级为重量级锁的过程以下是详细分析关键结论线程不会归还失败而是线程的竞争失败后触发锁膨胀轻量级锁的撤销即升级为重量级锁是由竞争线程线程发起的而非持有锁的线程线程最终所有线程包括线程都会切换到重量级锁模式由统一管理完整流程分析初始状态线程持有轻量级锁线程通过成功将对象的替换为指向自己栈帧中的指针此时对象头存储的是轻量级锁状态标志位指向的指针线程尝试获取锁触发锁膨胀当线程尝试通过竞争锁时失败发现已被线程占用指向线程的自旋优化线程短暂自旋默认次尝试等待线程释放锁如果自旋期间线程释放了锁线程会成功获取轻量级锁如果自旋失败开始锁膨胀流程锁膨胀升级为重量级锁分配一个对象重量级锁的核心结构修改对象头将更新为指向的指针标志位变为线程的原对象头会被存入线程释放锁时发现对象已升级为重量级锁会调用指令将的置为并唤醒中的阻塞线程如线程线程进入阻塞队列线程在锁膨胀后会直接进入的等待操作系统调度可能被挂起关键点澄清线程的归还不会失败线程释放锁时如果锁尚未膨胀会正常恢复轻量级锁流程如果锁已膨胀线程会走重量级锁的释放流程操作锁膨胀的触发者是竞争线程线程而非持有线程线程流程图解线程获取轻量级锁成功指向线程的线程尝试获取锁失败自旋仍失败触发锁膨胀分配指向线程进入阻塞线程释放锁若未膨胀恢复轻量级锁若已膨胀调用唤醒线程为什么需要重量级锁轻量级锁的局限性依赖自旋高竞争时浪费资源重量级锁的优势通过操作系统实现线程阻塞唤醒避免空转总结阶段线程持有锁线程竞争锁轻量级锁阶段成功指向失败自旋锁膨胀触发无操作自旋失败发起锁膨胀重量级锁阶段释放时操作进入阻塞通过这种机制在低竞争时保持高效轻量级锁高竞争时退回到安全模式重量级锁锁消除锁消除是在编译阶段进行的一种同步优化技术属于逃逸分析的一部分它的目标是如果一个对象不会被其他线程访问到即没有线程竞争那么即使代码中使用了也可以将这个锁消除掉从而避免不必要的同步开销锁消除的本质中的是一种安全但有代价的机制它会带来对象头的修改操作或获取可能的上下文切换线程挂起和唤醒但在很多场景下这些同步操作其实是不必要的因为对象只在当前线程内部使用方法虽然用了但根本没有并发访问甚至只是临时变量根本不可能逃逸出当前线程在这种情况下就可以通过锁消除技术把无意义的同步操作去掉提升性能锁消除的前提逃逸分析锁消除依赖于逃逸分析它是的一种分析技术用来判断一个对象是否会被多个线程访问逃逸分析的三种状态类型含义不逃逸对象仅在当前方法或线程中使用不会被外部访问方法逃逸对象作为参数传递给其他方法可能被其他线程访问线程逃逸对象被发布到全局变量静态变量或其它线程可见的地方只有当对象是不逃逸时才有可能进行锁消除示例说明示例锁可以被消除的情况只在当前线程使用不会被其他线程访问在这个例子中是局部变量没有把它传给其他线程它的作用域只在当前方法中所以它是不逃逸对象可以进行锁消除直接去掉块带来的同步开销示例锁不能被消除的情况是类成员变量可能被其他线程访问在这个例子中是类成员变量其他线程可能通过访问它所以它逃逸出了当前方法不能进行锁消除必须保留同步逻辑如何开启锁消除锁消除默认在模式下的中是开启的前提是启用了逃逸分析你可以通过以下参数来控制默认开启开启锁消除默认开启如果你希望禁用锁消除比如为了测试性能影响与适用场景场景是否适合锁消除说明大量使用局部变量加锁非常适合如作为锁对象使用内部用适合如果作用域小且不逃逸使用或视情况而定如果它们不逃逸也可能被优化多线程共享对象加锁不适合必须保留锁机制总结一句话锁消除是利用逃逸分析技术在编译期识别并移除那些实际上不存在并发竞争的同步操作从而减少不必要的锁开销提高程序执行效率的一种优化手段和是编程语言中用于线程间通信的两个方法它们定义在类中这两个方法允许线程在某个条件不满足时挂起自己并在条件可能改变时通知其他线程重新检查条件基本概念当一个线程调用一个对象的方法时它会释放该对象的锁并进入等待状态直到另一个线程调用该对象的或方法或者经过指定的时间如果使用了带参数的方法唤醒在此对象监视器上等待的一个线程选择是任意的也就是说会选择一个线程来唤醒被唤醒的线程不能立即继续执行因为它必须重新获取对象的锁而这个锁可能已经被其他线程持有与不同会唤醒所有在此对象监视器上等待的线程这些线程将竞争对象的锁只有获得锁的线程才能继续执行使用场景和通常用于生产者消费者模式缓冲区满空的情况等需要线程协作的场景例如当一个线程需要等待某个特定条件成立时它可以调用而当另一个线程改变了这个条件并希望通知等待的线程时它可以调用或示例代码下面是一个简单的例子展示了如何使用和来实现两个线程之间的基本同步如果资源已经存在则生产者等待通知消费者可以消费了如果资源不存在消费者等待通知生产者可以生产了在主类中启动线程在这个例子中类代表共享资源和方法分别模拟生产和消费操作每个方法都声明为以确保一次只有一个线程可以访问当资源不可用时相应的线程会调用进入等待状态当资源状态改变时线程通过来通知其他线程注意事项必须从同步上下文中调用和即它们必须在由关键字保护的代码块或方法中被调用否则会抛出异常调用时应该总是放在循环中而不是简单的语句里因为可能存在虚假唤醒的情况即没有收到通知的情况下线程也可能被唤醒只唤醒一个等待的线程但无法控制哪一个会被选中如果你有多个线程在等待并且你需要精确控制哪个线程被唤醒那么你可能需要更复杂的机制如和对象由于和的行为可能会导致死锁或竞态条件因此在设计多线程程序时要非常小心地处理这些问题保护性暂停是一种设计模式用于在多线程环境下控制线程的行为确保某个线程在特定条件满足之前不会继续执行这种模式通常用来解决线程之间的协作问题比如生产者消费者问题读者写者问题等模式描述在保护性暂停模式中一个线程会检查某个条件是否满足如果条件不满足则该线程会被挂起直到另一个线程修改了这个条件并通知它继续执行这种方式可以避免轮询带来的资源浪费同时也能够确保只有在条件合适时才会进行相应的处理实现方式在中实现保护性暂停模式可以通过和方法来完成这两个方法定义在类中用于线程间的通信以下是一个简单的示例展示了如何使用保护性暂停模式通知所有等待的线程超时退出使用示例创建一个模拟获取数据的线程假设需要秒才能准备好数据主线程尝试获取数据等待最多秒在这个例子中类封装了一个对象并通过方法实现了保护性暂停逻辑当调用方法时如果还没有被设置则当前线程将进入等待状态直到其他线程通过调用方法设置了并调用了来唤醒所有等待的线程关键点条件判断在循环中使用方法等待条件成立这是因为可能存在虚假唤醒的情况即使没有收到通知也可能唤醒等待的线程所以必须再次检查条件是否真的满足超时机制在实际应用中为了防止无限期等待通常会加入超时机制如上面代码中的参数确保线程不会永远处于等待状态锁的管理注意和必须在同步上下文中调用即在由修饰的方法或代码块中调用否则会导致异常保护性暂停模式是处理线程间协作问题的一个强大工具但在设计和实现时需要仔细考虑各种可能的并发情况以避免死锁或其他并发问题和是并发工具包中提供的低级线程阻塞和唤醒机制它们是由类提供的这两个方法提供了比传统的更灵活的线程控制方式主要用于构建更高级别的同步工具如锁信号量等和的基本概念可以理解为让当前线程停在某个地方类似于或但更加灵活调用会让当前线程进入等待状态直到发生以下情况之一调用了对应的方法线程被中断超时如果使用的是带超时参数的或方法用于解除一个线程的阻塞状态与不同可以先于调用也就是说你可以提前许可一个线程然后当该线程调用时它会立即返回而不是进入等待状态提供的方法以下是类中与和相关的主要方法使当前线程进入等待状态除非获得了许可通过先前调用或者中断与类似但是带有超时时间单位是纳秒使当前线程进入等待状态直到指定的时间点授予给定线程许可使其可以从调用中恢复执行如果该线程没有被则下次调用时会立即返回而不阻塞示例代码下面是一个简单的例子展示了如何使用和线程开始等待当前线程将在这里等待直到另一个线程调用线程继续执行让主线程暂停一段时间确保已经开始执行并调用了唤醒特点许可机制和使用了一种许可的概念每次调用就像是给目标线程发放一张许可票而每次调用则是尝试消耗这张票如果已经有一张未使用的票则会立即返回如果没有可用的票则当前线程会被挂起直到获得新的许可或线程被中断灵活性不同于必须配合对象的监视器锁一起使用没有这种限制因此它们提供了更高的灵活性优先性可以在之前调用这意味着你可以在需要的时候预先发出许可这使得编写某些类型的并发算法变得更加简单直接总之和提供了一种强大且灵活的方式来控制线程的行为特别是在开发自定义同步工具时非常有用不过由于它们属于较低级别的操作通常建议仅在构建更高级别的同步原语时使用而非直接在应用逻辑中频繁调用死锁定义当两个或多个线程无限期地等待彼此持有的资源时就会发生死锁换句话说每个线程都在等待另一个线程释放它所需要的资源从而导致所有涉及的线程都无法继续执行死锁发生的四个必要条件条件互斥条件至少有一个资源必须处于非共享模式即一次只能被一个线程占用占有并等待条件一个线程已经占有了至少一个资源同时还在等待其他线程所占有的资源不可剥夺条件资源不能被强制从一个线程那里剥夺而只能由拥有它的线程主动释放循环等待条件存在一个线程的环形等待序列其中每个线程都在等待下一个线程所拥有的资源示例代码活锁定义活锁类似于死锁但是不同之处在于涉及到的线程并没有被阻塞而是不断地尝试完成操作但由于某些条件始终未能满足导致它们不断重试却永远无法成功这种情况通常发生在避免冲突的算法中例如两个线程试图互相礼让对方先访问资源结果反而谁也无法前进示例情景假设两个线程都需要更新数据库中的同一条记录为了防止数据不一致它们都检查是否有其他线程正在修改这条记录如果检测到有其他线程正在修改则当前线程会放弃自己的修改尝试并重新开始整个过程若这两个线程总是同时检测到对方正在修改那么它们就永远不会完成任何修改饥饿定义饥饿是指一个线程由于长期得不到足够的资源来执行其任务从而无法向前推进的情况这可能是由于调度器不公平地分配时间或者是因为优先级较高的线程频繁抢占资源导致低优先级线程几乎得不到执行机会常见原因资源不足系统没有足够的资源供所有线程使用优先级倒置高优先级的线程频繁抢占低优先级线程所需的资源不合理的锁竞争策略比如某些线程总是在获取锁时失败因为其他线程总是更快地获取到了锁解决方案针对上述三种问题可以采取不同的解决策略死锁预防检测恢复通过设计避免满足条件之一使用死锁检测算法定期扫描系统的状态一旦检测到死锁可以通过回滚事务等方式进行恢复活锁解决引入随机化的退避机制使得线程在遇到冲突时不立即重试而是等待一段时间后再试饥饿缓解确保公平性例如使用公平锁保证请求资源的顺序与到达顺序一致调整线程优先级策略等并发包简称中的框架提供了一种比传统的更灵活的同步机制它允许更细粒度地控制锁的行为并提供了诸如尝试获取锁可中断获取锁超时获取锁等功能一基础架构核心接口是提供的一个接口定义了锁的基本操作获取锁如果锁不可用则当前线程处于等待状态直到获得锁可中断地获取锁尝试非阻塞地获取锁带超时功能的获取锁释放锁返回一个绑定到此对象的新实例锁的实现类最常用的重入锁实现支持公平锁和非公平锁模式读写锁允许多个读线程同时访问但写线程独占访问权引入的一种新的锁机制适用于读多写少的场景提供了乐观读取的能力二具体设计设计细节的核心是基于实现的是中的基础同步器框架通过队列来管理线程的竞争情况公平锁非公平锁公平锁会按照请求锁的顺序来分配锁即先请求的线程先获得锁非公平锁则允许插队新来的线程有机会抢占锁这可以减少上下文切换提高吞吐量可重入特性同一线程可以多次获取同一个锁而不导致死锁每次获取锁都会增加持有计数释放锁时减少计数只有当计数归零时才真正释放锁设计细节分为读锁和写锁分别实现了不同的锁策略读锁允许多个读线程同时持有只要没有写线程在操作即可写锁是排他的只有一个写线程能持有锁且不允许任何其他读或写操作设计细节引入了一个戳的概念用于标识锁的状态它支持三种模式写锁类似于传统的互斥锁读锁允许多个读线程同时持有乐观读锁假设没有写操作发生直接返回一个版本号作为戳如果后续发现确实有写操作发生了则需要重新获取正确的数据三场景应用使用替代当你需要更复杂的锁行为时如尝试获取锁带超时的获取锁等可以使用例如访问共享资源使用在读多写少的情况下提高性能如果你的应用场景中读操作远多于写操作可以使用来提高并发性能多个线程可以同时读取排他性写入使用在读多写少且适合乐观锁的场景对于读操作非常频繁而写操作较少的情况提供了更高的性能进行读操作如果检测到写操作发生升级为悲观读锁重新读取原理一架构图与类结构接口内部类是接口的实现类内部依赖来实现线程阻塞唤醒资源管理它通过内部类继承来完成真正的加锁逻辑二继承结构与类关系公平锁非公平锁是一个封装类真正加解锁逻辑都在中是的子类实现了等核心方法公平锁非公平锁的差异体现在方法的实现上三核心字段构造时根据参数使用或四加锁流程源码入口提供的模板方法中的流程分解尝试获取锁如果是可重入场景当前线程是持有者直接成功返回如果锁是空闲状态设置为占用状态失败后入队线程封装成加入等待队列排队自旋判断是否排到队头是则再次尝试加锁否则挂起自己五解锁流程模板方法的尝试释放锁如果降为设置持有线程为表示完全释放唤醒队列中的下一个线程调用唤醒队列中下一个等待线程六公平锁非公平锁非公平锁默认不管队列有没有人直接抢锁可重入逻辑非公平锁更激进更倾向于新来的线程插队公平锁先进先出只有队列没有线程等待才尝试抢锁公平锁在每次加锁前都会判断自己是不是排队中的第一个七重入的实现方式每次成功内部每次内部当才真正释放锁可重入场景真正释放八条件变量支持比更强大灵活等待并释放锁唤醒一个等待线程唤醒所有等待线程底层同样通过的实现拥有自己的等待队列总结图示成功继续失败入队下一个总结一句话是基于的可重入独占锁内部用状态变量和队列控制线程竞争支持公平非公平模式灵活强大这段代码是并发包中类的核心方法之一这个方法的作用是让线程在等待获取同步状态锁时以一种高效公平且可中断的方式挂起和唤醒它是实现如等并发工具的基础逻辑背景知识是什么是一个用来构建锁和同步器的框架由编写是并发包的核心组件之一它通过一个类型的状态变量来表示资源是否被占用并维护一个队列来管理等待获取资源的线程方法签名解析这是内部注解用于标记该方法调用链需要避免栈溢出检测特定优化当前线程封装成的一个节点已加入到的等待队列中尝试获取的同步状态值对于通常是返回值是否被中断过方法作用总结该方法负责让线程在队列中自旋等待获取锁如果失败则阻塞直到被前驱节点唤醒或中断它是非响应中断版本的独占式获取即允许线程被中断但不会提前释放节点主要流程详解逐行分析变量定义自旋循环循环体说明获取当前节点的前驱节点每个节点都保存了前驱节点如果当前节点不是头节点的后继节点则不能立即抢锁尝试获取锁只有头节点的下一个节点才有资格抢锁成功获取锁将当前节点设为头节点原头节点无引用帮助回收标记成功获取返回是否被中断这里体现了一个公平性机制只有当前节点是头节点的下一个节点时才尝试获取锁是抽象方法由子类实现具体的获取逻辑比如获取失败后的处理判断当前节点是否应该被挂起它会检查前驱节点的状态并可能设置为状态表示当前节点需要被唤醒如果前驱节点状态正常则返回表示可以安全地挂起当前线程使用阻塞当前线程如果线程在此期间被中断返回记录下来块中的异常处理如果在获取过程中出现异常如或其他错误仍为则调用清理当前节点设置节点状态为从队列中移除无效节点队列结构简述使用的是一个双向链表构成的队列每个节点包含以下信息当前线程前驱节点后继节点节点状态节点类型共享独占当线程获取锁失败时会被包装成插入到队列尾部并进入阻塞状态总结一句话是中用于实现线程排队获取锁的核心方法它通过自旋阻塞唤醒机制实现了高效公平可中断的锁获取逻辑扩展建议如果你对感兴趣还可以继续研究以下几个相关方法和概念方法名功能释放同步状态解锁共享模式下的获取与释放如对的支持用于实现语义共享模式下传播唤醒这段代码是中的方法它是实现线程挂起与唤醒机制的核心逻辑之一作用判断当前线程是否应该被阻塞挂起这个方法的作用是在尝试获取锁失败后决定当前节点是否应该被挂起以节省资源并等待前驱节点唤醒自己它主要做三件事如果前驱节点状态是说明它会唤醒当前节点可以安全挂起如果前驱节点状态是已取消跳过所有已取消的前驱节点重新连接链表否则状态为或尝试将前驱节点设为并返回表示本次不挂起下一轮再判断参数说明当前节点的前驱节点当前线程封装成的节点正在排队等待获取锁返回值含义可以安全地挂起当前线程调用不能挂起需要再次尝试获取锁或设置前驱节点状态后再重试逐段解析代码第一步检查前驱节点的状态如果前驱节点的表示前驱节点在释放锁时会通知当前节点所以当前节点可以安心地挂起等待唤醒直接返回表示可以第二步处理前驱节点被取消的情况意味着前驱节点是状态比如线程被中断超时等这种情况下需要从队列中跳过这些取消的节点找到一个有效的前驱节点然后把当前节点的指向该有效节点并更新该节点的指向当前节点最终返回让外层继续循环而不是挂起注意此时不会立即挂起线程而是让其重新进入自旋重新尝试获取锁第三步设置前驱节点为如果前驱节点状态是或共享模式传播就尝试将其状态改为使用原子操作保证线程安全返回表示本轮不能挂起线程下次再判断的几个关键值值含义默认状态新加入的节点初始状态当前节点的后继节点需要被唤醒当前线程被取消如中断超时当前节点在条件队列中用于共享模式下表示传播唤醒流程图示意当前节点前驱节点可挂起跳过取消节点更新或设置举个例子非公平锁假设有三个线程依次请求获取成功获取锁请求失败加入队列成为头节点的后继节点请求失败加入队列成为的后继节点当执行到时它的前驱节点是如果的就会通过把标记为返回不会立刻挂起而是再循环一次直到确认已经准备好唤醒它总结一句话是控制线程是否应该被挂起的关键逻辑它通过检查和修改前驱节点的状态确保线程只在合适的时候被挂起从而实现高效公平的并发控制是引入的一种锁机制位于包中它提供了一种比传统的读写锁如更灵活且可能更高效的替代方案尤其适用于读操作远多于写操作的场景与读写锁不同的是提供了乐观读锁的功能这使得在某些情况下可以进一步提升性能主要特点三种锁模式支持三种类型的锁模式写锁独占锁当一个线程获取了写锁之后其他任何线程都不能获取读锁或写锁读锁共享锁允许多个线程同时持有读锁只要没有线程持有写锁乐观读锁一种非阻塞的读锁允许其他线程尝试获取写锁如果在执行期间没有发生写操作则读操作可以成功否则需要重试戳记每次获取锁都会返回一个戳记该戳记用于后续的操作验证以及解锁这种设计使得锁的状态检查和解锁操作更加直观和高效不可重入性不支持重进入这意味着如果一个线程已经持有了某个锁它不能再次获取同一个锁无条件的锁降级虽然不支持重进入但是支持从写锁到读锁的有条件降级常用方法写锁相关获取写锁并返回一个戳记使用指定的戳记释放写锁读锁相关获取读锁并返回一个戳记使用指定的戳记释放读锁乐观读锁相关尝试获取乐观读锁并立即返回一个戳记验证戳记是否仍然有效即在此期间是否有写操作发生使用示例以下是一个简单的例子展示了如何使用写锁示例悲观读锁示例乐观读锁示例可能会失败如果验证失败转换为悲观读锁验证适用场景特别适合那些读操作远远多于写操作的应用场景比如缓存配置管理等通过使用乐观读锁可以在很大程度上减少锁竞争提高程序的并发度然而由于其复杂性和不支持重进入的特点在使用时需要特别小心确保正确处理各种情况下的锁获取和释放对于一些复杂的业务逻辑可能更适合使用或者其他高级同步工具',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-26 18:02:58',
  postMainColor: '#5393E3',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">个人主页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://benedicttom.github.io/home/" title="个人主页"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Joie's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AMQP/" style="font-size: 1.05rem;">AMQP<sup>1</sup></a><a href="/tags/CI-CD/" style="font-size: 1.05rem;">CI/CD<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 1.05rem;">ElasticSearch<sup>3</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/Http/" style="font-size: 1.05rem;">Http<sup>2</sup></a><a href="/tags/I-O/" style="font-size: 1.05rem;">I/O<sup>2</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>9</sup></a><a href="/tags/MongoDB/" style="font-size: 1.05rem;">MongoDB<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 1.05rem;">Mysql<sup>2</sup></a><a href="/tags/ORM/" style="font-size: 1.05rem;">ORM<sup>3</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>5</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>7</sup></a><a href="/tags/Redisson/" style="font-size: 1.05rem;">Redisson<sup>1</sup></a><a href="/tags/Rpc/" style="font-size: 1.05rem;">Rpc<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>3</sup></a><a href="/tags/Spring-Cloud/" style="font-size: 1.05rem;">Spring Cloud<sup>5</sup></a><a href="/tags/Spring-Data/" style="font-size: 1.05rem;">Spring Data<sup>5</sup></a><a href="/tags/Swagger/" style="font-size: 1.05rem;">Swagger<sup>2</sup></a><a href="/tags/%E4%B8%9A%E5%8A%A1/" style="font-size: 1.05rem;">业务<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 1.05rem;">云原生<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 1.05rem;">八股<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">分布式锁<sup>1</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3/" style="font-size: 1.05rem;">力扣<sup>10</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>9</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 1.05rem;">定时任务<sup>3</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>9</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">开发工具<sup>2</sup></a><a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">异步编程<sup>1</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">推荐<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/" style="font-size: 1.05rem;">权限校验<sup>4</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>1</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 1.05rem;">树<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.05rem;">消息队列<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>2</sup></a><a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 1.05rem;">缓存<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 1.05rem;">运维<sup>2</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">September 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">46</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">July 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">28</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">June 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url">并发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>多线程</span></a><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>并发</span></a></span></div></div><h1 class="post-title" itemprop="name headline">多线程_锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-05T07:19:35.718Z" title="Created 2025-07-05 15:19:35">2025-07-05</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-26T10:02:58.103Z" title="Updated 2025-08-26 18:02:58">2025-08-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.picgo.net/2025/07/07/0963a560354758f9ef0c7067907aa1405fffec21d4abeea6.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/"><header><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url">并发</a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url">多线程</a><a href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url">并发</a><h1 id="CrawlerTitle" itemprop="name headline">多线程_锁</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Joie</span><time itemprop="dateCreated datePublished" datetime="2025-07-05T07:19:35.718Z" title="Created 2025-07-05 15:19:35">2025-07-05</time><time itemprop="dateCreated datePublished" datetime="2025-08-26T10:02:58.103Z" title="Updated 2025-08-26 18:02:58">2025-08-26</time></header><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><code>synchronized</code> 是 Java 编程语言中的一个关键字，用于实现线程同步（Thread Synchronization），以确保多个线程在并发访问共享资源时的正确性和可见性。它是 Java 提供的一种内置锁机制，也被称为<strong>监视器锁（Monitor Lock）<strong>或</strong>对象锁（Intrinsic Lock）</strong>。</p>
<hr>
<h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p><code>synchronized</code> 的主要作用是：</p>
<ol>
<li><strong>保证原子性（Atomicity）</strong>：确保某段代码在同一时刻只能被一个线程执行。</li>
<li><strong>保证可见性（Visibility）</strong>：当一个线程修改了共享变量的值，其他线程可以立即看到这个修改。</li>
<li><strong>保证有序性（Ordering）</strong>：防止指令重排序带来的问题。</li>
</ol>
<hr>
<h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><h3 id="1-同步方法（Synchronized-Method）"><a href="#1-同步方法（Synchronized-Method）" class="headerlink" title="1. 同步方法（Synchronized Method）"></a>1. 同步方法（Synchronized Method）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于<strong>实例方法</strong>，锁是当前对象 <code>this</code>。</li>
<li>对于<strong>静态方法</strong>，锁是当前类的 <code>Class</code> 对象（即 <code>ClassName.class</code>）。</li>
</ul>
<h3 id="2-同步代码块（Synchronized-Block）"><a href="#2-同步代码块（Synchronized-Block）" class="headerlink" title="2. 同步代码块（Synchronized Block）"></a>2. 同步代码块（Synchronized Block）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更灵活地指定锁对象，避免对整个方法加锁，提高性能。</li>
<li>推荐做法：优先使用同步代码块而不是同步整个方法。</li>
</ul>
<h3 id="3-静态方法同步"><a href="#3-静态方法同步" class="headerlink" title="3. 静态方法同步"></a>3. 静态方法同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只能有一个线程执行该方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>锁的是 <code>Example.class</code>，而非某个对象实例。</li>
</ul>
<hr>
<h2 id="三、锁的特性"><a href="#三、锁的特性" class="headerlink" title="三、锁的特性"></a>三、锁的特性</h2><h3 id="1-可重入（Reentrant）"><a href="#1-可重入（Reentrant）" class="headerlink" title="1. 可重入（Reentrant）"></a>1. 可重入（Reentrant）</h3><p>Java 的 <code>synchronized</code> 是可重入锁。也就是说，同一个线程可以多次进入已经被自己持有的同步块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        methodB(); <span class="comment">// 允许再次获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-不可中断（Non-interruptible）"><a href="#2-不可中断（Non-interruptible）" class="headerlink" title="2. 不可中断（Non-interruptible）"></a>2. 不可中断（Non-interruptible）</h3><p>如果一个线程因为等待获取 <code>synchronized</code> 锁而阻塞，它不能通过调用 <code>interrupt()</code> 来中断。</p>
<h3 id="3-非公平锁（Non-Fair）"><a href="#3-非公平锁（Non-Fair）" class="headerlink" title="3. 非公平锁（Non-Fair）"></a>3. 非公平锁（Non-Fair）</h3><p><code>synchronized</code> 是非公平锁，即不保证等待时间最长的线程最先获得锁。</p>
<hr>
<h2 id="四、底层原理简述"><a href="#四、底层原理简述" class="headerlink" title="四、底层原理简述"></a>四、底层原理简述</h2><ul>
<li>每个 Java 对象都有一个与之关联的<strong>监视器（Monitor）</strong>，由 JVM 维护。</li>
<li>当线程进入 <code>synchronized</code> 块或方法时，它会尝试获取对象的监视器锁：<ul>
<li>如果锁未被占用，则线程获得锁并继续执行；</li>
<li>如果锁已被其他线程持有，则当前线程进入阻塞状态，直到锁被释放。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="五、优缺点对比"><a href="#五、优缺点对比" class="headerlink" title="五、优缺点对比"></a>五、优缺点对比</h2><table>
<thead>
<tr>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>使用简单</td>
<td>✔️ 语法简洁，易于理解</td>
<td>❌ 粒度大，容易影响性能</td>
</tr>
<tr>
<td>可重入</td>
<td>✔️ 支持同一线程多次进入</td>
<td></td>
</tr>
<tr>
<td>自动释放锁</td>
<td>✔️ 进入和退出自动管理</td>
<td></td>
</tr>
<tr>
<td>无法尝试锁</td>
<td>❌ 不能尝试获取锁而不阻塞</td>
<td></td>
</tr>
<tr>
<td>无法超时</td>
<td>❌ 不支持超时机制</td>
<td></td>
</tr>
<tr>
<td>无法中断</td>
<td>❌ 获取锁过程中不能被中断</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="六、替代方案"><a href="#六、替代方案" class="headerlink" title="六、替代方案"></a>六、替代方案</h2><p>从 Java 5 开始，<code>java.util.concurrent.locks</code> 包提供了更强大的锁机制，如：</p>
<ul>
<li><code>ReentrantLock</code></li>
<li><code>ReadWriteLock</code></li>
<li><code>Condition</code></li>
</ul>
<p>这些锁提供了更多功能，比如尝试锁（<code>tryLock()</code>）、超时、可中断等，适用于更复杂的并发场景。</p>
<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>synchronized</code> 是 Java 中最基础的线程同步机制，适合简单的并发控制场景。但在高并发或需要高级功能（如尝试锁、超时、读写分离）时，推荐使用 <code>ReentrantLock</code> 或其他并发工具类。</p>
<h3 id="syn-ed"><a href="#syn-ed" class="headerlink" title="syn-ed"></a>syn-ed</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p>
<p>synchronized 是可重入、不公平的重量级锁</p>
<p>原则上：</p>
<ul>
<li>锁对象建议使用共享资源</li>
<li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li>
<li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li>
</ul>
<p>同步代码块格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">	<span class="comment">// 访问共享资源的核心代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p>
<p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p>
<p>用法：直接给方法加上一个修饰符 synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法底层也是有锁对象的：</p>
<ul>
<li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<h2 id="✅-synchronized-锁对象的写法"><a href="#✅-synchronized-锁对象的写法" class="headerlink" title="✅ synchronized 锁对象的写法"></a>✅ synchronized 锁对象的写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="comment">// 只有持有 lock 对象的线程可以执行这段代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们创建了一个私有的、final 的对象 <code>lock</code>，专门用于加锁。</li>
<li>使用这种方式的好处是：<strong>不干扰其他无关同步操作</strong>，并且可以精确地控制锁的粒度。</li>
</ul>
<hr>
<h2 id="🧠-为什么推荐使用一个专用的对象来加锁？"><a href="#🧠-为什么推荐使用一个专用的对象来加锁？" class="headerlink" title="🧠 为什么推荐使用一个专用的对象来加锁？"></a>🧠 为什么推荐使用一个专用的对象来加锁？</h2><h3 id="❗-不建议这样写："><a href="#❗-不建议这样写：" class="headerlink" title="❗ 不建议这样写："></a>❗ 不建议这样写：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然语法上没问题，但存在潜在问题：</p>
<ul>
<li>如果这个类被其他模块继承或扩展，外部可能也在用 <code>this</code> 加锁，造成<strong>锁冲突</strong>。</li>
<li>容易引起<strong>锁竞争</strong>，降低并发性能。</li>
<li>粒度过大，影响程序效率。</li>
</ul>
<h3 id="✅-推荐做法："><a href="#✅-推荐做法：" class="headerlink" title="✅ 推荐做法："></a>✅ 推荐做法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更安全：不会与其他同步代码块产生冲突。</li>
<li>更灵活：可以为不同的资源定义不同的锁对象。</li>
<li>更高效：减小锁的粒度，提升并发性能。</li>
</ul>
<hr>
<h2 id="📌-实际应用场景举例"><a href="#📌-实际应用场景举例" class="headerlink" title="📌 实际应用场景举例"></a>📌 实际应用场景举例</h2><h3 id="场景1：保护共享变量"><a href="#场景1：保护共享变量" class="headerlink" title="场景1：保护共享变量"></a>场景1：保护共享变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目的：确保多个线程对 <code>count</code> 的访问是同步的。</p>
</blockquote>
<hr>
<h3 id="场景2：多资源同步控制"><a href="#场景2：多资源同步控制" class="headerlink" title="场景2：多资源同步控制"></a>场景2：多资源同步控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resourceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resourceB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useResourceA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">        <span class="comment">// 使用资源 A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useResourceB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">        <span class="comment">// 使用资源 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目的：不同资源使用不同的锁，互不影响。</p>
</blockquote>
<hr>
<h3 id="场景3：防止类级别的同步污染"><a href="#场景3：防止类级别的同步污染" class="headerlink" title="场景3：防止类级别的同步污染"></a>场景3：防止类级别的同步污染</h3><p>如果你有一个工具类，里面有些方法需要同步，但你不想影响整个类或对象实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 只同步关键部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔍-总结：锁对象的使用是否常见？"><a href="#🔍-总结：锁对象的使用是否常见？" class="headerlink" title="🔍 总结：锁对象的使用是否常见？"></a>🔍 总结：锁对象的使用是否常见？</h2><table>
<thead>
<tr>
<th>项目</th>
<th>是否推荐</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>锁住 <code>this</code></td>
<td>⚠️ 不推荐</td>
<td>容易引发锁冲突和不必要的锁竞争</td>
</tr>
<tr>
<td>锁住专用对象（如 <code>new Object()</code>）</td>
<td>✅ 非常推荐</td>
<td>控制粒度精细、安全性高、灵活性强</td>
</tr>
<tr>
<td>锁住类的 Class 对象（如 <code>MyClass.class</code>）</td>
<td>✅ 视情况而定</td>
<td>多用于静态方法同步</td>
</tr>
</tbody></table>
<hr>
<p>✅ 所以结论是：<strong>使用 <code>synchronized</code> 锁一个专门的 Object 对象是非常常见且推荐的做法</strong>，尤其在需要更细粒度控制并发行为时。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在 Java 中，每个对象都有一个与之关联的<strong>对象头（Object Header）</strong>，这是 JVM 为了实现某些特性（如锁机制、垃圾回收等）而添加的一些元数据。对于同步机制来说，尤其是 <code>synchronized</code> 关键字所依赖的监视器锁（Monitor），对象头中的信息尤为重要。</p>
<h3 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h3><p>Java 对象头主要包括两部分：<strong>Mark Word</strong> 和 <strong>Class Pointer</strong>。此外，在某些情况下还可能包括数组长度等额外信息。</p>
<ol>
<li><p><strong>Mark Word</strong>: 这是对象头中最重要的部分，用于存储对象的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。它的大小因 JVM 实现和平台的不同而异，通常为32位或64位。</p>
</li>
<li><p><strong>Class Pointer</strong>: 指向该对象对应的类（Class）在方法区中的地址。通过这个指针可以访问到对象的类型信息以及方法表等重要数据。</p>
</li>
</ol>
<h3 id="Mark-Word-的作用"><a href="#Mark-Word-的作用" class="headerlink" title="Mark Word 的作用"></a>Mark Word 的作用</h3><p>Mark Word 是一个非常重要的概念，它根据对象的状态复用不同的字段来节省空间。在支持偏向锁、轻量级锁、重量级锁的JVM中，Mark Word 可能会包含以下几种信息：</p>
<ul>
<li><strong>无锁状态</strong>：存储对象的哈希值、GC年龄等。</li>
<li><strong>偏向锁状态</strong>：存储偏向线程ID、偏向时间戳等信息。</li>
<li><strong>轻量级锁状态</strong>：指向栈中锁记录的指针。</li>
<li><strong>重量级锁状态</strong>：指向 Monitor 对象的指针。</li>
</ul>
<h3 id="Monitor-锁"><a href="#Monitor-锁" class="headerlink" title="Monitor 锁"></a>Monitor 锁</h3><p>Monitor 是一种同步机制，它提供了比简单锁定更复杂的语义。每个 Java 对象都可以作为一个 Monitor 来使用，这也是为什么我们说 <code>synchronized</code> 使用的是对象级别的锁。Monitor 主要由以下几个部分组成：</p>
<ul>
<li><strong>Entry Set</strong>：等待获取锁的所有线程队列。</li>
<li><strong>Wait Set</strong>：调用了 <code>wait()</code> 方法后进入等待状态的线程集合。</li>
<li><strong>Owner</strong>：当前持有锁的线程。</li>
</ul>
<p>当一个线程尝试进入 <code>synchronized</code> 方法或代码块时，如果此时没有其他线程占有该锁，则该线程可以获得锁并继续执行；否则，该线程将被放入 Entry Set 等待锁释放。类似地，当调用 <code>wait()</code> 方法时，线程会被移动到 Wait Set 直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p>
<h3 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h3><p>为了提高性能，现代 JVM 提供了从偏向锁到轻量级锁再到重量级锁的锁升级机制：</p>
<ol>
<li><strong>偏向锁</strong>：假设基本上不存在竞争，因此只需要简单的检查是否有别的线程尝试获取过这个锁即可。</li>
<li><strong>轻量级锁</strong>：当有轻微的竞争出现时，采用 CAS（Compare And Swap）操作尝试获取锁。</li>
<li><strong>重量级锁</strong>：当竞争加剧时，升级为真正的操作系统层面的互斥锁，涉及到上下文切换等开销较大的操作。</li>
</ol>
<p>这种逐步升级的设计旨在优化多线程环境下的性能表现，使得大多数情况下无需付出高昂的代价就能完成同步操作。</p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p>
<ul>
<li><p>Mark Word 结构：最后两位是<strong>锁标志位</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"></p>
</li>
<li><p>64 位虚拟机 Mark Word：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"></p>
</li>
</ul>
<p>工作流程：</p>
<ul>
<li>开始时 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor工作原理1.png" style="zoom:67%;" /></li>
<li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</li>
<li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li>
<li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li>
<li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
<p>在 Java 中，为了优化同步机制的性能，JVM 实现了锁升级的概念。锁升级是从偏向锁到轻量级锁再到重量级锁的过程。这个过程旨在减少线程间的竞争和上下文切换，从而提高程序的整体性能。以下是锁升级的具体过程及其解释：</p>
<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><h3 id="1-偏向锁（Biased-Locking）"><a href="#1-偏向锁（Biased-Locking）" class="headerlink" title="1. 偏向锁（Biased Locking）"></a>1. 偏向锁（Biased Locking）</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>减少无竞争情况下的同步开销。</li>
<li>如果一个线程获得了锁，并且之后没有其他线程尝试获取该锁，则该锁会保持偏向状态。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>当一个线程第一次访问同步代码块或方法时，JVM 会在对象头的 Mark Word 中记录该线程的 ID 和偏向时间戳。</li>
<li>如果后续该线程再次请求同一个锁，JVM 只需检查对象头中的线程 ID 是否与当前线程匹配，而无需执行任何 CAS 操作或其他复杂的同步操作。</li>
<li>如果另一个线程尝试获取偏向锁，那么 JVM 会撤销偏向锁，并将锁升级为轻量级锁。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>高效</strong>：对于只有一个线程访问共享资源的情况非常高效。</li>
<li><strong>低开销</strong>：几乎不产生额外的开销，因为不需要原子操作来保证同步。</li>
</ul>
<h3 id="2-轻量级锁（Lightweight-Locking）"><a href="#2-轻量级锁（Lightweight-Locking）" class="headerlink" title="2. 轻量级锁（Lightweight Locking）"></a>2. 轻量级锁（Lightweight Locking）</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ul>
<li>在有少量线程竞争的情况下，提供一种比重量级锁更高效的同步方式。</li>
<li>避免使用操作系统级别的互斥量，减少线程阻塞和唤醒带来的开销。</li>
</ul>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>当一个线程尝试获取一个已经被其他线程持有的偏向锁时，JVM 会撤销偏向锁，并将锁升级为轻量级锁。</li>
<li>轻量级锁通过比较并交换（CAS）操作来尝试获得锁。如果成功，则直接进入临界区；如果失败，则表示存在竞争，需要继续尝试或者等待。</li>
<li>每个持有轻量级锁的线程都会在其栈帧中创建一个锁记录（Lock Record），并将对象头的 Mark Word 复制到这个锁记录中。</li>
<li>如果锁竞争加剧，即多个线程频繁地争夺同一个锁，JVM 会将锁升级为重量级锁。</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>适用于低到中等程度的竞争</strong>：当只有少数几个线程试图同时访问同一资源时，轻量级锁表现良好。</li>
<li><strong>较低的上下文切换开销</strong>：相比重量级锁，减少了线程阻塞和唤醒的次数。</li>
</ul>
<h3 id="3-重量级锁（Heavyweight-Locking）"><a href="#3-重量级锁（Heavyweight-Locking）" class="headerlink" title="3. 重量级锁（Heavyweight Locking）"></a>3. 重量级锁（Heavyweight Locking）</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ul>
<li>处理高竞争场景，确保只有一个线程能够访问共享资源，其他线程必须等待直到锁被释放。</li>
<li>使用操作系统的互斥量实现，允许线程进入等待状态以节省 CPU 资源。</li>
</ul>
<h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li>当轻量级锁无法满足需求，即多个线程频繁争用同一个锁时，JVM 会将锁升级为重量级锁。</li>
<li>在重量级锁状态下，所有未获得锁的线程都将被放入 Entry Set 等待队列中，直到当前持有锁的线程释放锁为止。</li>
<li>重量级锁涉及到操作系统层面的调度，可能会导致线程的挂起和恢复，这会导致较高的上下文切换开销。</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>适用于高竞争场景</strong>：当多个线程频繁争夺同一个锁时，重量级锁可以保证数据的一致性和完整性。</li>
<li><strong>较高的开销</strong>：由于涉及到操作系统级别的互斥量，因此会有较大的开销。</li>
</ul>
<h3 id="锁升级流程图解"><a href="#锁升级流程图解" class="headerlink" title="锁升级流程图解"></a>锁升级流程图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏向锁 (单线程访问) -&gt; [遇到竞争] -&gt; 轻量级锁 (少量线程竞争) -&gt; [竞争加剧] -&gt; 重量级锁 (多线程竞争)</span><br></pre></td></tr></table></figure>



<p>好的，我们来深入讲解一下与对象关联的 <strong><code>Lock Record</code>（锁记录）</strong>。这是理解 Java 轻量级锁和偏向锁升级机制的核心概念之一。</p>
<hr>
<h3 id="1-什么是-Lock-Record？"><a href="#1-什么是-Lock-Record？" class="headerlink" title="1. 什么是 Lock Record？"></a>1. 什么是 Lock Record？</h3><ul>
<li><strong>定义：</strong> <code>Lock Record</code>（有时也称为 <code>BasicObjectLock</code> 或 <code>Lock Stack</code> 中的帧）是 JVM 在<strong>线程的 Java 调用栈（Java Stack）</strong> 上分配的一小块内存区域。</li>
<li><strong>目的：</strong> 它是 JVM 实现<strong>轻量级锁</strong>和<strong>偏向锁撤销后升级</strong>的关键数据结构。它主要用于在对象头（<code>Mark Word</code>）被修改时，<strong>保存对象头的原始状态（即 <code>Mark Word</code> 的副本）</strong>。</li>
<li><strong>位置：</strong> 它位于<strong>获取锁的线程的栈帧</strong>中，是线程私有的。这意味着每个尝试获取锁的线程，如果成功进入轻量级锁或以上状态，都会在自己的栈上拥有一个或多个 <code>Lock Record</code>。</li>
</ul>
<hr>
<h3 id="2-Lock-Record-的结构"><a href="#2-Lock-Record-的结构" class="headerlink" title="2. Lock Record 的结构"></a>2. Lock Record 的结构</h3><p>一个典型的 <code>Lock Record</code> 主要包含两个部分：</p>
<ol>
<li><p><strong>Displaced Mark Word (被置换的 Mark Word):</strong></p>
<ul>
<li>这是 <code>Lock Record</code> 中最重要的部分。</li>
<li>它存储了在加锁操作<strong>之前</strong>，对象头中 <code>Mark Word</code> 的<strong>完整内容</strong>。</li>
<li>例如，如果对象之前处于无锁状态，<code>Displaced Mark Word</code> 就保存了包含哈希码、分代年龄、无锁标志等信息的完整 <code>Mark Word</code>。</li>
<li>如果对象之前是偏向锁状态，<code>Displaced Mark Word</code> 会保存偏向锁模式下的 <code>Mark Word</code>（包含偏向线程 ID、时间戳等）。</li>
</ul>
</li>
<li><p><strong>Owner (所有者) 指针 (可选&#x2F;实现相关):</strong></p>
<ul>
<li>在某些 JVM 实现或调试信息中，<code>Lock Record</code> 可能还会包含一个指向其所关联对象的指针（<code>owner</code>），但这并非所有实现都显式包含，因为关联关系通常通过其他方式维护。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-Lock-Record-在锁升级过程中的作用"><a href="#3-Lock-Record-在锁升级过程中的作用" class="headerlink" title="3. Lock Record 在锁升级过程中的作用"></a>3. Lock Record 在锁升级过程中的作用</h3><p><code>Lock Record</code> 主要在<strong>轻量级锁</strong>的获取和释放过程中扮演核心角色。</p>
<h4 id="场景：线程-T1-尝试获取轻量级锁"><a href="#场景：线程-T1-尝试获取轻量级锁" class="headerlink" title="场景：线程 T1 尝试获取轻量级锁"></a><strong>场景：线程 T1 尝试获取轻量级锁</strong></h4><ol>
<li><strong>前提：</strong> 对象当前处于<strong>无锁状态</strong>（或偏向锁已被撤销）。</li>
<li><strong>创建 Lock Record：</strong> T1 在自己的栈帧中分配一个 <code>Lock Record</code>。</li>
<li><strong>复制 Mark Word：</strong> T1 将对象当前的 <code>Mark Word</code> <strong>复制</strong>到这个新创建的 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 字段中。</li>
<li><strong>CAS 替换：</strong> T1 使用 CAS 操作，试图将对象头的 <code>Mark Word</code> <strong>替换</strong>为一个<strong>指向自己栈中这个 <code>Lock Record</code> 的指针</strong>。<ul>
<li><strong>成功：</strong> 说明没有竞争，T1 获得了轻量级锁。此时，对象头的 <code>Mark Word</code> 指向了 T1 栈中的 <code>Lock Record</code>。T1 进入临界区。</li>
<li><strong>失败：</strong> 说明有竞争（另一个线程也在尝试获取），T1 会进行自旋等待或升级为重量级锁。</li>
</ul>
</li>
</ol>
<h4 id="场景：线程-T1-释放轻量级锁"><a href="#场景：线程-T1-释放轻量级锁" class="headerlink" title="场景：线程 T1 释放轻量级锁"></a><strong>场景：线程 T1 释放轻量级锁</strong></h4><ol>
<li><strong>准备：</strong> T1 退出同步块，准备释放锁。</li>
<li><strong>CAS 恢复：</strong> T1 使用 CAS 操作，试图将 <code>Lock Record</code> 中的 <code>Displaced Mark Word</code> <strong>交换回</strong>对象头的 <code>Mark Word</code> 中。</li>
<li><strong>成功：</strong> 说明在此期间没有其他线程成功修改过对象头（即没有发生竞争），解锁成功。对象恢复到无锁状态。</li>
<li><strong>失败：</strong> 说明有其他线程可能已经将锁升级为重量级锁（此时对象头的 <code>Mark Word</code> 可能已经指向一个 <code>Monitor</code> 对象），T1 不能简单地恢复 <code>Mark Word</code>，需要通过更复杂的重量级锁释放流程来处理。</li>
</ol>
<hr>
<h3 id="4-Lock-Record-与偏向锁的关系"><a href="#4-Lock-Record-与偏向锁的关系" class="headerlink" title="4. Lock Record 与偏向锁的关系"></a>4. Lock Record 与偏向锁的关系</h3><ul>
<li><strong>偏向锁本身不直接使用 Lock Record。</strong> 在偏向锁状态下，线程通过检查对象头的 <code>Mark Word</code> 中的线程 ID 来判断是否可以无开销地进入临界区，不需要在栈上创建 <code>Lock Record</code>。</li>
<li><strong>但偏向锁撤销后，会用到 Lock Record：</strong><ul>
<li>当发生竞争，需要撤销偏向锁并升级时，JVM 会在安全点检查持有偏向锁的线程（T1）的栈。</li>
<li>如果发现 T1 仍然“持有”这个锁（即 T1 的栈中有一个 <code>Lock Record</code>，其 <code>Displaced Mark Word</code> 指向了该对象），这说明 T1 还没有释放锁。</li>
<li>此时，JVM 会<strong>强制 T1 将其持有的偏向锁转换为轻量级锁</strong>。这个转换过程就涉及到 T1 创建或利用已有的 <code>Lock Record</code>，并将对象头的 <code>Mark Word</code> 从偏向模式修改为指向这个 <code>Lock Record</code> 的指针。</li>
<li>简单说，<code>Lock Record</code> 是偏向锁<strong>升级为轻量级锁</strong>过程中的“桥梁”和“容器”。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-为什么-Lock-Record-放在栈上？"><a href="#5-为什么-Lock-Record-放在栈上？" class="headerlink" title="5. 为什么 Lock Record 放在栈上？"></a>5. 为什么 Lock Record 放在栈上？</h3><ul>
<li><strong>线程私有：</strong> 栈是线程私有的，因此 <code>Lock Record</code> 天然是线程私有的，避免了多线程访问 <code>Lock Record</code> 本身的同步开销。</li>
<li><strong>生命周期匹配：</strong> <code>Lock Record</code> 的生命周期通常与获取锁的代码块（方法调用）的栈帧生命周期一致。当方法执行完毕，栈帧被弹出，<code>Lock Record</code> 也随之自动销毁，无需额外的内存管理。</li>
<li><strong>快速访问：</strong> CPU 访问线程栈上的数据非常快，这有助于减少轻量级锁的开销。</li>
</ul>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li><code>Lock Record</code> 是 JVM 在<strong>线程栈上</strong>分配的一块内存。</li>
<li>它的核心作用是<strong>保存对象头 <code>Mark Word</code> 的副本</strong>（<code>Displaced Mark Word</code>）。</li>
<li>它是实现<strong>轻量级锁</strong>的基础：通过 CAS 操作将对象头的 <code>Mark Word</code> 替换为指向 <code>Lock Record</code> 的指针来“标记”锁的持有者，并在解锁时尝试将 <code>Displaced Mark Word</code> 恢复回去。</li>
<li>它在<strong>偏向锁升级</strong>过程中扮演关键角色，是将偏向锁状态转换为轻量级锁状态的“容器”。</li>
<li>它的存在使得轻量级锁可以在不涉及操作系统互斥量（Mutex）的情况下，通过 CAS 和自旋来高效地处理短暂的线程竞争。</li>
</ul>
<p>理解 <code>Lock Record</code> 是理解 Java 对象头、Mark Word 以及锁升级（无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁）完整链条的关键一环。</p>
<p><strong>核心答案：轻量级锁的 Mark Word 信息是存储在 <em>锁记录（Lock Record）</em> 中，而不是“存储在 maxword 里面”。</strong> “maxword” 应该是 “Mark Word” 的笔误。</p>
<p>让我们详细梳理一下轻量级锁的机制和 Mark Word 的作用：</p>
<ol>
<li><p><strong>Mark Word 是什么？</strong></p>
<ul>
<li><code>Mark Word</code> 是 Java 对象头（Object Header）的一部分，它是一个存储对象运行时元数据的内存区域。</li>
<li>这些元数据包括：哈希码（HashCode）、对象的分代年龄（GC Age）、锁状态标志（锁的类型：无锁、偏向锁、轻量级锁、重量级锁）、偏向线程ID、指向锁记录或互斥量的指针等。</li>
<li><code>Mark Word</code> 的内容会根据对象的锁状态和 JVM 的运行状态动态变化。</li>
</ul>
</li>
<li><p><strong>轻量级锁的加锁过程与 Mark Word 的关系：</strong></p>
<ul>
<li>当一个线程尝试获取一个处于<strong>无锁或偏向锁（但能成功撤销）</strong> 状态的对象锁时，JVM 会尝试将其升级为轻量级锁。</li>
<li><strong>关键步骤：</strong><ol>
<li><strong>创建锁记录 (Lock Record)：</strong> 该线程会在自己的<strong>栈帧</strong>中分配一块空间，称为“锁记录”（Lock Record）。</li>
<li><strong>复制 Mark Word：</strong> 线程将对象当前的 <code>Mark Word</code> <strong>复制</strong>到这个锁记录中。这个被复制的 <code>Mark Word</code> 被称为“Displaced Mark Word”（被置换的 Mark Word）。</li>
<li><strong>CAS 替换：</strong> 线程使用 CAS (Compare and Swap) 操作，试图将对象头中的 <code>Mark Word</code> <strong>替换</strong>为一个指向自己栈帧中这个锁记录的指针。</li>
<li><strong>成功与失败：</strong><ul>
<li><strong>成功：</strong> 如果 CAS 成功，说明没有其他线程竞争这个锁，该线程获得了轻量级锁，可以进入临界区执行。此时，对象头的 <code>Mark Word</code> 指向了线程栈中的锁记录。</li>
<li><strong>失败：</strong> 如果 CAS 失败，说明有其他线程也在尝试获取锁（竞争发生）。当前线程会进行自旋（Spin），尝试再次 CAS，或者在自旋一定次数后，将锁<strong>膨胀</strong>为重量级锁。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>为什么说“轻量级锁不会存储在 Mark Word 里面”是误解？</strong></p>
<ul>
<li>这个说法本身是<strong>不准确</strong>的。更准确的说法是：<strong>轻量级锁的状态信息是通过 <code>Mark Word</code> 来体现和管理的。</strong></li>
<li>在轻量级锁状态下，<code>Mark Word</code> 的<strong>内容</strong>发生了改变：它不再直接包含哈希码、年龄等信息，而是<strong>存储了一个指向栈中锁记录的指针</strong>。同时，锁记录中保存了原始的 <code>Mark Word</code>（Displaced Mark Word）。</li>
<li>所以，<code>Mark Word</code> 是轻量级锁机制中<strong>核心的、动态变化的部分</strong>，它指向了锁的持有者（线程栈中的锁记录），而不是“不存储”轻量级锁。</li>
</ul>
</li>
<li><p><strong>轻量级锁的解锁过程：</strong></p>
<ul>
<li>当线程退出同步块时，需要释放轻量级锁。</li>
<li>它会使用 CAS 操作，试图将锁记录中的 <code>Displaced Mark Word</code> <strong>交换回</strong>对象头的 <code>Mark Word</code> 中。</li>
<li>如果 CAS 成功，说明在此期间没有其他线程尝试获取过这个锁（没有竞争），解锁完成，对象恢复到无锁状态。</li>
<li>如果 CAS 失败，说明在持有锁期间已经有其他线程尝试过获取锁（可能已经膨胀为重量级锁），此时需要在释放锁后，由 JVM 进行后续的重量级锁释放操作。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li><strong>轻量级锁的“信息”是存储在 <code>Mark Word</code> 和 <code>Lock Record</code> 共同构成的结构中的。</strong></li>
<li><code>Mark Word</code> 在轻量级锁状态下，其值是一个<strong>指向栈中锁记录的指针</strong>。</li>
<li><code>Lock Record</code> 中存储了原始的 <code>Mark Word</code>（Displaced Mark Word）。</li>
<li>因此，<code>Mark Word</code> 是轻量级锁机制中不可或缺的一部分，它用于标识锁的状态和指向锁记录，而不是“不存储”轻量级锁。</li>
</ul>
<p>所以，正确的理解是：轻量级锁利用 <code>Mark Word</code> 的指针指向线程栈中的 <code>Lock Record</code>，而 <code>Lock Record</code> 保存了原始的 <code>Mark Word</code> 内容。</p>
<p>你提出了一个非常精准且关键的问题！这涉及到对 <code>synchronized</code> 底层实现中“<strong>Monitor 到底是什么</strong>”以及“<strong>对象头（Mark Word）如何演变</strong>”的深刻理解。你的直觉是对的，但需要澄清一个常见的误解。</p>
<p>让我们一步步拆解：</p>
<hr>
<h3 id="核心答案："><a href="#核心答案：" class="headerlink" title="核心答案："></a><strong>核心答案：</strong></h3><ol>
<li><strong><code>synchronized(对象A)</code> 中的 <code>对象A</code> 本身 <em>不是</em> Monitor 对象。</strong> <code>对象A</code> 是<strong>被同步的对象</strong>，它的<strong>对象头（Object Header）</strong> 被用来存储锁状态信息。</li>
<li><strong>Monitor (<code>ObjectMonitor</code>) 是一个独立的、由 JVM 管理的 C++ 对象。</strong> 它通常不位于 Java 堆上（或位于一个特殊的区域），是重量级锁的“执行引擎”。</li>
<li><strong>在轻量级锁阶段，操作的是 <code>对象A</code> 的 <code>Mark Word</code>。</strong> 没有额外的 Monitor 对象被创建。</li>
<li><strong>只有当锁升级为重量级锁时，才会分配一个独立的 <code>ObjectMonitor</code> 对象，并将 <code>对象A</code> 的 <code>Mark Word</code> 指向这个 <code>ObjectMonitor</code>。</strong></li>
</ol>
<hr>
<h3 id="详细解析：锁的演变过程与-Mark-Word-的变化"><a href="#详细解析：锁的演变过程与-Mark-Word-的变化" class="headerlink" title="详细解析：锁的演变过程与 Mark Word 的变化"></a><strong>详细解析：锁的演变过程与 Mark Word 的变化</strong></h3><p>假设我们有一个 Java 对象 <code>A</code>，并执行 <code>synchronized(A)</code>。</p>
<h4 id="阶段-1-无锁-Normal"><a href="#阶段-1-无锁-Normal" class="headerlink" title="阶段 1: 无锁 (Normal)"></a><strong>阶段 1: 无锁 (Normal)</strong></h4><ul>
<li><strong>状态：</strong> <code>对象A</code> 尚未被任何线程同步。</li>
<li><strong>Mark Word 内容：</strong> 存储对象的哈希码、分代年龄、GC 信息等，锁状态标志为“无锁”。</li>
<li><strong>Monitor：</strong> 不存在。<code>对象A</code> 和任何 <code>ObjectMonitor</code> 都没有关联。</li>
</ul>
<h4 id="阶段-2-偏向锁-Biased-Locking"><a href="#阶段-2-偏向锁-Biased-Locking" class="headerlink" title="阶段 2: 偏向锁 (Biased Locking)"></a><strong>阶段 2: 偏向锁 (Biased Locking)</strong></h4><ul>
<li><strong>触发：</strong> 线程 T1 第一次进入 <code>synchronized(A)</code>。</li>
<li><strong>操作：</strong> JVM 修改 <code>对象A</code> 的 <code>Mark Word</code>。</li>
<li><strong>Mark Word 内容：</strong> 被设置为“偏向模式”，并记录下 T1 的线程 ID 和一个时间戳。<strong>仍然没有创建 <code>ObjectMonitor</code>。</strong></li>
<li><strong>原理：</strong> T1 再次进入时，只需检查 <code>Mark Word</code> 的线程 ID 是否是自己，无需任何同步操作。</li>
<li><strong>Monitor：</strong> 不存在。</li>
</ul>
<h4 id="阶段-3-轻量级锁-Lightweight-Locking"><a href="#阶段-3-轻量级锁-Lightweight-Locking" class="headerlink" title="阶段 3: 轻量级锁 (Lightweight Locking)"></a><strong>阶段 3: 轻量级锁 (Lightweight Locking)</strong></h4><ul>
<li><strong>触发：</strong> 线程 T2 尝试进入 <code>synchronized(A)</code>，但发现 <code>对象A</code> 已被 T1 偏向。</li>
<li><strong>操作：</strong><ol>
<li><strong>撤销偏向：</strong> 在安全点，JVM 撤销 T1 的偏向锁，将 <code>对象A</code> 的 <code>Mark Word</code> 恢复到可偏向但未偏向的状态。</li>
<li><strong>T1 获取轻量级锁：</strong> T1（或在撤销后重新竞争）在自己的<strong>栈帧</strong>中创建一个 <code>Lock Record</code>。</li>
<li><strong>复制 Mark Word：</strong> T1 将 <code>对象A</code> 当前的 <code>Mark Word</code>（撤销后的值）复制到自己的 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 字段中。</li>
<li><strong>CAS 替换：</strong> T1 使用 CAS 操作，将 <code>对象A</code> 的 <code>Mark Word</code> 替换为<strong>指向自己栈中 <code>Lock Record</code> 的指针</strong>。</li>
</ol>
</li>
<li><strong>Mark Word 内容：</strong> 现在 <code>对象A</code> 的 <code>Mark Word</code> 存储的是一个指向<strong>T1 栈中 <code>Lock Record</code> 的指针</strong>，锁状态标志为“轻量级锁”。</li>
<li><strong>Monitor：</strong> <strong>仍然不存在！</strong> 这是关键点。轻量级锁完全依赖 <code>对象A</code> 自身的 <code>Mark Word</code> 和线程栈上的 <code>Lock Record</code> 来实现，没有引入额外的 <code>ObjectMonitor</code> 对象。</li>
</ul>
<h4 id="阶段-4-重量级锁-Heavyweight-Locking-Inflation"><a href="#阶段-4-重量级锁-Heavyweight-Locking-Inflation" class="headerlink" title="阶段 4: 重量级锁 (Heavyweight Locking &#x2F; Inflation)"></a><strong>阶段 4: 重量级锁 (Heavyweight Locking &#x2F; Inflation)</strong></h4><ul>
<li><strong>触发：</strong> T2 发现自旋次数过多，决定将锁升级。</li>
<li><strong>操作：</strong><ol>
<li><strong>分配 Monitor：</strong> JVM 从 <code>Monitor</code> 缓存池或堆外内存中<strong>分配一个全新的 <code>ObjectMonitor</code> 对象</strong>（我们称之为 <code>M1</code>）。</li>
<li><strong>修改对象A的 Mark Word：</strong> T2 使用 CAS 操作，将 <code>对象A</code> 的 <code>Mark Word</code> 从“指向 T1 的 <code>Lock Record</code>”替换为“<strong>指向 <code>M1</code> 的指针</strong>”。锁状态标志变为“重量级锁”。</li>
<li><strong>初始化 Monitor：</strong> 设置 <code>M1.owner = T1</code>（因为 T1 才是当前持有者），<code>M1.recursions = 1</code>。</li>
<li><strong>T2 进入阻塞：</strong> T2 将自己放入 <code>M1.EntryList</code> 并调用操作系统原语将自己阻塞。</li>
</ol>
</li>
<li><strong>Mark Word 内容：</strong> <code>对象A</code> 的 <code>Mark Word</code> 现在存储的是一个指向<strong>独立 <code>ObjectMonitor</code> 对象 <code>M1</code> 的指针</strong>。</li>
<li><strong>Monitor：</strong> <strong>现在才创建！</strong> <code>ObjectMonitor</code> <code>M1</code> 是一个独立的、重量级的同步控制器。</li>
</ul>
<hr>
<h3 id="回答你的具体问题"><a href="#回答你的具体问题" class="headerlink" title="回答你的具体问题"></a><strong>回答你的具体问题</strong></h3><blockquote>
<p><strong>“比如我直接执行 synchronized(对象A) 不是直接把对象A作为 Monitor 对象吗”</strong></p>
</blockquote>
<ul>
<li><strong>不完全是。</strong> <code>对象A</code> 是<strong>被同步的实体</strong>，它的<strong>对象头（特别是 <code>Mark Word</code>）</strong> 是锁状态的“门面”和“指针”。</li>
<li>在偏向锁和轻量级锁阶段，<code>对象A</code> 通过其 <code>Mark Word</code> 直接管理锁状态（存储线程ID或指向 <code>Lock Record</code>）。</li>
<li>在重量级锁阶段，<code>对象A</code> 的 <code>Mark Word</code> <strong>不再直接管理锁</strong>，而是变成了一个“<strong>指向真正锁管理者（<code>ObjectMonitor</code>）的指针</strong>”。<code>对象A</code> 就像一个“门牌号”，告诉你真正的“锁办公室”（<code>ObjectMonitor</code>）在哪里。</li>
</ul>
<blockquote>
<p><strong>“在轻量级锁中，用的markword是哪个对象的？是这个A对象吗”</strong></p>
</blockquote>
<ul>
<li><strong>是的！</strong> 在轻量级锁阶段，<strong>操作的就是 <code>对象A</code> 自身的 <code>Mark Word</code></strong>。</li>
<li>具体来说，就是将 <code>对象A</code> 的 <code>Mark Word</code> 从存储哈希码等信息，改为存储一个指向<strong>获取锁的线程（T1）的栈帧中 <code>Lock Record</code> 的指针</strong>。</li>
<li>这个 <code>Lock Record</code> 里保存了 <code>对象A</code> <code>Mark Word</code> 的“快照”（Displaced Mark Word）。</li>
</ul>
<hr>
<h3 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a><strong>类比理解</strong></h3><p>想象 <code>对象A</code> 是一栋房子：</p>
<ul>
<li><strong>无锁：</strong> 房子没人管，门上贴着房子的编号和基本信息（<code>Mark Word</code> 的初始内容）。</li>
<li><strong>偏向锁：</strong> 房子给了张三（T1）一把专属钥匙，门上写着“此房偏向张三”（<code>Mark Word</code> 记录 T1 ID）。</li>
<li><strong>轻量级锁：</strong> 李四（T2）也想进。张三把门锁了，把钥匙（房子的“快照”信息）放进自己口袋（<code>Lock Record</code>），门上贴了张纸条：“钥匙在张三口袋里”（<code>Mark Word</code> 指向 <code>Lock Record</code>）。李四在门外轻轻敲门（自旋）等张三出来。</li>
<li><strong>重量级锁：</strong> 李四等烦了，叫来了物业（JVM）。物业在小区门口建了一个<strong>独立的门卫室</strong>（<code>ObjectMonitor M1</code>），把房子的正式钥匙挂在门卫室墙上。门卫室墙上写着：“此房钥匙在此，持有者：张三”（<code>M1.owner = T1</code>）。房子原来的门上贴了新的纸条：“此房的门卫室在X栋Y号”（<code>对象A</code> 的 <code>Mark Word</code> 指向 <code>M1</code>）。李四去门卫室登记，坐在椅子上等着（阻塞在 <code>EntryList</code>），不再敲门。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>对象A</code> 的 <code>Mark Word</code> 是锁状态的“<strong>指示器</strong>”。</li>
<li>在<strong>偏向锁和轻量级锁</strong>阶段，<code>Mark Word</code> <strong>直接存储锁信息</strong>（线程ID 或 指向栈上 <code>Lock Record</code> 的指针）。</li>
<li>在<strong>重量级锁</strong>阶段，<code>Mark Word</code> <strong>存储一个指向独立 <code>ObjectMonitor</code> 对象的指针</strong>。</li>
<li><code>ObjectMonitor</code> 是一个<strong>独立于 Java 对象</strong>的、由 JVM 管理的 C++ 对象，是重量级锁的“大脑”和“队列管理者”。</li>
<li>因此，<code>synchronized(对象A)</code> 并不是直接用 <code>对象A</code> 当作 Monitor，而是利用 <code>对象A</code> 的 <code>Mark Word</code> 作为“跳板”或“指针”，在需要时链接到真正的重量级锁控制器（<code>ObjectMonitor</code>）。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>偏向锁</strong>：适用于几乎没有竞争的场景，旨在消除同步原语的开销。</li>
<li><strong>轻量级锁</strong>：适用于有一定竞争但不是非常激烈的场景，利用 CAS 操作来避免昂贵的操作系统互斥量。</li>
<li><strong>重量级锁</strong>：适用于高度竞争的场景，尽管开销较大，但能有效管理多个线程对同一资源的访问。</li>
</ul>
<p>需要注意的是，锁可以从偏向锁升级为轻量级锁，再升级为重量级锁，但是不能降级。一旦锁升级为重量级锁，它将一直保持这种状态，直到 JVM 重启或类加载器卸载相关类。</p>
<p>此外，从 Java 7 开始，默认情况下启用了偏向锁，但在某些特定环境下（如频繁的锁撤销），可能需要禁用偏向锁以获得更好的性能。可以通过 JVM 参数 <code>-XX:-UseBiasedLocking</code> 来关闭偏向锁。</p>
<p>在 Java 中，<code>synchronized</code> 是一种内置锁机制，用于确保多个线程在访问共享资源时的同步性。一个重要的特性是<strong>可重入性（Reentrancy）</strong>，这意味着同一个线程可以多次获取同一个锁而不会发生死锁。</p>
<h3 id="什么是锁重入？"><a href="#什么是锁重入？" class="headerlink" title="什么是锁重入？"></a>什么是锁重入？</h3><p>锁重入是指当一个线程已经持有了某个对象的锁，并试图再次获取该对象的锁时，JVM 允许这个操作成功完成，而不是阻塞或抛出异常。这种机制保证了即使在一个方法调用另一个也需要相同锁的方法时，也不会导致死锁。</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method A is called&quot;</span>);</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method B is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果一个线程调用了 <code>methodA()</code>，它会获得当前对象的锁并执行其中的代码。当 <code>methodA()</code> 内部调用 <code>methodB()</code> 时，由于 <code>methodB()</code> 也是同步方法，需要获取同样的锁。但是因为 <code>synchronized</code> 支持重入，所以这个线程可以再次获取相同的锁而不会被阻塞。</p>
<h3 id="锁计数器"><a href="#锁计数器" class="headerlink" title="锁计数器"></a>锁计数器</h3><p>为了实现重入，JVM 维护了一个与锁关联的计数器。每当一个线程获取到锁时，计数器加一；每当线程释放锁时，计数器减一。只有当计数器归零时，表示锁完全释放，其他等待该锁的线程才能获取到锁。</p>
<p>例如：</p>
<ul>
<li>线程 T1 首次获取锁，计数器从0变为1。</li>
<li>T1 再次获取同一锁，计数器从1变为2。</li>
<li>当 T1 完成同步代码块或方法，第一次释放锁，计数器从2变为1。</li>
<li>最后一次释放锁，计数器从1变为0，锁完全释放。</li>
</ul>
<h3 id="锁重入的应用场景"><a href="#锁重入的应用场景" class="headerlink" title="锁重入的应用场景"></a>锁重入的应用场景</h3><p>锁重入主要应用于以下几种情况：</p>
<ol>
<li><p><strong>递归调用同步方法或代码块</strong>：如上面的例子所示，一个方法内部调用另一个需要相同锁的方法。</p>
</li>
<li><p><strong>嵌套同步块</strong>：在一个同步方法或代码块内使用另一个需要相同锁的同步块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedSynchronization</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            innerMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 同步逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>继承层次中的同步方法</strong>：子类覆盖父类的方法时，如果两个方法都需要同步，则可能涉及到锁重入的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">parentMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">parentMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.parentMethod(); <span class="comment">// 调用父类的同步方法</span></span><br><span class="line">        <span class="comment">// 子类额外的同步逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>锁重入</strong>是 <code>synchronized</code> 的一个重要特性，允许同一个线程多次获取同一个锁而不导致死锁。</li>
<li>JVM 通过维护一个计数器来跟踪锁的获取次数，确保每次获取都有相应的释放操作，最终使得锁能够正确地被释放。</li>
<li>这种机制使得开发人员可以在编写多线程程序时更加灵活地使用同步方法和代码块，特别是在递归调用、嵌套同步块以及继承层次结构中同步方法的情况下。</li>
</ul>
<h2 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h2><p>自旋优化（Spin Optimization）是一种针对多线程同步机制的优化策略，主要用于减少线程在等待获取锁时进入阻塞状态所带来的开销。传统上，当一个线程尝试获取已经被其他线程持有的锁时，它会被挂起并放入等待队列中，直到锁被释放。这一过程涉及到上下文切换，即操作系统需要保存当前线程的状态并将CPU资源分配给另一个线程，这会带来一定的性能开销。</p>
<h3 id="自旋锁的基本概念"><a href="#自旋锁的基本概念" class="headerlink" title="自旋锁的基本概念"></a>自旋锁的基本概念</h3><p>自旋锁（Spin Lock）是指当一个线程尝试获取锁但未能成功时，不会立即进入阻塞状态，而是通过循环的方式“忙等”（busy-waiting），持续检查锁是否可用。一旦锁变为可用状态，该线程就可以立即获得锁并继续执行。这种方法可以避免昂贵的上下文切换，适用于锁被占用时间非常短的场景。</p>
<h3 id="自旋优化的工作原理"><a href="#自旋优化的工作原理" class="headerlink" title="自旋优化的工作原理"></a>自旋优化的工作原理</h3><p>自旋优化通常与轻量级锁结合使用，在某些情况下，JVM 会在尝试获取轻量级锁时先进行短暂的自旋操作，而不是直接进入阻塞状态。如果在这段时间内锁变为可用，则线程可以直接获取锁而无需经历阻塞和唤醒的过程；如果自旋一定次数后仍未获取到锁，则线程最终会被挂起。</p>
<h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ul>
<li><strong>减少上下文切换</strong>：自旋期间线程保持活跃，减少了从运行态到等待态再回到运行态的转换。</li>
<li><strong>适合短时间等待</strong>：对于那些预计锁很快就会被释放的情况特别有效。</li>
<li><strong>CPU资源消耗</strong>：由于自旋是主动的轮询检查，因此可能会浪费CPU周期，尤其是在长时间等待的情况下。</li>
</ul>
<h3 id="在Java中的应用"><a href="#在Java中的应用" class="headerlink" title="在Java中的应用"></a>在Java中的应用</h3><p>在 Java 中，自旋优化并不是直接暴露给开发者的功能，而是 JVM 内部的一种优化策略。具体来说，JVM 可能会在以下几种情况下采用自旋优化：</p>
<ol>
<li><strong>轻量级锁</strong>：在尝试获取轻量级锁失败时，JVM 可能会让线程先自旋一段时间，希望持有锁的线程能够尽快释放锁。</li>
<li><strong>偏向锁撤销</strong>：当偏向锁需要撤销时，JVM 可能会允许其他竞争线程先自旋，而不是立即升级为重量级锁。</li>
</ol>
<p>值得注意的是，从 Java 9 开始，默认情况下不再启用偏向锁，并且可以通过 JVM 参数调整相关行为，例如 <code>-XX:+UseBiasedLocking</code> 来控制偏向锁的使用，或 <code>-XX:BiasedLockingStartupDelay=0</code> 来设置偏向锁启动延迟。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>尽管自旋优化可以在某些特定场景下提高性能，但它并不总是最佳选择。特别是对于锁被长时间占用的情况，自旋会导致不必要的CPU资源浪费。因此，现代 JVM 实现了更复杂的锁机制，如适应性自旋（Adaptive Spinning），根据历史统计信息动态决定是否应该让线程自旋以及自旋多久。</p>
<p>在 Java 中，偏向锁是一种优化技术，旨在减少无竞争同步的开销。当一个线程第一次访问同步代码块或方法时，JVM 会尝试使用偏向锁来标记这个对象是被该线程所偏好的，从而避免后续对该锁的竞争检查。然而，在某些情况下，偏向锁会被撤销，其中一个常见的场景就是调用了对象的 <code>hashCode</code> 方法。</p>
<h3 id="为什么调用-hashCode-会导致偏向锁被禁用？"><a href="#为什么调用-hashCode-会导致偏向锁被禁用？" class="headerlink" title="为什么调用 hashCode 会导致偏向锁被禁用？"></a>为什么调用 <code>hashCode</code> 会导致偏向锁被禁用？</h3><ol>
<li><p><strong>偏向锁的工作原理</strong>：</p>
<ul>
<li>偏向锁通过在对象头（Object Header）的 Mark Word 中记录持有锁的线程 ID 来实现。这意味着，在偏向锁状态下，Mark Word 需要存储线程 ID 和偏向时间戳等信息。</li>
</ul>
</li>
<li><p><strong><code>hashCode</code> 的需求</strong>：</p>
<ul>
<li>当你调用一个对象的 <code>hashCode</code> 方法时，Java 需要返回一个整数值，该值通常基于对象的身份哈希码（即对象在内存中的地址）。对于普通对象，这个哈希码是由 JVM 自动生成并缓存的。</li>
<li>如果对象处于偏向锁状态，它的 Mark Word 已经被用于存储偏向锁的信息（如线程 ID），此时没有足够的空间同时存储哈希码和偏向锁信息。</li>
</ul>
</li>
<li><p><strong>偏向锁与 <code>hashCode</code> 的冲突</strong>：</p>
<ul>
<li>因为偏向锁需要占用 Mark Word 中原本可能用来存储哈希码的空间，所以在调用 <code>hashCode</code> 方法时，JVM 必须撤销偏向锁，以便腾出空间来计算和存储哈希码。</li>
<li>撤销偏向锁意味着将对象的状态从偏向锁转换为轻量级锁或重量级锁，具体取决于当前是否有其他线程在等待获取该锁。</li>
</ul>
</li>
<li><p><strong>性能考虑</strong>：</p>
<ul>
<li>调用 <code>hashCode</code> 导致偏向锁被撤销，虽然可能会引入一些额外的开销，但这通常是必要的，因为保证了哈希码的正确性和一致性比保持偏向锁更重要。此外，这种情况相对较少发生，大多数对象在其生命周期中不会调用 <code>hashCode</code> 方法。</li>
</ul>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>偏向锁</strong>利用对象头的 Mark Word 来存储偏向信息（如线程 ID），以减少同步操作的开销。</li>
<li><strong>调用 <code>hashCode</code> 方法</strong>需要使用对象头中的部分空间来存储哈希码，这就与偏向锁所需的存储空间产生了冲突。</li>
<li>为了确保哈希码能够正确地生成和存储，JVM 在检测到 <code>hashCode</code> 方法被调用时会撤销偏向锁，将对象的锁定状态升级为轻量级锁或者重量级锁。</li>
</ul>
<p>因此，当你知道某个对象将会频繁地调用 <code>hashCode</code> 方法时，应该意识到这可能会导致偏向锁被撤销，进而影响性能优化的效果。不过，在实际应用中，这种影响通常是可接受的，因为偏向锁主要是针对几乎没有锁竞争的情况设计的，而这些情况下的 <code>hashCode</code> 调用频率一般较低。</p>
<p>非常好的问题！<strong>批量重偏向（Bulk Rebiasing）</strong> 是 JVM 对 <strong>偏向锁优化机制</strong> 的一种高级改进，目的是在某些特定场景下<strong>避免频繁撤销偏向锁带来的性能损耗</strong>。它主要出现在多个对象被偏向同一个线程后，又陆续被其他线程访问的情况下。</p>
<hr>
<h2 id="🧠-为什么需要“批量重偏向”？"><a href="#🧠-为什么需要“批量重偏向”？" class="headerlink" title="🧠 为什么需要“批量重偏向”？"></a>🧠 为什么需要“批量重偏向”？</h2><p>我们先回顾一下偏向锁的两个关键点：</p>
<ol>
<li><strong>偏向锁一旦被另一个线程访问就会被撤销</strong>（revoke），并升级为轻量级锁。</li>
<li><strong>撤销操作是有成本的</strong>：需要停止所有线程（Stop-The-World）进行偏向锁撤销，影响性能。</li>
</ol>
<p>但如果多个对象都被偏向线程 T1，然后这些对象又被线程 T2 访问，那么每次都要撤销一次偏向锁，这会导致大量重复的撤销操作。</p>
<p>这时候，JVM 就引入了 <strong>批量重偏向（Bulk Rebiasing）</strong> 来解决这个问题。</p>
<hr>
<h2 id="🔍-批量重偏向的核心思想"><a href="#🔍-批量重偏向的核心思想" class="headerlink" title="🔍 批量重偏向的核心思想"></a>🔍 批量重偏向的核心思想</h2><blockquote>
<p>当 JVM 检测到某类对象（比如 <code>A.class</code> 的实例）正在被某个线程（T1）偏向，并且有另一个线程（T2）正在尝试获取这些对象的锁时，JVM 可以<strong>将这一批对象统一重新偏向到新线程 T2</strong>，而不是一个个地撤销偏向锁并升级为轻量级锁。</p>
</blockquote>
<p>这样做的好处是：</p>
<ul>
<li>减少 STW（Stop-The-World） 撤销次数；</li>
<li>避免锁升级，继续保持偏向锁状态；</li>
<li>提高并发性能。</li>
</ul>
<hr>
<h2 id="📈-批量重偏向的触发条件"><a href="#📈-批量重偏向的触发条件" class="headerlink" title="📈 批量重偏向的触发条件"></a>📈 批量重偏向的触发条件</h2><p>JVM 内部有一个计数器来统计某个类的对象发生偏向锁撤销的次数。当达到一定阈值（默认是 <strong>20 次</strong>）时，就会触发批量重偏向。</p>
<h3 id="示例流程如下："><a href="#示例流程如下：" class="headerlink" title="示例流程如下："></a>示例流程如下：</h3><ol>
<li>线程 T1 获取多个 <code>MyObject</code> 实例的偏向锁；</li>
<li>线程 T2 开始访问这些对象；</li>
<li>第 1~19 次访问时，T2 触发偏向锁撤销；</li>
<li>到第 20 次撤销时，JVM 发现这个类的对象频繁发生偏向锁撤销；</li>
<li>JVM 决定对这个类的所有未使用的实例进行 <strong>批量重偏向</strong>，把它们的偏向锁目标改为 T2；</li>
<li>后续访问这些对象时，T2 不再需要撤销偏向锁，而是直接获得偏向锁。</li>
</ol>
<hr>
<h2 id="🧩-关键概念总结"><a href="#🧩-关键概念总结" class="headerlink" title="🧩 关键概念总结"></a>🧩 关键概念总结</h2><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁撤销（Revoke）</td>
<td>当另一个线程尝试获取已被偏向的锁时，JVM 会撤销偏向锁</td>
</tr>
<tr>
<td>批量重偏向（Bulk Rebiasing）</td>
<td>JVM 检测到某一类对象频繁被撤销偏向锁后，统一将这些对象的偏向锁重新指向新的线程</td>
</tr>
<tr>
<td>批量撤销（Bulk Revocation）</td>
<td>如果竞争太激烈，JVM 直接对该类的所有对象撤销偏向锁，不再使用偏向锁机制</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚙️-如何观察和控制批量重偏向？"><a href="#⚙️-如何观察和控制批量重偏向？" class="headerlink" title="⚙️ 如何观察和控制批量重偏向？"></a>⚙️ 如何观察和控制批量重偏向？</h2><p>你可以通过以下方式查看或调整相关参数：</p>
<h3 id="1-查看当前是否启用偏向锁（Java-8-默认开启）："><a href="#1-查看当前是否启用偏向锁（Java-8-默认开启）：" class="headerlink" title="1. 查看当前是否启用偏向锁（Java 8+ 默认开启）："></a>1. 查看当前是否启用偏向锁（Java 8+ 默认开启）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal | grep UseBiasedLocking</span><br></pre></td></tr></table></figure>

<p>输出类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool UseBiasedLocking                          = true</span><br></pre></td></tr></table></figure>

<h3 id="2-控制偏向锁延迟启动时间（默认是-4-秒）："><a href="#2-控制偏向锁延迟启动时间（默认是-4-秒）：" class="headerlink" title="2. 控制偏向锁延迟启动时间（默认是 4 秒）："></a>2. 控制偏向锁延迟启动时间（默认是 4 秒）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>

<h3 id="3-查看偏向锁相关的统计信息（需要启用诊断选项）："><a href="#3-查看偏向锁相关的统计信息（需要启用诊断选项）：" class="headerlink" title="3. 查看偏向锁相关的统计信息（需要启用诊断选项）："></a>3. 查看偏向锁相关的统计信息（需要启用诊断选项）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintBiasedLockingStatistics</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><strong>批量重偏向是 JVM 在检测到某一类对象频繁发生偏向锁撤销时，主动将这批对象的偏向锁目标更换为当前请求的新线程，从而减少后续的撤销次数，提升性能的一种优化策略。</strong></p>
</blockquote>
<p>它是偏向锁机制的一个重要补充，在多线程交替访问共享资源、但竞争不激烈的场景中特别有效。</p>
<hr>
<p>这个问题非常关键，也非常深入！你问的是：</p>
<blockquote>
<p><strong>“偏向锁撤销了之后不是就升级为轻量级锁了吗？为什么还能回退到偏向锁？”</strong></p>
</blockquote>
<p>我们来详细分析一下这个过程。</p>
<hr>
<h2 id="🔍-问题核心："><a href="#🔍-问题核心：" class="headerlink" title="🔍 问题核心："></a>🔍 问题核心：</h2><p><strong>偏向锁被撤销后，是否可以重新变为偏向锁？</strong></p>
<h3 id="✅-简短回答："><a href="#✅-简短回答：" class="headerlink" title="✅ 简短回答："></a>✅ 简短回答：</h3><blockquote>
<p><strong>是的，偏向锁被撤销后，并不会立即变成轻量级锁。JVM 会根据实际情况决定是否恢复偏向锁（比如批量重偏向），或者直接升级为轻量级&#x2F;重量级锁。</strong></p>
</blockquote>
<hr>
<h2 id="🧠-偏向锁撤销-≠-锁升级"><a href="#🧠-偏向锁撤销-≠-锁升级" class="headerlink" title="🧠 偏向锁撤销 ≠ 锁升级"></a>🧠 偏向锁撤销 ≠ 锁升级</h2><p>很多人误以为只要偏向锁被撤销（revoke），就会自动升级为轻量级锁，其实这是不对的。</p>
<p>让我们澄清几个关键概念：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>偏向锁撤销（Revoke）</strong></td>
<td>表示某个线程尝试获取一个已经被偏向其他线程的对象锁，此时 JVM 会清除偏向信息（如线程 ID）。这一步只是“清理”偏向状态，并不等于锁升级。</td>
</tr>
<tr>
<td><strong>锁升级（升级为轻量级或重量级锁）</strong></td>
<td>是另一个独立的过程，只有在多个线程竞争同一个锁时才会发生。</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧪-示例场景回顾"><a href="#🧪-示例场景回顾" class="headerlink" title="🧪 示例场景回顾"></a>🧪 示例场景回顾</h2><p>我们来看一个典型的流程：</p>
<ol>
<li><strong>T1 获取对象锁 → 对象进入偏向锁状态（偏向 T1）</strong></li>
<li><strong>T2 尝试获取锁 → 发现偏向 T1，触发偏向锁撤销（revoke）</strong><ul>
<li>此时对象头 Mark Word 被清空或标记为不可偏向。</li>
</ul>
</li>
<li><strong>如果这是第 1~19 次撤销某个类的对象偏向锁</strong><ul>
<li>JVM 记录撤销次数；</li>
<li>不立即升级为轻量级锁；</li>
<li>对象处于 “可偏向但未偏向” 的中间状态（neutral bias state）。</li>
</ul>
</li>
<li><strong>如果后续有新的线程请求锁，且满足条件，可能再次偏向该线程（即重新启用偏向锁）</strong></li>
<li><strong>当撤销次数达到阈值（默认 20 次）</strong><ul>
<li>JVM 触发 <strong>批量重偏向（Bulk Rebiasing）</strong><ul>
<li>把这一类对象统一重新偏向当前线程；</li>
</ul>
</li>
<li>或者触发 <strong>批量撤销（Bulk Revocation）</strong><ul>
<li>直接禁用这类对象的偏向锁机制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔁-偏向锁是可以“重新获得”的！"><a href="#🔁-偏向锁是可以“重新获得”的！" class="headerlink" title="🔁 偏向锁是可以“重新获得”的！"></a>🔁 偏向锁是可以“重新获得”的！</h2><p>也就是说：</p>
<ul>
<li><strong>偏向锁撤销 ≠ 升级为轻量级锁</strong></li>
<li>在撤销后，如果对象没有被升级为轻量级锁，它仍然可以被其他线程重新偏向。</li>
<li>这就是 JVM 的一种优化策略 —— <strong>延迟锁升级</strong>，避免不必要的开销。</li>
</ul>
<hr>
<h2 id="📌-举个例子说明更清楚："><a href="#📌-举个例子说明更清楚：" class="headerlink" title="📌 举个例子说明更清楚："></a>📌 举个例子说明更清楚：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">    objects[i] = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1 先偏向这些对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : objects) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2 开始访问这些对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : objects) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;&#125; <span class="comment">// 前 19 次触发撤销，第 20 次触发批量重偏向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>第 1~19 次：T2 访问 T1 偏向的对象，触发偏向锁撤销；</li>
<li>第 20 次：JVM 发现撤销次数达到阈值，于是对 <code>objects</code> 所属类的所有对象执行 <strong>批量重偏向</strong>，将它们偏向 T2；</li>
<li>后续访问：T2 再次访问这些对象时，又能以偏向锁方式获取锁，不再需要撤销。</li>
</ul>
<hr>
<h2 id="🧩-什么时候才会真正升级为轻量级锁？"><a href="#🧩-什么时候才会真正升级为轻量级锁？" class="headerlink" title="🧩 什么时候才会真正升级为轻量级锁？"></a>🧩 什么时候才会真正升级为轻量级锁？</h2><p>只有在以下情况下，JVM 才会真正将锁从偏向锁升级为轻量级锁：</p>
<ol>
<li><strong>多个线程同时竞争同一个对象的锁</strong>（比如两个线程几乎同时尝试获取锁）</li>
<li><strong>CAS 操作失败多次</strong>，表示并发竞争激烈</li>
<li><strong>批量重偏向失败或被跳过</strong></li>
</ol>
<p>这时候 JVM 才会放弃使用偏向锁机制，升级为轻量级锁（通过 CAS 实现）或最终升级为重量级锁（操作系统互斥量）。</p>
<hr>
<h2 id="✅-总结一句话：-1"><a href="#✅-总结一句话：-1" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><strong>偏向锁撤销 ≠ 锁升级</strong>，它只是“取消偏向”，并不意味着锁立刻变成轻量级锁。JVM 会在撤销后观察是否有新的线程频繁访问这些对象，如果有，还会进行<strong>批量重偏向</strong>，让这些对象重新支持偏向锁机制。</p>
</blockquote>
<p>这样做的目的是：</p>
<ul>
<li>避免频繁的偏向锁撤销；</li>
<li>减少上下文切换和 STW（Stop-The-World）操作；</li>
<li>提高多线程交替访问下的性能表现。</li>
</ul>
<hr>
<p>这是一个非常深入、非常好的问题！</p>
<blockquote>
<p><strong>你问：</strong><br>在偏向锁机制中，T2 访问 T1 偏向的对象时触发了偏向锁撤销。那为什么不直接让这个对象偏向 T2，而是要等到第 20 次才批量重偏向呢？</p>
</blockquote>
<hr>
<h2 id="✅-简短回答：-1"><a href="#✅-简短回答：-1" class="headerlink" title="✅ 简短回答："></a>✅ 简短回答：</h2><blockquote>
<p>JVM 不会立即把对象从偏向 T1 改为偏向 T2，是为了防止“频繁切换偏向线程”带来的性能开销和误判。只有当发现某个类的对象被多个线程交替访问的频率较高时，JVM 才会进行 <strong>批量重偏向（Bulk Rebiasing）</strong>。</p>
</blockquote>
<hr>
<h2 id="🧠-为什么不能“立刻偏向-T2”？"><a href="#🧠-为什么不能“立刻偏向-T2”？" class="headerlink" title="🧠 为什么不能“立刻偏向 T2”？"></a>🧠 为什么不能“立刻偏向 T2”？</h2><p>我们来逐条分析原因：</p>
<h3 id="1-避免频繁撤销和重偏向带来的开销"><a href="#1-避免频繁撤销和重偏向带来的开销" class="headerlink" title="1. 避免频繁撤销和重偏向带来的开销"></a>1. <strong>避免频繁撤销和重偏向带来的开销</strong></h3><ul>
<li>每次偏向锁撤销都需要进行一次全局安全点（Safepoint），也就是 Stop-The-World（STW）操作。</li>
<li>如果每次遇到不同线程就重新偏向，会导致大量 STW 操作，反而降低性能。</li>
</ul>
<p>📌 类比：就像不要因为一个人偶尔用了一次厕所，就给每个新人都换一把厕所钥匙。</p>
<hr>
<h3 id="2-防止误判：可能是偶发性竞争，而非真正的多线程交替使用"><a href="#2-防止误判：可能是偶发性竞争，而非真正的多线程交替使用" class="headerlink" title="2. 防止误判：可能是偶发性竞争，而非真正的多线程交替使用"></a>2. <strong>防止误判：可能是偶发性竞争，而非真正的多线程交替使用</strong></h3><ul>
<li>第一次发生偏向锁撤销，可能只是个偶然事件，比如：<ul>
<li>T2 只是临时访问一下；</li>
<li>后续还是 T1 长期使用；</li>
</ul>
</li>
<li>如果此时就偏向 T2，那么下次 T1 再访问又要撤销，来回折腾，得不偿失。</li>
</ul>
<p>📌 类比：你正在写代码，同事借你鼠标用了一下。这时候没必要把鼠标的使用权“永久移交”给他。</p>
<hr>
<h3 id="3-批量处理更高效：减少-Safepoint-次数"><a href="#3-批量处理更高效：减少-Safepoint-次数" class="headerlink" title="3. 批量处理更高效：减少 Safepoint 次数"></a>3. <strong>批量处理更高效：减少 Safepoint 次数</strong></h3><ul>
<li>JVM 是一种追求吞吐量的系统，它倾向于将多个类似的小操作合并成一个大操作来优化性能。</li>
<li>所以 JVM 设置了一个阈值（默认是 <strong>20 次</strong>），当某一类对象发生撤销次数达到这个阈值时，才统一进行批量重偏向。</li>
</ul>
<p>📌 这是一种典型的“延迟优化”策略 —— <strong>只在真正需要的时候才做昂贵的操作</strong>。</p>
<hr>
<h2 id="📈-批量重偏向的工作流程（详细）"><a href="#📈-批量重偏向的工作流程（详细）" class="headerlink" title="📈 批量重偏向的工作流程（详细）"></a>📈 批量重偏向的工作流程（详细）</h2><table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1. T1 获取锁</td>
<td>对象进入偏向状态（偏向 T1）</td>
</tr>
<tr>
<td>2. T2 尝试获取锁</td>
<td>发现偏向 T1，触发偏向锁撤销</td>
</tr>
<tr>
<td>3. 第 1~19 次撤销</td>
<td>JVM 记录该类对象的撤销次数；不做批量重偏向</td>
</tr>
<tr>
<td>4. 第 20 次撤销</td>
<td>达到阈值，触发 <strong>批量重偏向</strong></td>
</tr>
<tr>
<td>5. 所有未被使用的该类对象</td>
<td>被统一偏向当前线程（T2）</td>
</tr>
<tr>
<td>6. 后续访问</td>
<td>T2 再次访问这些对象时，可以再次以偏向锁方式获得锁</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-补充：如果撤销特别频繁怎么办？"><a href="#🧩-补充：如果撤销特别频繁怎么办？" class="headerlink" title="🧩 补充：如果撤销特别频繁怎么办？"></a>🧩 补充：如果撤销特别频繁怎么办？</h2><p>如果某类对象不仅撤销很多，而且并发竞争很激烈（比如多个线程同时抢锁），JVM 还有一个更强力的机制：</p>
<h3 id="🔥-批量撤销（Bulk-Revocation）"><a href="#🔥-批量撤销（Bulk-Revocation）" class="headerlink" title="🔥 批量撤销（Bulk Revocation）"></a>🔥 <strong>批量撤销（Bulk Revocation）</strong></h3><ul>
<li>当撤销次数太多或并发太强时，JVM 会直接禁用这类对象的偏向锁功能。</li>
<li>后续所有该类对象的锁都跳过偏向锁阶段，直接使用轻量级锁或重量级锁。</li>
</ul>
<hr>
<h2 id="⚙️-如何查看-调整这些参数？"><a href="#⚙️-如何查看-调整这些参数？" class="headerlink" title="⚙️ 如何查看&#x2F;调整这些参数？"></a>⚙️ 如何查看&#x2F;调整这些参数？</h2><p>你可以通过以下 JVM 参数控制偏向锁的行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingBulkRebiasThreshold=20     <span class="comment"># 默认值</span></span><br><span class="line">-XX:BiasedLockingBulkRevokeThreshold=40     <span class="comment"># 默认值</span></span><br></pre></td></tr></table></figure>

<p>还可以启用诊断信息观察偏向锁状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintBiasedLockingStatistics</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-总结一句话：-2"><a href="#✅-总结一句话：-2" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><strong>JVM 不会在第一次撤销偏向锁后就立刻偏向新线程，是为了避免不必要的 STW 开销和误判。只有当检测到某类对象频繁发生偏向锁撤销时，才会触发批量重偏向，统一将它们偏向新的线程。</strong></p>
</blockquote>
<p>这是一种典型的“懒优化”、“延迟决策”策略，体现了 JVM 在性能与复杂度之间做出的精妙权衡。</p>
<hr>
<p>非常好！我们来系统、详细地讲解一下 <strong>偏向锁的撤销流程（Biased Locking Revocation）</strong>，这是 JVM 在多线程环境下优化锁性能的一个重要机制。</p>
<hr>
<h2 id="🧠-什么是偏向锁撤销？"><a href="#🧠-什么是偏向锁撤销？" class="headerlink" title="🧠 什么是偏向锁撤销？"></a>🧠 什么是偏向锁撤销？</h2><blockquote>
<p><strong>偏向锁撤销（Revoke Biased Lock）</strong> 是指当一个线程尝试获取某个对象的锁时，发现该对象已经被偏向其他线程了，于是触发的一系列操作，用于清除偏向状态，为后续锁升级做准备。</p>
</blockquote>
<h3 id="📌-关键点："><a href="#📌-关键点：" class="headerlink" title="📌 关键点："></a>📌 关键点：</h3><ul>
<li>偏向锁撤销不是直接升级为轻量级锁。</li>
<li>它只是“取消偏向”，让对象回到中立状态（neutral bias state），为后续是否使用轻量级锁或再次偏向做准备。</li>
<li>撤销过程需要进入 <strong>安全点（Safepoint）</strong>，也就是全局停顿（Stop-The-World，STW），所以代价较高。</li>
</ul>
<hr>
<h2 id="🔁-偏向锁撤销的典型触发场景"><a href="#🔁-偏向锁撤销的典型触发场景" class="headerlink" title="🔁 偏向锁撤销的典型触发场景"></a>🔁 偏向锁撤销的典型触发场景</h2><ol>
<li><strong>另一个线程尝试获取已被偏向的对象锁</strong></li>
<li><strong>调用 <code>Object.hashCode()</code> 或 <code>System.identityHashCode()</code></strong></li>
<li><strong>JVM 进行批量重偏向或批量撤销</strong></li>
</ol>
<p>我们重点讲解第一种情况：<strong>另一个线程访问已偏向的对象。</strong></p>
<hr>
<h2 id="🧪-场景模拟："><a href="#🧪-场景模拟：" class="headerlink" title="🧪 场景模拟："></a>🧪 场景模拟：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// T1 获取锁 → obj 被偏向 T1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 T1 执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// T2 尝试获取锁 → 触发偏向锁撤销</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🚀-偏向锁撤销流程详解（从-T2-的角度）"><a href="#🚀-偏向锁撤销流程详解（从-T2-的角度）" class="headerlink" title="🚀 偏向锁撤销流程详解（从 T2 的角度）"></a>🚀 偏向锁撤销流程详解（从 T2 的角度）</h2><p>我们分步骤来看 JVM 如何处理这个撤销过程：</p>
<hr>
<h3 id="✅-第一步：检查对象头-Mark-Word"><a href="#✅-第一步：检查对象头-Mark-Word" class="headerlink" title="✅ 第一步：检查对象头 Mark Word"></a>✅ 第一步：检查对象头 Mark Word</h3><ul>
<li>对象头中的 <strong>Mark Word</strong> 包含了偏向锁信息（如线程 ID 和偏向时间戳）。</li>
<li>T2 发现对象处于偏向状态，并且偏向的线程是 T1，不是自己。</li>
</ul>
<hr>
<h3 id="✅-第二步：判断是否可以撤销"><a href="#✅-第二步：判断是否可以撤销" class="headerlink" title="✅ 第二步：判断是否可以撤销"></a>✅ 第二步：判断是否可以撤销</h3><ul>
<li>如果当前没有其他线程正在并发修改该对象的状态，那么可以进行撤销。</li>
<li>如果对象正被多个线程竞争，则可能跳过撤销，直接升级为轻量级锁。</li>
</ul>
<hr>
<h3 id="✅-第三步：进入-Safepoint（全局停顿）"><a href="#✅-第三步：进入-Safepoint（全局停顿）" class="headerlink" title="✅ 第三步：进入 Safepoint（全局停顿）"></a>✅ 第三步：进入 Safepoint（全局停顿）</h3><ul>
<li>因为要修改对象头的信息，必须确保所有使用该对象的线程都处于安全状态。</li>
<li>JVM 触发一次 <strong>Safepoint</strong>（即 Stop-The-World，STW），暂停所有线程。</li>
<li>这个过程会带来一定的性能开销。</li>
</ul>
<hr>
<h3 id="✅-第四步：撤销偏向锁"><a href="#✅-第四步：撤销偏向锁" class="headerlink" title="✅ 第四步：撤销偏向锁"></a>✅ 第四步：撤销偏向锁</h3><ul>
<li>清除对象头中的偏向标志位；</li>
<li>清除线程 ID 和偏向时间戳；</li>
<li>将对象状态改为“可偏向但未偏向”（neutral bias）或“不可偏向”状态；</li>
<li>如果是批量撤销策略的一部分，还可能将整个类的对象统一撤销偏向状态。</li>
</ul>
<hr>
<h3 id="✅-第五步：恢复线程执行并尝试获取锁"><a href="#✅-第五步：恢复线程执行并尝试获取锁" class="headerlink" title="✅ 第五步：恢复线程执行并尝试获取锁"></a>✅ 第五步：恢复线程执行并尝试获取锁</h3><ul>
<li>STW 结束，线程继续运行；</li>
<li>T2 继续尝试获取锁；</li>
<li>此时对象不再是偏向锁状态，T2 可能通过 CAS 操作获取轻量级锁；</li>
<li>如果有多个线程竞争，最终可能升级为重量级锁。</li>
</ul>
<hr>
<h2 id="⚙️-撤销后的状态变化（以-64-位-JVM-为例）"><a href="#⚙️-撤销后的状态变化（以-64-位-JVM-为例）" class="headerlink" title="⚙️ 撤销后的状态变化（以 64 位 JVM 为例）"></a>⚙️ 撤销后的状态变化（以 64 位 JVM 为例）</h2><table>
<thead>
<tr>
<th>锁状态</th>
<th>Mark Word 内容</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>01 + hashcode + age</td>
</tr>
<tr>
<td>偏向锁</td>
<td>101 + threadID + epoch + age</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中 Lock Record 的指针</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向 Monitor 的指针</td>
</tr>
</tbody></table>
<p>撤销后，Mark Word 中不再包含偏向信息，变成 neutral bias 状态或者直接进入轻量级锁状态。</p>
<hr>
<h2 id="📈-批量撤销-vs-单个撤销"><a href="#📈-批量撤销-vs-单个撤销" class="headerlink" title="📈 批量撤销 vs 单个撤销"></a>📈 批量撤销 vs 单个撤销</h2><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单个撤销</strong></td>
<td>当某类对象发生少量偏向锁撤销时，只对当前对象进行撤销</td>
</tr>
<tr>
<td><strong>批量撤销</strong></td>
<td>当某一类对象撤销次数超过阈值（默认 40 次），JVM 会禁用该类的偏向锁机制，所有对象直接跳过偏向锁阶段</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-为什么偏向锁撤销代价高？"><a href="#🎯-为什么偏向锁撤销代价高？" class="headerlink" title="🎯 为什么偏向锁撤销代价高？"></a>🎯 为什么偏向锁撤销代价高？</h2><table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>需要进入 Safepoint</td>
<td>导致全局停顿（STW），影响吞吐量</td>
</tr>
<tr>
<td>修改对象头</td>
<td>必须在 STW 下完成，否则可能造成数据不一致</td>
</tr>
<tr>
<td>不一定有用</td>
<td>撤销后如果只有一个线程访问，又得重新偏向，浪费资源</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-总结：偏向锁撤销的关键流程"><a href="#✅-总结：偏向锁撤销的关键流程" class="headerlink" title="✅ 总结：偏向锁撤销的关键流程"></a>✅ 总结：偏向锁撤销的关键流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程 T2 尝试获取锁</span><br><span class="line">   ↓</span><br><span class="line">发现对象处于偏向状态（偏向 T1）</span><br><span class="line">   ↓</span><br><span class="line">判断是否满足撤销条件</span><br><span class="line">   ↓</span><br><span class="line">进入 Safepoint（STW）</span><br><span class="line">   ↓</span><br><span class="line">清除 Mark Word 中的偏向信息</span><br><span class="line">   ↓</span><br><span class="line">退出 Safepoint，T2 继续尝试获取锁</span><br><span class="line">   ↓</span><br><span class="line">根据竞争情况决定是否升级为轻量级锁或重量级锁</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💡-补充建议"><a href="#💡-补充建议" class="headerlink" title="💡 补充建议"></a>💡 补充建议</h2><p>如果你希望更深入地观察对象头的变化，比如查看 Mark Word 的内容，可以使用 <strong>JOL（Java Object Layout）工具</strong>，这是一个非常强大的调试工具。</p>
<p>以下是一个简单的 JOL 示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;初始对象布局:&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 加锁后:&quot;</span>);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 加锁后:&quot;</span>);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果可以看到 Mark Word 的变化，从而验证偏向锁、撤销、升级的过程。</p>
<hr>
<h2 id="撤销了t1，t2获得了锁，如果还没升级轻量级锁-那是什么锁"><a href="#撤销了t1，t2获得了锁，如果还没升级轻量级锁-那是什么锁" class="headerlink" title="撤销了t1，t2获得了锁，如果还没升级轻量级锁 那是什么锁"></a>撤销了t1，t2获得了锁，如果还没升级轻量级锁 那是什么锁</h2><p>在 Java 的偏向锁撤销过程中，当 T2 尝试获取已被 T1 偏向的对象锁时，会发生偏向锁的撤销。撤销后，T2 获取到的锁状态取决于具体的竞争情况和 JVM 的优化策略。</p>
<h3 id="撤销后的锁状态"><a href="#撤销后的锁状态" class="headerlink" title="撤销后的锁状态"></a>撤销后的锁状态</h3><p>如果在撤销偏向锁之后，还没有升级为轻量级锁（Lightweight Lock），那么此时的锁状态实际上是一个**“无锁但可偏向”状态**（neutral bias state）。不过，这并不意味着 T2 实际上是在这种状态下获得锁的。让我们详细分析一下撤销后可能发生的情况：</p>
<hr>
<h2 id="🧪-场景回顾"><a href="#🧪-场景回顾" class="headerlink" title="🧪 场景回顾"></a>🧪 场景回顾</h2><p>假设我们有如下场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 T1 获取偏向锁</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// T1 获得偏向锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();  <span class="comment">// 等待 T1 完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 T2 尝试获取锁，触发偏向锁撤销</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// T2 触发偏向锁撤销并尝试获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<h3 id="撤销过程简述："><a href="#撤销过程简述：" class="headerlink" title="撤销过程简述："></a>撤销过程简述：</h3><ol>
<li><strong>T1 获取了偏向锁</strong>：对象被标记为偏向 T1。</li>
<li><strong>T2 尝试获取锁</strong>：发现对象已偏向 T1，触发偏向锁撤销。</li>
<li><strong>JVM 进入 Safepoint</strong>：暂停所有线程，清除偏向信息。</li>
<li><strong>T2 继续执行</strong>：尝试重新获取锁。</li>
</ol>
<hr>
<h2 id="🔍-撤销后的锁状态分析"><a href="#🔍-撤销后的锁状态分析" class="headerlink" title="🔍 撤销后的锁状态分析"></a>🔍 撤销后的锁状态分析</h2><p>撤销偏向锁后，根据具体场景和 JVM 的优化策略，可能会出现以下几种情况：</p>
<h3 id="1-直接进入轻量级锁"><a href="#1-直接进入轻量级锁" class="headerlink" title="1. 直接进入轻量级锁"></a>1. <strong>直接进入轻量级锁</strong></h3><p>如果 T2 在撤销偏向锁的过程中检测到存在潜在的竞争（比如有其他线程也在等待这个锁），JVM 可能会直接将锁升级为轻量级锁。</p>
<ul>
<li><strong>锁类型</strong>：轻量级锁</li>
<li><strong>实现方式</strong>：通过 CAS（Compare And Swap）操作来尝试获取锁。</li>
</ul>
<h3 id="2-保持中立状态（Neutral-Bias-State）并重新偏向"><a href="#2-保持中立状态（Neutral-Bias-State）并重新偏向" class="headerlink" title="2. 保持中立状态（Neutral Bias State）并重新偏向"></a>2. <strong>保持中立状态（Neutral Bias State）并重新偏向</strong></h3><p>如果撤销偏向锁后，没有其他线程竞争该锁，JVM 可能会选择将对象的状态恢复为中立状态，并允许 T2 再次偏向该对象。</p>
<ul>
<li><strong>锁类型</strong>：无锁但可偏向（neutral bias state）</li>
<li><strong>说明</strong>：虽然对象处于中立状态，但由于没有竞争，JVM 允许 T2 直接偏向该对象，类似于初始的偏向锁状态。</li>
</ul>
<h3 id="3-CAS-竞争失败后升级为轻量级锁"><a href="#3-CAS-竞争失败后升级为轻量级锁" class="headerlink" title="3. CAS 竞争失败后升级为轻量级锁"></a>3. <strong>CAS 竞争失败后升级为轻量级锁</strong></h3><p>如果 T2 在撤销偏向锁后尝试通过 CAS 操作获取锁，但 CAS 操作失败（即有其他线程也在尝试获取锁），则 JVM 会将锁升级为轻量级锁。</p>
<ul>
<li><strong>锁类型</strong>：轻量级锁</li>
<li><strong>说明</strong>：CAS 失败表明存在竞争，因此需要使用更复杂的同步机制来管理锁。</li>
</ul>
<h3 id="4-批量重偏向"><a href="#4-批量重偏向" class="headerlink" title="4. 批量重偏向"></a>4. <strong>批量重偏向</strong></h3><p>如果 JVM 发现某一类对象频繁发生偏向锁撤销（达到一定阈值，默认是 20 次），它会进行 <strong>批量重偏向</strong>，将这些对象统一偏向新的线程（如 T2）。</p>
<ul>
<li><strong>锁类型</strong>：偏向锁（偏向 T2）</li>
<li><strong>说明</strong>：JVM 通过批量重偏向避免频繁撤销带来的性能损耗。</li>
</ul>
<hr>
<h2 id="✅-总结：T2-获得锁的具体情况"><a href="#✅-总结：T2-获得锁的具体情况" class="headerlink" title="✅ 总结：T2 获得锁的具体情况"></a>✅ 总结：T2 获得锁的具体情况</h2><p>根据上述分析，当 T2 在撤销偏向锁后获得锁时，可能遇到以下几种情况：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>没有竞争</td>
<td>无锁但可偏向（neutral bias state）或偏向锁（偏向 T2）</td>
<td>如果没有其他线程竞争，T2 可能重新偏向该对象。</td>
</tr>
<tr>
<td>轻微竞争</td>
<td>轻量级锁</td>
<td>如果有轻微竞争，T2 可能通过 CAS 操作获取轻量级锁。</td>
</tr>
<tr>
<td>强烈竞争</td>
<td>轻量级锁或重量级锁</td>
<td>如果竞争激烈，JVM 可能将锁升级为轻量级锁甚至重量级锁。</td>
</tr>
</tbody></table>
<h3 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong>撤销偏向锁并不会自动升级为轻量级锁</strong>，而是根据具体情况决定后续步骤。</li>
<li><strong>如果没有其他线程竞争</strong>，T2 可以重新偏向该对象，继续享受偏向锁的优势。</li>
<li><strong>如果有竞争</strong>，则会根据竞争程度选择合适的锁机制（轻量级锁或重量级锁）。</li>
</ul>
<hr>
<p>非常棒的追问！你抓住了偏向锁机制中一个<strong>核心但容易混淆的点</strong>：  </p>
<blockquote>
<p><strong>“JVM 在什么情况下才会让对象重新偏向另一个线程？”</strong></p>
</blockquote>
<p>我们来系统、清晰地解释这个问题。</p>
<hr>
<h2 id="✅-你的问题本质："><a href="#✅-你的问题本质：" class="headerlink" title="✅ 你的问题本质："></a>✅ 你的问题本质：</h2><p>你说得对，前面我提到：</p>
<ul>
<li>如果撤销后没有竞争，T2 可能会重新偏向该对象；</li>
<li>但你也记得：只有当某个类的对象发生 <strong>20 次偏向锁撤销</strong> 后，JVM 才会触发 <strong>批量重偏向（Bulk Rebiasing）</strong>。</li>
</ul>
<p>所以你问：</p>
<blockquote>
<p><strong>那是不是只有在第 20 次撤销时才允许重新偏向？为什么前面又说 T2 有可能直接重新偏向？</strong></p>
</blockquote>
<hr>
<h2 id="🧠-答案一句话总结："><a href="#🧠-答案一句话总结：" class="headerlink" title="🧠 答案一句话总结："></a>🧠 答案一句话总结：</h2><blockquote>
<p><strong>是的，只有当某类对象累计发生 20 次偏向锁撤销时，才会触发批量重偏向；但在某些特定场景下，JVM 也允许单个对象在撤销后重新偏向新线程，这被称为“单次重偏向”或“延迟偏向”。</strong></p>
</blockquote>
<hr>
<h2 id="🔍-具体分析"><a href="#🔍-具体分析" class="headerlink" title="🔍 具体分析"></a>🔍 具体分析</h2><h3 id="📌-1-偏向锁撤销-≠-锁升级为轻量级锁"><a href="#📌-1-偏向锁撤销-≠-锁升级为轻量级锁" class="headerlink" title="📌 1. 偏向锁撤销 ≠ 锁升级为轻量级锁"></a>📌 1. 偏向锁撤销 ≠ 锁升级为轻量级锁</h3><p>如前所述，偏向锁撤销只是清除偏向信息，并不意味着立即升级为轻量级锁。<br>此时对象进入一种中间状态 —— <strong>neutral bias state（中立偏向状态）</strong>，表示它可以被再次偏向。</p>
<hr>
<h3 id="📌-2-单个对象是否可以重新偏向？"><a href="#📌-2-单个对象是否可以重新偏向？" class="headerlink" title="📌 2. 单个对象是否可以重新偏向？"></a>📌 2. 单个对象是否可以重新偏向？</h3><p>答案是：<strong>可以</strong>，但这不是默认行为，而是取决于以下条件：</p>
<h4 id="✅-条件一：没有其他线程竞争"><a href="#✅-条件一：没有其他线程竞争" class="headerlink" title="✅ 条件一：没有其他线程竞争"></a>✅ 条件一：没有其他线程竞争</h4><ul>
<li>如果当前只有一个线程访问该对象（比如 T2 是唯一访问者），那么 JVM 可以将它重新偏向给 T2。</li>
<li>这样做的好处是避免不必要的 CAS 操作和锁升级，提高性能。</li>
</ul>
<h4 id="✅-条件二：该类尚未触发批量重偏向或批量撤销"><a href="#✅-条件二：该类尚未触发批量重偏向或批量撤销" class="headerlink" title="✅ 条件二：该类尚未触发批量重偏向或批量撤销"></a>✅ 条件二：该类尚未触发批量重偏向或批量撤销</h4><ul>
<li>如果这个类还没有达到撤销次数阈值（默认 20 次），那么 JVM 可能尝试让这个对象单独偏向 T2。</li>
<li>如果已经达到了阈值，则统一进行批量重偏向。</li>
</ul>
<hr>
<h3 id="📌-3-什么时候才能批量重偏向？"><a href="#📌-3-什么时候才能批量重偏向？" class="headerlink" title="📌 3. 什么时候才能批量重偏向？"></a>📌 3. 什么时候才能批量重偏向？</h3><p>JVM 内部维护了一个 <strong>撤销计数器（revocation count）</strong>，用于统计某个类的对象发生偏向锁撤销的次数。</p>
<table>
<thead>
<tr>
<th>阈值</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>撤销 &lt; 20 次</td>
<td>不批量操作，可能允许单个对象重新偏向</td>
</tr>
<tr>
<td>撤销 ≥ 20 次</td>
<td>触发 <strong>批量重偏向（Bulk Rebiasing）</strong>，所有未使用的该类对象都偏向当前线程</td>
</tr>
<tr>
<td>撤销 ≥ 40 次</td>
<td>触发 <strong>批量撤销（Bulk Revocation）</strong>，禁用该类对象的偏向锁</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧪-示例说明"><a href="#🧪-示例说明" class="headerlink" title="🧪 示例说明"></a>🧪 示例说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1 获取偏向锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2 尝试获取锁 → 第一次撤销偏向锁</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>obj</code> 被 T1 偏向；</li>
<li>T2 访问时触发第一次撤销；</li>
<li>因为只撤销了一次，还没达到 20 次，<strong>JVM 可能选择将 obj 直接偏向 T2</strong>，而不是升级为轻量级锁。</li>
</ul>
<p>但如果我们在多个对象上重复这个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">    objs[i] = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1 偏向所有对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : objs) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2 访问这些对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : objs) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;&#125; <span class="comment">// 第 1~20 次撤销，第 20 次触发批量重偏向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>这时：</p>
<ul>
<li>到第 20 次撤销时，JVM 发现这是同一个类的对象；</li>
<li>触发 <strong>批量重偏向</strong>，把这一类对象全部偏向 T2；</li>
<li>后续访问就都可以使用偏向锁了。</li>
</ul>
<hr>
<h2 id="📌-总结一下关键区别："><a href="#📌-总结一下关键区别：" class="headerlink" title="📌 总结一下关键区别："></a>📌 总结一下关键区别：</h2><table>
<thead>
<tr>
<th>类型</th>
<th>是否需要达到撤销阈值</th>
<th>是否适用于单个对象</th>
<th>是否适用于多个对象</th>
</tr>
</thead>
<tbody><tr>
<td>单次重偏向</td>
<td>❌ 不需要</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td>批量重偏向</td>
<td>✅ 需要（默认 20 次）</td>
<td>❌ 否</td>
<td>✅ 是</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-最后总结一句话："><a href="#✅-最后总结一句话：" class="headerlink" title="✅ 最后总结一句话："></a>✅ 最后总结一句话：</h2><blockquote>
<p><strong>JVM 并不是必须等到 20 次撤销才允许重新偏向，而是在无竞争的情况下，也可以让单个对象从 neutral bias 状态重新偏向新的线程。不过这种“单次重偏向”是有条件的，且优先级低于批量重偏向。</strong></p>
</blockquote>
<p>这样设计的目的是：</p>
<ul>
<li><strong>避免不必要的锁升级</strong></li>
<li><strong>减少 STW 次数</strong></li>
<li><strong>保持偏向锁的灵活性和高效性</strong></li>
</ul>
<hr>
<h2 id="如果如果t2-撤销了t1的偏向，然后会进行一个单对象偏向-并计数，如果后面这个对象又被t1-请求了，t1会撤销t2的偏向，单对象偏向到t1-并计数。这个理解对吧"><a href="#如果如果t2-撤销了t1的偏向，然后会进行一个单对象偏向-并计数，如果后面这个对象又被t1-请求了，t1会撤销t2的偏向，单对象偏向到t1-并计数。这个理解对吧" class="headerlink" title="如果如果t2 撤销了t1的偏向，然后会进行一个单对象偏向 并计数，如果后面这个对象又被t1 请求了，t1会撤销t2的偏向，单对象偏向到t1. 并计数。这个理解对吧"></a>如果如果t2 撤销了t1的偏向，然后会进行一个单对象偏向 并计数，如果后面这个对象又被t1 请求了，t1会撤销t2的偏向，单对象偏向到t1. 并计数。这个理解对吧</h2><p>你这个问题非常深刻，已经触及了 <strong>偏向锁机制中最核心、最容易被误解的部分</strong> —— 偏向锁的 <strong>单对象重偏向行为</strong> 和 <strong>撤销计数器机制</strong>。</p>
<hr>
<h2 id="✅-你的理解总结如下："><a href="#✅-你的理解总结如下：" class="headerlink" title="✅ 你的理解总结如下："></a>✅ 你的理解总结如下：</h2><blockquote>
<p>T2 撤销了 T1 的偏向锁后，如果无竞争，可以对该对象重新偏向自己（T2），并记录一次撤销；<br>后续 T1 又访问该对象时，又会撤销 T2 的偏向，并偏向回 T1，再次记录一次撤销；<br>这样来回切换，每撤销一次都会计入类撤销计数器中；<br>如果达到阈值（如 20 次），就会触发批量重偏向。</p>
</blockquote>
<hr>
<h2 id="✅-答案一句话总结："><a href="#✅-答案一句话总结：" class="headerlink" title="✅ 答案一句话总结："></a>✅ 答案一句话总结：</h2><blockquote>
<p><strong>基本正确！但有一些细节需要注意：</strong></p>
</blockquote>
<ul>
<li>单个对象确实可以在 T1 → T2 → T1 之间来回偏向；</li>
<li>但每次撤销都会增加 JVM 对这个类的撤销计数器；</li>
<li>当撤销次数达到一定阈值（默认 20）时，JVM 会触发 <strong>批量重偏向</strong>；</li>
<li>如果撤销频繁且并发严重，还可能直接进入 <strong>批量撤销（禁用偏向锁）</strong>。</li>
</ul>
<hr>
<h2 id="🧠-更详细解释"><a href="#🧠-更详细解释" class="headerlink" title="🧠 更详细解释"></a>🧠 更详细解释</h2><h3 id="📌-1-偏向锁是“线程-epoch”绑定的"><a href="#📌-1-偏向锁是“线程-epoch”绑定的" class="headerlink" title="📌 1. 偏向锁是“线程 + epoch”绑定的"></a>📌 1. 偏向锁是“线程 + epoch”绑定的</h3><p>JVM 中每个偏向锁信息不仅包含线程 ID，还包括一个叫 <strong>epoch</strong> 的时间戳字段（用于判断偏向是否过期）。</p>
<p>当发生以下情况之一时，对象会被撤销偏向：</p>
<ul>
<li>另一个线程尝试获取锁；</li>
<li>调用了 <code>hashCode()</code>；</li>
<li>发生了 GC（偏向锁需要重新验证有效性）；</li>
</ul>
<hr>
<h3 id="📌-2-单个对象可以反复偏向不同线程"><a href="#📌-2-单个对象可以反复偏向不同线程" class="headerlink" title="📌 2. 单个对象可以反复偏向不同线程"></a>📌 2. 单个对象可以反复偏向不同线程</h3><p>这是 JVM 的一种优化策略，称为 <strong>延迟偏向（Delayed Biased Locking）</strong> 或 <strong>可恢复偏向（Rebiasable Bias）</strong>。</p>
<h4 id="示例流程："><a href="#示例流程：" class="headerlink" title="示例流程："></a>示例流程：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1 获取锁 → obj 被偏向 T1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2 获取锁 → 撤销 T1 的偏向，obj 被偏向 T2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1 再次获取锁 → 撤销 T2 的偏向，obj 被偏向 T1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>在这个过程中：</p>
<ul>
<li>obj 在 T1 ↔ T2 之间来回偏向；</li>
<li>每次撤销都会触发一次 Safepoint；</li>
<li>并且每次撤销都会增加该类的撤销计数器；</li>
<li>如果这类对象的撤销总数达到了 20 次，就会触发 <strong>批量重偏向</strong>。</li>
</ul>
<hr>
<h3 id="📌-3-类撤销计数器的作用"><a href="#📌-3-类撤销计数器的作用" class="headerlink" title="📌 3. 类撤销计数器的作用"></a>📌 3. 类撤销计数器的作用</h3><p>JVM 不是对每个对象单独统计撤销次数，而是对<strong>类（class）级别</strong>进行统计。例如：</p>
<ul>
<li>所有 <code>MyClass</code> 的实例共用一个撤销计数器；</li>
<li>每次某个 <code>MyClass</code> 实例发生偏向锁撤销，这个计数器就加一；</li>
<li>达到阈值后（默认 20），JVM 觉得这些对象经常被多个线程交替使用；</li>
<li>就会统一将这批对象偏向当前线程（即批量重偏向）；</li>
<li>如果撤销特别多（比如 40 次），JVM 甚至会直接禁用该类的偏向锁。</li>
</ul>
<hr>
<h2 id="📈-撤销计数器与偏向锁状态变化的关系"><a href="#📈-撤销计数器与偏向锁状态变化的关系" class="headerlink" title="📈 撤销计数器与偏向锁状态变化的关系"></a>📈 撤销计数器与偏向锁状态变化的关系</h2><table>
<thead>
<tr>
<th>撤销次数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; 20</td>
<td>允许单个对象重新偏向新线程；不触发批量操作</td>
</tr>
<tr>
<td>&#x3D;&#x3D; 20</td>
<td>第一次触发批量重偏向（Bulk Rebiasing）</td>
</tr>
<tr>
<td>&gt; 20</td>
<td>已经处于批量重偏向状态，后续对象偏向当前线程</td>
</tr>
<tr>
<td>&gt;&#x3D; 40</td>
<td>触发批量撤销（Bulk Revocation），禁用该类的偏向锁</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚙️-补充说明：为什么允许单对象重偏向？"><a href="#⚙️-补充说明：为什么允许单对象重偏向？" class="headerlink" title="⚙️ 补充说明：为什么允许单对象重偏向？"></a>⚙️ 补充说明：为什么允许单对象重偏向？</h2><p>JVM 的设计哲学是：“<strong>只有真正需要的时候才做昂贵的操作</strong>”。</p>
<p>所以即使发生了几次撤销，只要还没达到批量阈值，JVM 就不会贸然升级为轻量级锁或重量级锁，而是先尝试让对象继续使用偏向锁机制。</p>
<p>这在一些线程交替使用的场景下非常有用，比如：</p>
<ul>
<li>线程池中的线程轮流执行任务；</li>
<li>多个消费者轮询同一个队列等。</li>
</ul>
<hr>
<h2 id="✅-总结一下你的理解是否正确："><a href="#✅-总结一下你的理解是否正确：" class="headerlink" title="✅ 总结一下你的理解是否正确："></a>✅ 总结一下你的理解是否正确：</h2><table>
<thead>
<tr>
<th>说法</th>
<th>是否准确</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T2 撤销 T1 的偏向锁后，可以重新偏向自己</td>
<td>✅ 正确</td>
<td>如果无竞争，允许单对象重新偏向</td>
</tr>
<tr>
<td>T1 再次访问时，又能撤销 T2 的偏向</td>
<td>✅ 正确</td>
<td>如果无竞争，允许再次偏向 T1</td>
</tr>
<tr>
<td>每次撤销都会计入类的撤销计数器</td>
<td>✅ 正确</td>
<td>是的，用于触发批量重偏向&#x2F;撤销</td>
</tr>
<tr>
<td>达到 20 次会触发批量重偏向</td>
<td>✅ 正确</td>
<td>默认阈值是 20，触发批量重偏向</td>
</tr>
</tbody></table>
<hr>
<h2 id="💡-推荐实践建议"><a href="#💡-推荐实践建议" class="headerlink" title="💡 推荐实践建议"></a>💡 推荐实践建议</h2><p>如果你在开发中遇到以下情况：</p>
<ul>
<li>锁对象被多个线程交替访问；</li>
<li>频繁发生偏向锁撤销；</li>
<li>GC 日志中出现大量 Safepoint 操作；</li>
</ul>
<p>你可以考虑：</p>
<ul>
<li>使用 <code>-XX:-UseBiasedLocking</code> 关闭偏向锁（适用于高并发服务）；</li>
<li>或者调整撤销阈值（仅调试用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingBulkRebiasThreshold=20</span><br><span class="line">-XX:BiasedLockingBulkRevokeThreshold=40</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>在偏向锁的设计中，<strong>线程B如何判断线程A是否已经执行完同步代码（释放锁）</strong>，并不是通过主动通知或标记实现的，而是通过<strong>竞争时的锁撤销（Revoke）机制</strong>来处理的。以下是详细流程：</p>
<hr>
<h3 id="1-偏向锁的基本假设"><a href="#1-偏向锁的基本假设" class="headerlink" title="1. 偏向锁的基本假设"></a><strong>1. 偏向锁的基本假设</strong></h3><p>偏向锁的核心思想是：<br><strong>“锁通常只会被同一个线程重复获取，其他线程的竞争是罕见的”</strong>。<br>因此：</p>
<ul>
<li>线程A获取偏向锁后，退出同步块时<strong>不会主动清除Mark Word中的线程ID</strong>（即不会“显式释放”锁）。</li>
<li>线程B在尝试获取锁时，需要<strong>被动触发检查</strong>，来判断线程A是否仍持有锁。</li>
</ul>
<hr>
<h3 id="2-线程B如何检测线程A是否释放锁？"><a href="#2-线程B如何检测线程A是否释放锁？" class="headerlink" title="2. 线程B如何检测线程A是否释放锁？"></a><strong>2. 线程B如何检测线程A是否释放锁？</strong></h3><p>当线程B尝试获取一个已偏向线程A的锁时，JVM会执行以下步骤：</p>
<h4 id="步骤1：检查Mark-Word的线程ID"><a href="#步骤1：检查Mark-Word的线程ID" class="headerlink" title="步骤1：检查Mark Word的线程ID"></a><strong>步骤1：检查Mark Word的线程ID</strong></h4><ul>
<li>线程B读取对象的Mark Word，发现线程ID指向线程A（而非自己）。</li>
<li>此时，JVM需要判断线程A是否仍“逻辑上”持有锁。</li>
</ul>
<h4 id="步骤2：触发偏向锁撤销（Revoke）"><a href="#步骤2：触发偏向锁撤销（Revoke）" class="headerlink" title="步骤2：触发偏向锁撤销（Revoke）"></a><strong>步骤2：触发偏向锁撤销（Revoke）</strong></h4><p>JVM会暂停线程A（通过安全点，SafePoint），并检查线程A的执行状态：</p>
<ol>
<li><p><strong>如果线程A已退出同步块</strong>（即“释放锁”）：  </p>
<ul>
<li>线程A的栈帧中<strong>没有该对象的锁记录</strong>（Lock Record）。  </li>
<li>JVM会将对象<strong>重置为匿名偏向状态</strong>（线程ID清零，标志位保持<code>101</code>）。  </li>
<li>线程B可以尝试<strong>重新偏向</strong>（CAS将自己的线程ID写入Mark Word）。</li>
</ul>
</li>
<li><p><strong>如果线程A仍在同步块中</strong>（即“未释放锁”）：  </p>
<ul>
<li>线程A的栈帧中存在该对象的锁记录。  </li>
<li>JVM会<strong>撤销偏向锁</strong>，将锁升级为<strong>轻量级锁</strong>：  <ul>
<li>将Mark Word复制到线程A的锁记录中（Displaced Mark Word）。  </li>
<li>用CAS将Mark Word替换为指向锁记录的指针（轻量级锁状态）。</li>
</ul>
</li>
<li>线程B会<strong>通过自旋尝试竞争轻量级锁</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-关键问题：如何知道线程A是否退出同步块？"><a href="#3-关键问题：如何知道线程A是否退出同步块？" class="headerlink" title="3. 关键问题：如何知道线程A是否退出同步块？"></a><strong>3. 关键问题：如何知道线程A是否退出同步块？</strong></h3><ul>
<li>JVM通过遍历线程A的栈帧，检查是否存在该对象的锁记录：  <ul>
<li><strong>存在锁记录</strong> → 线程A仍在同步块中（未释放锁）。  </li>
<li><strong>不存在锁记录</strong> → 线程A已退出同步块（已释放锁）。</li>
</ul>
</li>
</ul>
<h4 id="为什么需要暂停线程A（STW）？"><a href="#为什么需要暂停线程A（STW）？" class="headerlink" title="为什么需要暂停线程A（STW）？"></a><strong>为什么需要暂停线程A（STW）？</strong></h4><ul>
<li>如果不暂停线程A，可能在检查过程中线程A恰好退出同步块，导致误判。  </li>
<li>通过安全点（SafePoint）暂停线程A，可以确保检查期间线程A的状态稳定。</li>
</ul>
<hr>
<h3 id="4-流程图"><a href="#4-流程图" class="headerlink" title="4. 流程图"></a><strong>4. 流程图</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程B尝试获取偏向锁:</span><br><span class="line"><span class="number">1.</span> 读取Mark Word → 发现偏向线程A</span><br><span class="line">   │</span><br><span class="line">   ├── 线程A已退出同步块? (无锁记录)</span><br><span class="line">   │   │</span><br><span class="line">   │   ├── 是 → 撤销偏向锁，对象重置为匿名偏向状态 → 线程B尝试重新偏向</span><br><span class="line">   │   │</span><br><span class="line">   │   └── 否 → 升级为轻量级锁 → 线程B自旋竞争</span><br><span class="line">   │</span><br><span class="line">   └── 如果撤销次数超过阈值 → 触发批量重偏向或批量撤销</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-性能优化：批量重偏向与撤销"><a href="#5-性能优化：批量重偏向与撤销" class="headerlink" title="5. 性能优化：批量重偏向与撤销"></a><strong>5. 性能优化：批量重偏向与撤销</strong></h3><ul>
<li><strong>批量重偏向（Bulk Rebias）</strong>：<br>如果同一个类的偏向锁被频繁撤销（默认20次），JVM会认为“线程A可能不再需要偏向锁”，允许该类的对象直接偏向新的线程（线程B），而无需每次撤销。  </li>
<li><strong>批量撤销（Bulk Revoke）</strong>：<br>如果撤销次数更高（默认40次），JVM会彻底禁用该类的偏向锁，后续所有实例直接使用轻量级锁。</li>
</ul>
<hr>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ul>
<li><strong>偏向锁的释放是隐式的</strong>：线程A退出同步块后，不会主动修改Mark Word。  </li>
<li><strong>线程B通过触发撤销机制检测锁状态</strong>：  <ul>
<li>暂停线程A → 检查栈帧中的锁记录 → 判断线程A是否释放锁。</li>
</ul>
</li>
<li><strong>升级策略</strong>：  <ul>
<li>无竞争：保持偏向或重新偏向。  </li>
<li>有竞争：升级为轻量级锁。</li>
</ul>
</li>
</ul>
<p>这种机制在无竞争场景下避免了同步开销，而在竞争发生时通过撤销和升级保证正确性。</p>
<p>是的，你的理解是正确的！  </p>
<h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><p><strong>如果线程A已经释放了锁（退出同步代码块），那么它的栈帧中对应的 <code>Lock Record</code> 就会被移除</strong>。此时，其他线程（如线程B）在尝试获取锁时，JVM会通过检查线程A的栈帧，确认是否存在该对象的 <code>Lock Record</code>：  </p>
<ul>
<li><strong>不存在 <code>Lock Record</code></strong> → 线程A已释放锁，对象可重新偏向或升级为轻量级锁。  </li>
<li><strong>存在 <code>Lock Record</code></strong> → 线程A仍持有锁，触发锁升级（轻量级锁&#x2F;重量级锁）。</li>
</ul>
<hr>
<h3 id="详细流程分析"><a href="#详细流程分析" class="headerlink" title="详细流程分析"></a><strong>详细流程分析</strong></h3><h4 id="1-偏向锁场景下-Lock-Record-的作用"><a href="#1-偏向锁场景下-Lock-Record-的作用" class="headerlink" title="1. 偏向锁场景下 Lock Record 的作用"></a><strong>1. 偏向锁场景下 <code>Lock Record</code> 的作用</strong></h4><ul>
<li><p><strong>获取偏向锁时</strong>：  </p>
<ul>
<li>线程A首次进入同步块时，JVM会在其栈帧中创建一个 <code>Lock Record</code>，用于存储锁对象的信息（即使偏向锁不严格需要它，但JVM仍会生成一个空的 <code>Lock Record</code> 作为标记）。  </li>
<li>如果后续没有竞争，线程A再次进入同步块时，只需检查 <code>Mark Word</code> 中的线程ID，无需操作 <code>Lock Record</code>。</li>
</ul>
</li>
<li><p><strong>释放偏向锁时</strong>：  </p>
<ul>
<li>线程A退出同步块后，<strong><code>Lock Record</code> 会被立即移除</strong>（栈帧弹出或复用）。  </li>
<li>但对象的 <code>Mark Word</code> <strong>仍然保持偏向线程A的状态</strong>（不会主动清除线程ID）。</li>
</ul>
</li>
</ul>
<h4 id="2-线程B如何检测锁是否释放？"><a href="#2-线程B如何检测锁是否释放？" class="headerlink" title="2. 线程B如何检测锁是否释放？"></a><strong>2. 线程B如何检测锁是否释放？</strong></h4><p>当线程B尝试获取已被线程A偏向的锁时：  </p>
<ol>
<li>JVM会暂停线程A（SafePoint），检查线程A的栈帧：  <ul>
<li><strong>如果找不到该对象的 <code>Lock Record</code></strong>：  <ul>
<li>说明线程A已释放锁，JVM会将对象<strong>重置为匿名偏向状态</strong>（允许线程B重新偏向）。</li>
</ul>
</li>
<li><strong>如果找到 <code>Lock Record</code></strong>：  <ul>
<li>说明线程A仍持有锁，JVM会<strong>撤销偏向锁</strong>，升级为轻量级锁（通过CAS竞争）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-轻量级锁场景下的-Lock-Record"><a href="#3-轻量级锁场景下的-Lock-Record" class="headerlink" title="3. 轻量级锁场景下的 Lock Record"></a><strong>3. 轻量级锁场景下的 <code>Lock Record</code></strong></h4><ul>
<li>轻量级锁的 <code>Lock Record</code> 会明确存储对象的 <code>Displaced Mark Word</code>（原对象头的拷贝）。  </li>
<li>释放轻量级锁时，JVM会<strong>将 <code>Displaced Mark Word</code> 还原回对象头</strong>，并清除栈帧中的 <code>Lock Record</code>。</li>
</ul>
<hr>
<h3 id="为什么偏向锁不立即清除-Mark-Word-的线程ID？"><a href="#为什么偏向锁不立即清除-Mark-Word-的线程ID？" class="headerlink" title="为什么偏向锁不立即清除 Mark Word 的线程ID？"></a><strong>为什么偏向锁不立即清除 <code>Mark Word</code> 的线程ID？</strong></h3><ul>
<li><strong>性能优化</strong>：偏向锁假设“线程A可能会重复获取锁”，保留偏向状态可以避免下次获取时的CAS操作。  </li>
<li><strong>懒清除</strong>：只有发生竞争时，才通过撤销机制清除或升级锁状态。</li>
</ul>
<hr>
<h3 id="示例代码与内存变化"><a href="#示例代码与内存变化" class="headerlink" title="示例代码与内存变化"></a><strong>示例代码与内存变化</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// Mark Word: 匿名偏向 (101)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A进入同步块</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">    <span class="comment">// 1. 偏向线程A，栈帧中生成 Lock Record（可能为空）</span></span><br><span class="line">    <span class="comment">// 2. Mark Word 更新为线程A ID (101 + threadA ID)</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 线程A退出同步块：</span></span><br><span class="line"><span class="comment">// - Lock Record 被移除</span></span><br><span class="line"><span class="comment">// - Mark Word 仍保留线程A ID（但锁已逻辑释放）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B尝试获取锁：</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">    <span class="comment">// 触发偏向锁撤销：</span></span><br><span class="line">    <span class="comment">// 1. 检查线程A的栈帧，发现无 Lock Record → 锁已释放</span></span><br><span class="line">    <span class="comment">// 2. 重置为匿名偏向或升级为轻量级锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th><code>Lock Record</code> 状态</th>
<th>锁状态变化</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程A持有偏向锁</strong></td>
<td>存在（标记作用）</td>
<td>Mark Word 记录线程A ID</td>
</tr>
<tr>
<td><strong>线程A释放锁</strong></td>
<td><strong>被移除</strong></td>
<td>Mark Word 仍保留线程A ID，但锁已逻辑释放</td>
</tr>
<tr>
<td><strong>线程B竞争锁</strong></td>
<td>JVM检查线程A的栈帧，确认无记录</td>
<td>撤销偏向锁，重置或升级</td>
</tr>
</tbody></table>
<p>理解这一点对分析锁竞争、偏向锁撤销机制至关重要！</p>
<p>好的！<strong>轻量级锁的撤销过程</strong>是Java中锁机制的核心部分，它发生在多个线程竞争同一个锁时，JVM需要将轻量级锁升级为<strong>重量级锁</strong>（通过操作系统互斥量实现）。下面我会详细讲解整个过程，包括触发条件、具体步骤和底层实现。</p>
<hr>
<h2 id="1-轻量级锁的基本原理"><a href="#1-轻量级锁的基本原理" class="headerlink" title="1. 轻量级锁的基本原理"></a><strong>1. 轻量级锁的基本原理</strong></h2><p>在介绍撤销之前，先回顾轻量级锁的运行机制：</p>
<ul>
<li><strong>适用场景</strong>：<strong>低竞争</strong>环境（多个线程<strong>交替</strong>执行同步代码，但不会同时竞争）。</li>
<li><strong>加锁过程</strong>：<ol>
<li>线程A进入同步块时，JVM会在<strong>栈帧</strong>中创建一个<code>Lock Record</code>（锁记录），存储对象的<code>Mark Word</code>（称为<code>Displaced Mark Word</code>）。</li>
<li>通过<code>CAS</code>（Compare-And-Swap）尝试将对象的<code>Mark Word</code>替换为指向<code>Lock Record</code>的指针。</li>
<li>如果成功，线程A获得轻量级锁；如果失败（说明有竞争），进入<strong>锁膨胀</strong>流程。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-轻量级锁的撤销（升级为重量级锁）"><a href="#2-轻量级锁的撤销（升级为重量级锁）" class="headerlink" title="2. 轻量级锁的撤销（升级为重量级锁）"></a><strong>2. 轻量级锁的撤销（升级为重量级锁）</strong></h2><p>当多个线程竞争同一个轻量级锁时，JVM会触发<strong>锁膨胀（Lock Inflation）</strong>，将轻量级锁升级为重量级锁。具体流程如下：</p>
<h3 id="2-1-触发条件"><a href="#2-1-触发条件" class="headerlink" title="2.1 触发条件"></a><strong>2.1 触发条件</strong></h3><ul>
<li><strong>CAS失败</strong>：线程B尝试获取锁时，发现<code>Mark Word</code>已经指向线程A的<code>Lock Record</code>（说明线程A持有锁）。</li>
<li><strong>自旋失败</strong>：线程B会进行短时间的<strong>自旋</strong>（默认10次，可通过<code>-XX:PreBlockSpin</code>调整），如果自旋后仍未获得锁，触发锁膨胀。</li>
</ul>
<h3 id="2-2-撤销流程"><a href="#2-2-撤销流程" class="headerlink" title="2.2 撤销流程"></a><strong>2.2 撤销流程</strong></h3><ol>
<li><p><strong>JVM分配一个<code>Monitor</code>对象（重量级锁的核心结构）</strong>  </p>
<ul>
<li>每个Java对象在锁膨胀后都会关联一个<code>Monitor</code>（也称为管程或互斥锁）。</li>
<li><code>Monitor</code>包含：<ul>
<li><code>Owner</code>：持有锁的线程（如线程A）。</li>
<li><code>EntryList</code>：竞争锁的阻塞线程队列（如线程B）。</li>
<li><code>WaitSet</code>：调用<code>wait()</code>的线程队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>修改<code>Mark Word</code>，指向<code>Monitor</code>对象</strong>  </p>
<ul>
<li>对象的<code>Mark Word</code>会被更新为指向<code>Monitor</code>的指针（标志位变为<code>10</code>，表示重量级锁）。</li>
<li>线程A的<code>Displaced Mark Word</code>（原对象头）会被存入<code>Monitor</code>。</li>
</ul>
</li>
<li><p><strong>线程B进入阻塞状态</strong>  </p>
<ul>
<li>线程B尝试获取锁时，发现锁已被升级为重量级锁，会进入<code>EntryList</code>，等待操作系统调度（可能被挂起）。</li>
</ul>
</li>
<li><p><strong>线程A释放锁</strong>  </p>
<ul>
<li>线程A退出同步块时，会调用<code>monitorexit</code>指令：<ul>
<li>如果<code>EntryList</code>为空（无竞争），<code>Monitor</code>的<code>Owner</code>被置为<code>null</code>。</li>
<li>如果<code>EntryList</code>不为空（如线程B在等待），唤醒一个线程（线程B）来竞争锁。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-轻量级锁-vs-重量级锁"><a href="#3-轻量级锁-vs-重量级锁" class="headerlink" title="3. 轻量级锁 vs 重量级锁"></a><strong>3. 轻量级锁 vs 重量级锁</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>轻量级锁</strong></th>
<th><strong>重量级锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现方式</strong></td>
<td>CAS + 栈帧<code>Lock Record</code></td>
<td>操作系统<code>Mutex</code> + <code>Monitor</code></td>
</tr>
<tr>
<td><strong>竞争处理</strong></td>
<td>自旋（少量CAS）</td>
<td>线程阻塞（内核态调度）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>低竞争（线程交替执行）</td>
<td>高竞争（多线程同时抢锁）</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>低（用户态操作）</td>
<td>高（涉及内核态切换）</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-示例代码分析"><a href="#4-示例代码分析" class="headerlink" title="4. 示例代码分析"></a><strong>4. 示例代码分析</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A获取轻量级锁</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">// 1. CAS成功，Mark Word指向Lock Record</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-A holds the lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125; <span class="comment">// 3. 释放锁（如果是轻量级锁，恢复Mark Word）</span></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B触发锁膨胀</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">// 2. CAS失败 → 自旋 → 锁膨胀 → 进入Monitor阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-B acquires the lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong>：</p>
<ol>
<li>线程A获取轻量级锁（CAS成功）。</li>
<li>线程B尝试CAS失败，自旋后仍无法获取，触发锁膨胀。</li>
<li>JVM分配<code>Monitor</code>，线程B进入<code>EntryList</code>阻塞。</li>
<li>线程A释放锁后，唤醒线程B。</li>
</ol>
<hr>
<h2 id="5-关键点总结"><a href="#5-关键点总结" class="headerlink" title="5. 关键点总结"></a><strong>5. 关键点总结</strong></h2><ol>
<li><strong>轻量级锁撤销的触发条件</strong>：CAS失败 + 自旋失败。</li>
<li><strong>升级为重量级锁的核心步骤</strong>：<ul>
<li>分配<code>Monitor</code>对象。</li>
<li>修改<code>Mark Word</code>指向<code>Monitor</code>。</li>
<li>竞争线程进入阻塞队列（<code>EntryList</code>）。</li>
</ul>
</li>
<li><strong>性能影响</strong>：锁膨胀后，线程切换涉及内核态调度，开销较大。</li>
</ol>
<p>通过这种方式，JVM在低竞争时使用轻量级锁（高效CAS），高竞争时退回到重量级锁（保证正确性）。</p>
<h2 id="精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析："><a href="#精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析：" class="headerlink" title="精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析："></a>精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析：</h2><hr>
<h3 id="关键结论-1"><a href="#关键结论-1" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><ol>
<li><strong>线程A不会“归还失败”</strong>，而是<strong>线程B的CAS竞争失败</strong>后触发锁膨胀。  </li>
<li>**轻量级锁的撤销（即升级为重量级锁）**是由竞争线程（线程B）发起的，而非持有锁的线程（线程A）。  </li>
<li>最终所有线程（包括线程A）都会切换到重量级锁模式，由<code>Monitor</code>统一管理。</li>
</ol>
<hr>
<h3 id="完整流程分析"><a href="#完整流程分析" class="headerlink" title="完整流程分析"></a><strong>完整流程分析</strong></h3><h4 id="1-初始状态（线程A持有轻量级锁）"><a href="#1-初始状态（线程A持有轻量级锁）" class="headerlink" title="1. 初始状态（线程A持有轻量级锁）"></a><strong>1. 初始状态（线程A持有轻量级锁）</strong></h4><ul>
<li>线程A通过CAS成功将对象的<code>Mark Word</code>替换为指向自己栈帧中<code>Lock Record</code>的指针。  </li>
<li>此时对象头存储的是<strong>轻量级锁状态</strong>（标志位<code>00</code> + 指向<code>Lock Record</code>的指针）。</li>
</ul>
<h4 id="2-线程B尝试获取锁（触发锁膨胀）"><a href="#2-线程B尝试获取锁（触发锁膨胀）" class="headerlink" title="2. 线程B尝试获取锁（触发锁膨胀）"></a><strong>2. 线程B尝试获取锁（触发锁膨胀）</strong></h4><p>当线程B尝试通过CAS竞争锁时：  </p>
<ol>
<li><strong>CAS失败</strong>：发现<code>Mark Word</code>已被线程A占用（指向线程A的<code>Lock Record</code>）。  </li>
<li><strong>自旋优化</strong>：线程B短暂自旋（默认10次），尝试等待线程A释放锁。  <ul>
<li>如果自旋期间线程A释放了锁，线程B会成功获取轻量级锁。  </li>
<li><strong>如果自旋失败</strong>，JVM开始<strong>锁膨胀</strong>流程。</li>
</ul>
</li>
</ol>
<h4 id="3-锁膨胀（升级为重量级锁）"><a href="#3-锁膨胀（升级为重量级锁）" class="headerlink" title="3. 锁膨胀（升级为重量级锁）"></a><strong>3. 锁膨胀（升级为重量级锁）</strong></h4><ol>
<li><strong>JVM分配一个<code>Monitor</code>对象</strong>（重量级锁的核心结构）。  </li>
<li><strong>修改对象头</strong>：  <ul>
<li>将<code>Mark Word</code>更新为指向<code>Monitor</code>的指针（标志位变为<code>10</code>）。  </li>
<li>线程A的<code>Displaced Mark Word</code>（原对象头）会被存入<code>Monitor</code>。</li>
</ul>
</li>
<li><strong>线程A释放锁时</strong>：  <ul>
<li>发现对象已升级为重量级锁，会调用<code>monitorexit</code>指令，将<code>Monitor</code>的<code>Owner</code>置为<code>null</code>，并唤醒<code>EntryList</code>中的阻塞线程（如线程B）。</li>
</ul>
</li>
<li><strong>线程B进入阻塞队列</strong>：  <ul>
<li>线程B在锁膨胀后，会直接进入<code>Monitor</code>的<code>EntryList</code>，等待操作系统调度（可能被挂起）。</li>
</ul>
</li>
</ol>
<h4 id="4-关键点澄清"><a href="#4-关键点澄清" class="headerlink" title="4. 关键点澄清"></a><strong>4. 关键点澄清</strong></h4><ul>
<li><strong>线程A的“归还”不会失败</strong>：  <ul>
<li>线程A释放锁时，如果锁尚未膨胀，会正常恢复<code>Displaced Mark Word</code>（轻量级锁流程）。  </li>
<li>如果锁已膨胀，线程A会走重量级锁的释放流程（操作<code>Monitor</code>）。</li>
</ul>
</li>
<li><strong>锁膨胀的触发者是竞争线程（线程B）</strong>，而非持有线程（线程A）。</li>
</ul>
<hr>
<h3 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a><strong>流程图解</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程A获取轻量级锁：</span><br><span class="line">1. CAS成功，Mark Word → 指向线程A的Lock Record（00）</span><br><span class="line">   │</span><br><span class="line">   └─ 线程B尝试获取锁：</span><br><span class="line">      ├─ CAS失败 → 自旋 → 仍失败 → 触发锁膨胀</span><br><span class="line">      │    │</span><br><span class="line">      │    ├─ JVM分配Monitor</span><br><span class="line">      │    ├─ Mark Word → 指向Monitor（10）</span><br><span class="line">      │    └─ 线程B进入EntryList阻塞</span><br><span class="line">      │</span><br><span class="line">      └─ 线程A释放锁：</span><br><span class="line">           ├─ 若未膨胀：恢复Displaced Mark Word（轻量级锁）</span><br><span class="line">           └─ 若已膨胀：调用monitorexit，唤醒EntryList线程</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="为什么需要重量级锁？"><a href="#为什么需要重量级锁？" class="headerlink" title="为什么需要重量级锁？"></a><strong>为什么需要重量级锁？</strong></h3><ul>
<li><strong>轻量级锁的局限性</strong>：依赖自旋，高竞争时浪费CPU资源。  </li>
<li><strong>重量级锁的优势</strong>：通过操作系统<code>Mutex</code>实现线程阻塞&#x2F;唤醒，避免空转。</li>
</ul>
<hr>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>阶段</th>
<th>线程A（持有锁）</th>
<th>线程B（竞争锁）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>轻量级锁阶段</strong></td>
<td>CAS成功，Mark Word指向Lock Record</td>
<td>CAS失败，自旋</td>
</tr>
<tr>
<td><strong>锁膨胀触发</strong></td>
<td>无操作</td>
<td>自旋失败，发起锁膨胀</td>
</tr>
<tr>
<td><strong>重量级锁阶段</strong></td>
<td>释放时操作Monitor</td>
<td>进入EntryList阻塞</td>
</tr>
</tbody></table>
<p>通过这种机制，JVM在低竞争时保持高效（轻量级锁），高竞争时退回到安全模式（重量级锁）。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p><strong>锁消除（Lock Elimination）</strong> 是 JVM 在 <strong>JIT 编译阶段</strong> 进行的一种 <strong>同步优化技术</strong>，属于 <strong>逃逸分析（Escape Analysis）</strong> 的一部分。</p>
<p>它的目标是：  </p>
<blockquote>
<p><strong>如果一个对象不会被其他线程访问到（即没有线程竞争），那么即使代码中使用了 <code>synchronized</code>，JVM 也可以将这个锁“消除掉”，从而避免不必要的同步开销。</strong></p>
</blockquote>
<hr>
<h2 id="🧠-锁消除的本质"><a href="#🧠-锁消除的本质" class="headerlink" title="🧠 锁消除的本质"></a>🧠 锁消除的本质</h2><p>Java 中的 <code>synchronized</code> 是一种安全但有代价的机制。它会带来：</p>
<ul>
<li>对象头 Mark Word 的修改；</li>
<li>CAS 操作或 Monitor 获取；</li>
<li>可能的上下文切换、线程挂起和唤醒；</li>
</ul>
<p>但在很多场景下，这些同步操作其实是<strong>不必要的</strong>，因为：</p>
<ul>
<li>对象只在当前线程内部使用；</li>
<li>方法虽然用了 <code>synchronized</code>，但根本没有并发访问；</li>
<li>甚至只是临时变量，根本不可能“逃逸”出当前线程。</li>
</ul>
<p>在这种情况下，JVM 就可以通过 <strong>锁消除</strong> 技术，把无意义的同步操作去掉，提升性能。</p>
<hr>
<h2 id="🔍-锁消除的前提：逃逸分析（Escape-Analysis）"><a href="#🔍-锁消除的前提：逃逸分析（Escape-Analysis）" class="headerlink" title="🔍 锁消除的前提：逃逸分析（Escape Analysis）"></a>🔍 锁消除的前提：逃逸分析（Escape Analysis）</h2><p>锁消除依赖于 <strong>逃逸分析（Escape Analysis）</strong>，它是 JVM 的一种分析技术，用来判断一个对象是否会被多个线程访问。</p>
<h3 id="逃逸分析的三种状态："><a href="#逃逸分析的三种状态：" class="headerlink" title="逃逸分析的三种状态："></a>逃逸分析的三种状态：</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>不逃逸（No Escape）</td>
<td>对象仅在当前方法或线程中使用，不会被外部访问</td>
</tr>
<tr>
<td>方法逃逸（Arg Escape）</td>
<td>对象作为参数传递给其他方法，可能被其他线程访问</td>
</tr>
<tr>
<td>线程逃逸（Global Escape）</td>
<td>对象被发布到全局变量、静态变量或其它线程可见的地方</td>
</tr>
</tbody></table>
<p>只有当对象是 <strong>不逃逸（No Escape）</strong> 时，JVM 才有可能进行锁消除。</p>
<hr>
<h2 id="🧪-示例说明-1"><a href="#🧪-示例说明-1" class="headerlink" title="🧪 示例说明"></a>🧪 示例说明</h2><h3 id="示例-1：锁可以被消除的情况"><a href="#示例-1：锁可以被消除的情况" class="headerlink" title="示例 1：锁可以被消除的情况"></a>示例 1：锁可以被消除的情况</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 只在当前线程使用 obj，不会被其他线程访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;in synchronized block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>obj</code> 是局部变量；</li>
<li>没有把它传给其他线程；</li>
<li>它的作用域只在当前方法中；</li>
<li>所以它是 <strong>不逃逸对象</strong>；</li>
<li>JVM 可以进行 <strong>锁消除</strong>，直接去掉 <code>synchronized</code> 块带来的同步开销。</li>
</ul>
<h3 id="示例-2：锁不能被消除的情况"><a href="#示例-2：锁不能被消除的情况" class="headerlink" title="示例 2：锁不能被消除的情况"></a>示例 2：锁不能被消除的情况</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// obj 是类成员变量，可能被其他线程访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>obj</code> 是类成员变量；</li>
<li>其他线程可能通过 <code>someOtherMethod()</code> 访问它；</li>
<li>所以它 <strong>逃逸出了当前方法</strong>；</li>
<li>JVM <strong>不能进行锁消除</strong>，必须保留同步逻辑。</li>
</ul>
<hr>
<h2 id="⚙️-如何开启锁消除？"><a href="#⚙️-如何开启锁消除？" class="headerlink" title="⚙️ 如何开启锁消除？"></a>⚙️ 如何开启锁消除？</h2><p>锁消除默认在 <strong>Server 模式下的 HotSpot JVM</strong> 中是开启的，前提是启用了逃逸分析。</p>
<p>你可以通过以下 JVM 参数来控制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis     <span class="comment"># 默认开启（Java 6u23+）</span></span><br><span class="line">-XX:+EliminateLocks       <span class="comment"># 开启锁消除（默认开启）</span></span><br></pre></td></tr></table></figure>

<p>如果你希望禁用锁消除（比如为了测试）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-EliminateLocks</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📈-性能影响与适用场景"><a href="#📈-性能影响与适用场景" class="headerlink" title="📈 性能影响与适用场景"></a>📈 性能影响与适用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>是否适合锁消除</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>大量使用局部变量加锁</td>
<td>✅ 非常适合</td>
<td>如 <code>new Object()</code> 作为锁对象</td>
</tr>
<tr>
<td>使用 <code>StringBuffer</code>（内部用 <code>synchronized</code>）</td>
<td>✅ 适合</td>
<td>如果作用域小且不逃逸</td>
</tr>
<tr>
<td>使用 <code>Vector</code> 或 <code>Hashtable</code></td>
<td>⚠️ 视情况而定</td>
<td>如果它们不逃逸，也可能被优化</td>
</tr>
<tr>
<td>多线程共享对象加锁</td>
<td>❌ 不适合</td>
<td>必须保留锁机制</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-总结一句话：-3"><a href="#✅-总结一句话：-3" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><strong>锁消除是 JVM 利用逃逸分析技术，在编译期识别并移除那些实际上不存在并发竞争的同步操作，从而减少不必要的锁开销，提高程序执行效率的一种优化手段。</strong></p>
</blockquote>
<hr>
<p><code>wait()</code> 和 <code>notify()</code> 是 Java 编程语言中用于线程间通信的两个方法，它们定义在 <code>Object</code> 类中。这两个方法允许线程在某个条件不满足时挂起自己，并在条件可能改变时通知其他线程重新检查条件。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p><strong><code>wait()</code></strong>：当一个线程调用一个对象的 <code>wait()</code> 方法时，它会释放该对象的锁并进入等待状态，直到另一个线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或者经过指定的时间（如果使用了带参数的 <code>wait(long timeout)</code> 方法）。</p>
</li>
<li><p><strong><code>notify()</code></strong>：唤醒在此对象监视器上等待的一个线程。选择是任意的，也就是说，JVM 会选择一个线程来唤醒。被唤醒的线程不能立即继续执行，因为它必须重新获取对象的锁，而这个锁可能已经被其他线程持有。</p>
</li>
<li><p><strong><code>notifyAll()</code></strong>：与 <code>notify()</code> 不同，<code>notifyAll()</code> 会唤醒所有在此对象监视器上等待的线程。这些线程将竞争对象的锁，只有获得锁的线程才能继续执行。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>wait()</code> 和 <code>notify()</code> 通常用于生产者-消费者模式、缓冲区满&#x2F;空的情况等需要线程协作的场景。例如，当一个线程需要等待某个特定条件成立时，它可以调用 <code>wait()</code>；而当另一个线程改变了这个条件并希望通知等待的线程时，它可以调用 <code>notify()</code> 或 <code>notifyAll()</code>。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个简单的例子，展示了如何使用 <code>wait()</code> 和 <code>notify()</code> 来实现两个线程之间的基本同步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123;</span><br><span class="line">            wait(); <span class="comment">// 如果资源已经存在，则生产者等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Producing...&quot;</span>);</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notify(); <span class="comment">// 通知消费者可以消费了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">            wait(); <span class="comment">// 如果资源不存在，消费者等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming...&quot;</span>);</span><br><span class="line">        available = <span class="literal">false</span>;</span><br><span class="line">        notify(); <span class="comment">// 通知生产者可以生产了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                resource.produce();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SharedResource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(SharedResource resource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                resource.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主类中启动线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(resource));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(resource));</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>SharedResource</code> 类代表共享资源，<code>produce()</code> 和 <code>consume()</code> 方法分别模拟生产和消费操作。每个方法都声明为 <code>synchronized</code> 以确保一次只有一个线程可以访问。当资源不可用时，相应的线程会调用 <code>wait()</code> 进入等待状态；当资源状态改变时，线程通过 <code>notify()</code> 来通知其他线程。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>必须从同步上下文中调用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>，即它们必须在由 <code>synchronized</code> 关键字保护的代码块或方法中被调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</p>
</li>
<li><p>调用 <code>wait()</code> 时应该总是放在循环中，而不是简单的 <code>if</code> 语句里，因为可能存在虚假唤醒（spurious wakeups）的情况，即没有收到通知的情况下线程也可能被唤醒。</p>
</li>
<li><p><code>notify()</code> 只唤醒一个等待的线程，但无法控制哪一个会被选中。如果你有多个线程在等待并且你需要精确控制哪个线程被唤醒，那么你可能需要更复杂的机制，如 <code>ReentrantLock</code> 和 <code>Condition</code> 对象。</p>
</li>
<li><p>由于 <code>notify()</code> 和 <code>wait()</code> 的行为可能会导致死锁或竞态条件，因此在设计多线程程序时要非常小心地处理这些问题。</p>
</li>
</ul>
<p>保护性暂停（Guarded Suspension）是一种设计模式，用于在多线程环境下控制线程的行为，确保某个线程在特定条件满足之前不会继续执行。这种模式通常用来解决线程之间的协作问题，比如生产者-消费者问题、读者-写者问题等。</p>
<h3 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h3><p>在保护性暂停模式中，一个线程会检查某个条件是否满足，如果条件不满足，则该线程会被挂起，直到另一个线程修改了这个条件并通知它继续执行。这种方式可以避免轮询带来的资源浪费，同时也能够确保只有在条件合适时才会进行相应的处理。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在Java中，实现保护性暂停模式可以通过<code>wait()</code>和<code>notify()</code>方法来完成，这两个方法定义在<code>Object</code>类中，用于线程间的通信。以下是一个简单的示例，展示了如何使用保护性暂停模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            notifyAll(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">remaining</span> <span class="operator">=</span> timeout - passedTime;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 超时退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(remaining);</span><br><span class="line">                passedTime = System.currentTimeMillis() - start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个模拟获取数据的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 假设需要3秒才能准备好数据</span></span><br><span class="line">                guardedObject.setResponse(<span class="string">&quot;Data is ready&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程尝试获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>); <span class="comment">// 等待最多5秒</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>GuardedObject</code> 类封装了一个对象 <code>response</code>，并通过 <code>get()</code> 方法实现了保护性暂停逻辑。当调用 <code>get()</code> 方法时，如果 <code>response</code> 还没有被设置，则当前线程将进入等待状态，直到其他线程通过调用 <code>setResponse()</code> 方法设置了 <code>response</code> 并调用了 <code>notifyAll()</code> 来唤醒所有等待的线程。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p><strong>条件判断</strong>：在循环中使用 <code>wait()</code> 方法等待条件成立。这是因为可能存在虚假唤醒的情况，即使没有收到通知也可能唤醒等待的线程，所以必须再次检查条件是否真的满足。</p>
</li>
<li><p><strong>超时机制</strong>：在实际应用中，为了防止无限期等待，通常会加入超时机制，如上面代码中的 <code>timeout</code> 参数，确保线程不会永远处于等待状态。</p>
</li>
<li><p><strong>锁的管理</strong>：注意，<code>wait()</code> 和 <code>notify()</code> 必须在同步上下文中调用，即在由 <code>synchronized</code> 修饰的方法或代码块中调用，否则会导致 <code>IllegalMonitorStateException</code> 异常。</p>
</li>
</ul>
<p>保护性暂停模式是处理线程间协作问题的一个强大工具，但在设计和实现时需要仔细考虑各种可能的并发情况，以避免死锁或其他并发问题。</p>
<p><code>park</code> 和 <code>unpark</code> 是 Java 并发工具包 <code>java.util.concurrent.locks</code> 中提供的低级线程阻塞和唤醒机制，它们是由 <code>LockSupport</code> 类提供的。这两个方法提供了比传统的 <code>wait/notify</code> 更灵活的线程控制方式，主要用于构建更高级别的同步工具（如锁、信号量等）。</p>
<h3 id="Park-和-Unpark-的基本概念"><a href="#Park-和-Unpark-的基本概念" class="headerlink" title="Park 和 Unpark 的基本概念"></a>Park 和 Unpark 的基本概念</h3><ul>
<li><p><strong>Park</strong>：可以理解为让当前线程“停在某个地方”，类似于 <code>Object.wait()</code> 或 <code>Thread.sleep()</code>，但更加灵活。调用 <code>LockSupport.park()</code> 会让当前线程进入等待状态，直到发生以下情况之一：</p>
<ul>
<li>调用了对应的 <code>unpark</code> 方法。</li>
<li>线程被中断。</li>
<li>超时（如果使用的是带超时参数的 <code>parkNanos</code> 或 <code>parkUntil</code> 方法）。</li>
</ul>
</li>
<li><p><strong>Unpark</strong>：用于解除一个线程的阻塞状态。与 <code>park</code> 不同，<code>unpark</code> 可以先于 <code>park</code> 调用。也就是说，你可以提前“许可”一个线程，然后当该线程调用 <code>park</code> 时，它会立即返回而不是进入等待状态。</p>
</li>
</ul>
<h3 id="LockSupport-提供的方法"><a href="#LockSupport-提供的方法" class="headerlink" title="LockSupport 提供的方法"></a>LockSupport 提供的方法</h3><p>以下是 <code>LockSupport</code> 类中与 <code>park</code> 和 <code>unpark</code> 相关的主要方法：</p>
<ul>
<li><p><strong><code>void park()</code></strong>：使当前线程进入等待状态，除非获得了许可（通过先前调用 <code>unpark</code> 或者中断）。</p>
</li>
<li><p><strong><code>void parkNanos(long nanos)</code></strong>：与 <code>park</code> 类似，但是带有超时时间，单位是纳秒。</p>
</li>
<li><p><strong><code>void parkUntil(long deadline)</code></strong>：使当前线程进入等待状态直到指定的时间点。</p>
</li>
<li><p><strong><code>void unpark(Thread thread)</code></strong>：授予给定线程许可，使其可以从 <code>park</code> 调用中恢复执行。如果该线程没有被 <code>park</code>，则下次调用 <code>park</code> 时会立即返回而不阻塞。</p>
</li>
</ul>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个简单的例子展示了如何使用 <code>park</code> 和 <code>unpark</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParkUnparkExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">parkedThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始等待...&quot;</span>);</span><br><span class="line">            <span class="comment">// 当前线程将在这里等待，直到另一个线程调用 unpark</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程继续执行...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        parkedThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程暂停一段时间，确保 parkedThread 已经开始执行并调用了 park</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒 parkedThread</span></span><br><span class="line">        LockSupport.unpark(parkedThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p><strong>许可机制</strong>：<code>park</code> 和 <code>unpark</code> 使用了一种“许可”的概念。每次调用 <code>unpark</code> 就像是给目标线程发放一张“许可票”，而每次调用 <code>park</code> 则是尝试消耗这张票。如果已经有一张未使用的票，则 <code>park</code> 会立即返回；如果没有可用的票，则当前线程会被挂起，直到获得新的许可或线程被中断。</p>
</li>
<li><p><strong>灵活性</strong>：不同于 <code>wait/notify</code> 必须配合对象的监视器锁一起使用，<code>park/unpark</code> 没有这种限制，因此它们提供了更高的灵活性。</p>
</li>
<li><p><strong>优先性</strong>：<code>unpark</code> 可以在 <code>park</code> 之前调用，这意味着你可以在需要的时候预先发出“许可”，这使得编写某些类型的并发算法变得更加简单直接。</p>
</li>
</ul>
<p>总之，<code>park</code> 和 <code>unpark</code> 提供了一种强大且灵活的方式来控制线程的行为，特别是在开发自定义同步工具时非常有用。不过由于它们属于较低级别的操作，通常建议仅在构建更高级别的同步原语时使用，而非直接在应用逻辑中频繁调用。</p>
<h3 id="1-死锁（Deadlock）"><a href="#1-死锁（Deadlock）" class="headerlink" title="1. 死锁（Deadlock）"></a>1. 死锁（Deadlock）</h3><p><strong>定义：</strong></p>
<p>当两个或多个线程无限期地等待彼此持有的资源时，就会发生死锁。换句话说，每个线程都在等待另一个线程释放它所需要的资源，从而导致所有涉及的线程都无法继续执行。</p>
<p><strong>死锁发生的四个必要条件（Coffman 条件）：</strong></p>
<ul>
<li><strong>互斥条件</strong>：至少有一个资源必须处于非共享模式，即一次只能被一个线程占用。</li>
<li><strong>占有并等待条件</strong>：一个线程已经占有了至少一个资源，同时还在等待其他线程所占有的资源。</li>
<li><strong>不可剥夺条件</strong>：资源不能被强制从一个线程那里剥夺，而只能由拥有它的线程主动释放。</li>
<li><strong>循环等待条件</strong>：存在一个线程的环形等待序列，其中每个线程都在等待下一个线程所拥有的资源。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; holds lockA...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; holds lockB...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; holds lockB...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; holds lockA...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.methodA()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; demo.methodB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-活锁（Livelock）"><a href="#2-活锁（Livelock）" class="headerlink" title="2. 活锁（Livelock）"></a>2. 活锁（Livelock）</h3><p><strong>定义：</strong></p>
<p>活锁类似于死锁，但是不同之处在于，涉及到的线程并没有被阻塞，而是不断地尝试完成操作，但由于某些条件始终未能满足，导致它们不断重试却永远无法成功。这种情况通常发生在避免冲突的算法中，例如两个线程试图互相礼让对方先访问资源，结果反而谁也无法前进。</p>
<p><strong>示例情景：</strong></p>
<p>假设两个线程都需要更新数据库中的同一条记录，为了防止数据不一致，它们都检查是否有其他线程正在修改这条记录。如果检测到有其他线程正在修改，则当前线程会放弃自己的修改尝试，并重新开始整个过程。若这两个线程总是同时检测到对方正在修改，那么它们就永远不会完成任何修改。</p>
<h3 id="3-饥饿（Starvation）"><a href="#3-饥饿（Starvation）" class="headerlink" title="3. 饥饿（Starvation）"></a>3. 饥饿（Starvation）</h3><p><strong>定义：</strong></p>
<p>饥饿是指一个线程由于长期得不到足够的资源来执行其任务，从而无法向前推进的情况。这可能是由于调度器不公平地分配CPU时间，或者是因为优先级较高的线程频繁抢占资源，导致低优先级线程几乎得不到执行机会。</p>
<p><strong>常见原因：</strong></p>
<ul>
<li><strong>资源不足</strong>：系统没有足够的资源供所有线程使用。</li>
<li><strong>优先级倒置</strong>：高优先级的线程频繁抢占低优先级线程所需的资源。</li>
<li><strong>不合理的锁竞争策略</strong>：比如某些线程总是在获取锁时失败，因为其他线程总是更快地获取到了锁。</li>
</ul>
<p><strong>解决方案：</strong></p>
<p>针对上述三种问题，可以采取不同的解决策略：</p>
<ul>
<li><strong>死锁预防&#x2F;检测&#x2F;恢复</strong>：通过设计避免满足 Coffman 条件之一；使用死锁检测算法定期扫描系统的状态；一旦检测到死锁，可以通过回滚事务等方式进行恢复。</li>
<li><strong>活锁解决</strong>：引入随机化的退避机制，使得线程在遇到冲突时不立即重试，而是等待一段时间后再试。</li>
<li><strong>饥饿缓解</strong>：确保公平性，例如使用公平锁（Fair Lock），保证请求资源的顺序与到达顺序一致；调整线程优先级策略等。</li>
</ul>
<p>Java 并发包（<code>java.util.concurrent</code>, 简称 JUC）中的 <code>Lock</code> 框架提供了一种比传统的 <code>synchronized</code> 更灵活的同步机制。它允许更细粒度地控制锁的行为，并提供了诸如尝试获取锁、可中断获取锁、超时获取锁等功能。</p>
<h3 id="一、基础架构"><a href="#一、基础架构" class="headerlink" title="一、基础架构"></a>一、基础架构</h3><h4 id="1-核心接口：Lock"><a href="#1-核心接口：Lock" class="headerlink" title="1. 核心接口：Lock"></a>1. 核心接口：<code>Lock</code></h4><p><code>Lock</code> 是 Java 提供的一个接口，定义了锁的基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>; <span class="comment">// 获取锁，如果锁不可用，则当前线程处于等待状态直到获得锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 可中断地获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>; <span class="comment">// 尝试非阻塞地获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 带超时功能的获取锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>; <span class="comment">// 释放锁</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>; <span class="comment">// 返回一个绑定到此 Lock 对象的新 Condition 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-锁的实现类"><a href="#2-锁的实现类" class="headerlink" title="2. 锁的实现类"></a>2. 锁的实现类</h4><ul>
<li><strong>ReentrantLock</strong>：最常用的重入锁实现，支持公平锁和非公平锁模式。</li>
<li><strong>ReadWriteLock &#x2F; ReentrantReadWriteLock</strong>：读写锁，允许多个读线程同时访问，但写线程独占访问权。</li>
<li><strong>StampedLock</strong>：Java 8 引入的一种新的锁机制，适用于读多写少的场景，提供了乐观读取的能力。</li>
</ul>
<h3 id="二、具体设计"><a href="#二、具体设计" class="headerlink" title="二、具体设计"></a>二、具体设计</h3><h4 id="1-ReentrantLock-设计细节"><a href="#1-ReentrantLock-设计细节" class="headerlink" title="1. ReentrantLock 设计细节"></a>1. ReentrantLock 设计细节</h4><p><code>ReentrantLock</code> 的核心是基于 AQS（AbstractQueuedSynchronizer）实现的。AQS 是 JUC 中的基础同步器框架，通过 FIFO 队列来管理线程的竞争情况。</p>
<ul>
<li><p><strong>公平锁 vs 非公平锁</strong></p>
<ul>
<li>公平锁会按照请求锁的顺序来分配锁，即先请求的线程先获得锁。</li>
<li>非公平锁则允许插队，新来的线程有机会抢占锁，这可以减少上下文切换，提高吞吐量。</li>
</ul>
</li>
<li><p><strong>可重入特性</strong></p>
<ul>
<li>同一线程可以多次获取同一个锁而不导致死锁，每次获取锁都会增加持有计数，释放锁时减少计数，只有当计数归零时才真正释放锁。</li>
</ul>
</li>
</ul>
<h4 id="2-ReentrantReadWriteLock-设计细节"><a href="#2-ReentrantReadWriteLock-设计细节" class="headerlink" title="2. ReentrantReadWriteLock 设计细节"></a>2. ReentrantReadWriteLock 设计细节</h4><p><code>ReentrantReadWriteLock</code> 分为读锁和写锁，分别实现了不同的锁策略：</p>
<ul>
<li><strong>读锁</strong>：允许多个读线程同时持有，只要没有写线程在操作即可。</li>
<li><strong>写锁</strong>：是排他的，只有一个写线程能持有锁，且不允许任何其他读或写操作。</li>
</ul>
<h4 id="3-StampedLock-设计细节"><a href="#3-StampedLock-设计细节" class="headerlink" title="3. StampedLock 设计细节"></a>3. StampedLock 设计细节</h4><p><code>StampedLock</code> 引入了一个“戳”的概念，用于标识锁的状态。它支持三种模式：</p>
<ul>
<li><strong>写锁</strong>：类似于传统的互斥锁。</li>
<li><strong>读锁</strong>：允许多个读线程同时持有。</li>
<li><strong>乐观读锁</strong>：假设没有写操作发生，直接返回一个版本号作为戳。如果后续发现确实有写操作发生了，则需要重新获取正确的数据。</li>
</ul>
<h3 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h3><h4 id="1-使用-ReentrantLock-替代-synchronized"><a href="#1-使用-ReentrantLock-替代-synchronized" class="headerlink" title="1. 使用 ReentrantLock 替代 synchronized"></a>1. 使用 ReentrantLock 替代 synchronized</h4><p>当你需要更复杂的锁行为时，如尝试获取锁、带超时的获取锁等，可以使用 <code>ReentrantLock</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-ReadWriteLock-在读多写少的情况下提高性能"><a href="#2-使用-ReadWriteLock-在读多写少的情况下提高性能" class="headerlink" title="2. 使用 ReadWriteLock 在读多写少的情况下提高性能"></a>2. 使用 ReadWriteLock 在读多写少的情况下提高性能</h4><p>如果你的应用场景中读操作远多于写操作，可以使用 <code>ReentrantReadWriteLock</code> 来提高并发性能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">rwl.readLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 多个线程可以同时读取</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rwl.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 排他性写入</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwl.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用-StampedLock-在读多写少且适合乐观锁的场景"><a href="#3-使用-StampedLock-在读多写少且适合乐观锁的场景" class="headerlink" title="3. 使用 StampedLock 在读多写少且适合乐观锁的场景"></a>3. 使用 StampedLock 在读多写少且适合乐观锁的场景</h4><p>对于读操作非常频繁，而写操作较少的情况，<code>StampedLock</code> 提供了更高的性能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 进行读操作...</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">    <span class="comment">// 如果检测到写操作发生，升级为悲观读锁</span></span><br><span class="line">    stamp = sl.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新读取</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sl.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="ReentrantLock原理。"><a href="#ReentrantLock原理。" class="headerlink" title="ReentrantLock原理。"></a>ReentrantLock原理。</h2><p>🧱 一、ReentrantLock 架构图与类结构<br>java.util.concurrent.locks.Lock         ← 接口<br>            ↑<br>     ┌──────┴──────────┐<br>     │                 │<br>ReentrantLock    ReadWriteLock<br>     │<br>     └──────────── uses ─────────────┐<br>                                     ↓<br>      AbstractQueuedSynchronizer (AQS) ←——— Sync（内部类）</p>
<p> ReentrantLock 是 Lock 接口的实现类</p>
<p> 内部依赖 AQS 来实现线程阻塞&#x2F;唤醒、资源管理</p>
<p> 它通过内部类 Sync（继承 AQS）来完成真正的加锁逻辑</p>
<p>🧬 二、继承结构与类关系<br>ReentrantLock<br>  ├── Sync extends AbstractQueuedSynchronizer<br>  │     ├── FairSync      （公平锁）<br>  │     └── NonfairSync   （非公平锁）</p>
<p> ReentrantLock 是一个封装类，真正加解锁逻辑都在 Sync 中</p>
<p> Sync 是 AQS 的子类，实现了 tryAcquire, tryRelease 等核心方法</p>
<p> 公平锁 &#x2F; 非公平锁的差异体现在 tryAcquire 方法的实现上</p>
<p>🔑 三、核心字段<br>private final Sync sync;</p>
<p> 构造时根据参数使用 FairSync 或 NonfairSync：</p>
<p>public ReentrantLock(boolean fair) {<br>    sync &#x3D; fair ? new FairSync() : new NonfairSync();<br>}<br>🔄 四、加锁流程（lock）<br>📌 源码入口：<br>public void lock() {<br>    sync.acquire(1); &#x2F;&#x2F; AQS 提供的模板方法<br>}<br>📌 AQS 中的 acquire(int arg)：<br>public final void acquire(int arg) {<br>    if (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>}<br>流程分解：</p>
<p> 尝试获取锁（tryAcquire）：</p>
<p> 如果是可重入场景，当前线程是持有者，直接 state++，成功返回。</p>
<p> 如果锁是空闲状态，CAS 设置为占用状态。</p>
<p> 失败后入队（addWaiter）：</p>
<p> 线程封装成 Node 加入 CLH 等待队列。</p>
<p> 排队自旋（acquireQueued）：</p>
<p> 判断是否排到队头，是则再次尝试加锁。</p>
<p> 否则 LockSupport.park() 挂起自己。</p>
<p>🔓 五、解锁流程（unlock）<br>public void unlock() {<br>    sync.release(1); &#x2F;&#x2F; AQS 模板方法<br>}<br>AQS 的 release：<br>public final boolean release(int arg) {<br>    if (tryRelease(arg)) {<br>        Node h &#x3D; head;<br>        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)<br>            unparkSuccessor(h);<br>        return true;<br>    }<br>    return false;<br>}</p>
<p> 尝试释放锁（tryRelease）：</p>
<p> state–；如果降为 0，设置持有线程为 null，表示完全释放。</p>
<p> 唤醒队列中的下一个线程（unparkSuccessor）：</p>
<p> 调用 LockSupport.unpark()，唤醒队列中下一个等待线程。</p>
<p>🎭 六、公平锁 vs 非公平锁</p>
<ol>
<li>非公平锁（默认）<br>final boolean nonfairTryAcquire(int acquires) {<br> final Thread current &#x3D; Thread.currentThread();<br> int c &#x3D; getState();<br> if (c &#x3D;&#x3D; 0) {<br> &#x2F;&#x2F; 不管队列有没有人，直接抢锁<br> if (compareAndSetState(0, acquires)) {<br>     setExclusiveOwnerThread(current);<br>     return true;<br> }<br> }<br> &#x2F;&#x2F; 可重入逻辑<br> else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) {<br> setState(c + acquires);<br> return true;<br> }<br> return false;<br>}<br>非公平锁更激进，更倾向于新来的线程插队。</li>
<li>公平锁（先进先出）<br>protected final boolean tryAcquire(int acquires) {<br> final Thread current &#x3D; Thread.currentThread();<br> int c &#x3D; getState();<br> if (c &#x3D;&#x3D; 0) {<br> &#x2F;&#x2F; 只有队列没有线程等待，才尝试抢锁<br> if (!hasQueuedPredecessors() &amp;&amp;<br>     compareAndSetState(0, acquires)) {<br>     setExclusiveOwnerThread(current);<br>     return true;<br> }<br> }<br> else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) {<br> setState(c + acquires);<br> return true;<br> }<br> return false;<br>}<br>公平锁在每次加锁前都会判断自己是不是排队中的第一个。<br>🔁 七、重入的实现方式</li>
</ol>
<p> 每次 lock() 成功，内部 state++；</p>
<p> 每次 unlock()，内部 state–；</p>
<p> 当 state &#x3D;&#x3D; 0，才真正释放锁。</p>
<p>&#x2F;&#x2F; 可重入场景<br>lock.lock();  &#x2F;&#x2F; state &#x3D; 1<br>lock.lock();  &#x2F;&#x2F; state &#x3D; 2<br>lock.unlock();&#x2F;&#x2F; state &#x3D; 1<br>lock.unlock();&#x2F;&#x2F; state &#x3D; 0，真正释放<br>🎯 八、条件变量（Condition）<br>ReentrantLock 支持 Condition，比 Object.wait&#x2F;notify 更强大灵活。<br>Condition condition &#x3D; lock.newCondition();</p>
<p>condition.await();     &#x2F;&#x2F; 等待并释放锁<br>condition.signal();    &#x2F;&#x2F; 唤醒一个等待线程<br>condition.signalAll(); &#x2F;&#x2F; 唤醒所有等待线程<br>底层同样通过 AQS 的 ConditionObject 实现，拥有自己的等待队列。<br>🔚 总结图示<br>ReentrantLock<br>   ↓<br>[lock()] → AQS.acquire()<br>             ↓<br>         tryAcquire()  → 成功 → 继续<br>                      → 失败 → 入队 + park()</p>
<p>[unlock()] → AQS.release()<br>             ↓<br>         tryRelease()  → state&#x3D;&#x3D;0 → unpark 下一个<br>✅ 总结一句话：<br> ReentrantLock 是基于 AQS 的可重入独占锁，内部用状态变量和 CLH 队列控制线程竞争，支持公平&#x2F;非公平模式，灵活强大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是 <strong>Java 并发包 <code>java.util.concurrent.locks</code> 中 AQS（AbstractQueuedSynchronizer）类</strong> 的核心方法之一：<code>acquireQueued()</code>。</p>
<p>这个方法的作用是：<strong>让线程在等待获取同步状态（锁）时，以一种高效、公平且可中断的方式挂起和唤醒</strong>。它是 AQS 实现如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 等并发工具的基础逻辑。</p>
<hr>
<h2 id="🧠-背景知识：AQS-是什么？"><a href="#🧠-背景知识：AQS-是什么？" class="headerlink" title="🧠 背景知识：AQS 是什么？"></a>🧠 背景知识：AQS 是什么？</h2><p>AQS（AbstractQueuedSynchronizer）是一个用来构建锁和同步器的框架，由 Doug Lea 编写，是 Java 并发包的核心组件之一。</p>
<p>它通过一个 <strong>int 类型的状态变量（state）</strong> 来表示资源是否被占用，并维护一个 <strong>CLH（Craig-Landin-Hagersten）队列</strong> 来管理等待获取资源的线程。</p>
<hr>
<h2 id="🔍-方法签名解析"><a href="#🔍-方法签名解析" class="headerlink" title="🔍 方法签名解析"></a>🔍 方法签名解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@ReservedStackAccess</code>：这是 JDK 内部注解，用于标记该方法调用链需要避免栈溢出检测（JVM 特定优化）。</li>
<li><code>node</code>：当前线程封装成的一个节点（Node），已加入到 AQS 的等待队列中。</li>
<li><code>arg</code>：尝试获取的同步状态值（对于 ReentrantLock 通常是 1）。</li>
<li>返回值：是否被中断过（interrupted）</li>
</ul>
<hr>
<h2 id="📦-方法作用总结"><a href="#📦-方法作用总结" class="headerlink" title="📦 方法作用总结"></a>📦 方法作用总结</h2><blockquote>
<p><strong>该方法负责让线程在队列中自旋等待获取锁（tryAcquire），如果失败则阻塞，直到被前驱节点唤醒或中断。</strong></p>
</blockquote>
<p>它是 <strong>非响应中断版本的独占式获取</strong>（即允许线程被中断，但不会提前释放节点）。</p>
<hr>
<h2 id="🔁-主要流程详解（逐行分析）"><a href="#🔁-主要流程详解（逐行分析）" class="headerlink" title="🔁 主要流程详解（逐行分析）"></a>🔁 主要流程详解（逐行分析）</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋循环</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔁-循环体说明："><a href="#🔁-循环体说明：" class="headerlink" title="🔁 循环体说明："></a>🔁 循环体说明：</h3><h4 id="1-获取当前节点的前驱节点-p"><a href="#1-获取当前节点的前驱节点-p" class="headerlink" title="1. 获取当前节点的前驱节点 p"></a>1. 获取当前节点的前驱节点 <code>p</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br></pre></td></tr></table></figure>

<ul>
<li>每个节点都保存了前驱节点。</li>
<li>如果当前节点不是头节点的后继节点，则不能立即抢锁。</li>
</ul>
<h4 id="2-尝试获取锁（只有头节点的下一个节点才有资格抢锁）"><a href="#2-尝试获取锁（只有头节点的下一个节点才有资格抢锁）" class="headerlink" title="2. 尝试获取锁（只有头节点的下一个节点才有资格抢锁）"></a>2. 尝试获取锁（只有头节点的下一个节点才有资格抢锁）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node); <span class="comment">// 成功获取锁，将当前节点设为头节点</span></span><br><span class="line">    p.next = <span class="literal">null</span>; <span class="comment">// 原头节点无引用，帮助GC回收</span></span><br><span class="line">    failed = <span class="literal">false</span>; <span class="comment">// 标记成功获取</span></span><br><span class="line">    <span class="keyword">return</span> interrupted; <span class="comment">// 返回是否被中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里体现了一个“公平性”机制：只有当前节点是头节点的下一个节点时才尝试获取锁。</li>
<li><code>tryAcquire(arg)</code> 是抽象方法，由子类实现具体的获取逻辑（比如 <code>ReentrantLock.Sync.tryAcquire()</code>）。</li>
</ul>
<h4 id="3-获取失败后的处理"><a href="#3-获取失败后的处理" class="headerlink" title="3. 获取失败后的处理"></a>3. 获取失败后的处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h5 id="a-shouldParkAfterFailedAcquire-p-node"><a href="#a-shouldParkAfterFailedAcquire-p-node" class="headerlink" title="a. shouldParkAfterFailedAcquire(p, node)"></a>a. <code>shouldParkAfterFailedAcquire(p, node)</code></h5><ul>
<li>判断当前节点是否应该被挂起（park）。</li>
<li>它会检查前驱节点的状态（waitStatus），并可能设置为 SIGNAL 状态，表示当前节点需要被唤醒。</li>
<li>如果前驱节点状态正常，则返回 <code>true</code>，表示可以安全地挂起当前线程。</li>
</ul>
<h5 id="b-parkAndCheckInterrupt"><a href="#b-parkAndCheckInterrupt" class="headerlink" title="b. parkAndCheckInterrupt()"></a>b. <code>parkAndCheckInterrupt()</code></h5><ul>
<li>使用 <code>LockSupport.park()</code> 阻塞当前线程。</li>
<li>如果线程在此期间被中断，返回 <code>true</code>，记录下来。</li>
</ul>
<hr>
<h3 id="🛑-finally-块中的异常处理"><a href="#🛑-finally-块中的异常处理" class="headerlink" title="🛑 finally 块中的异常处理"></a>🛑 finally 块中的异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在获取过程中出现异常（如 InterruptedException 或其他错误），<code>failed</code> 仍为 <code>true</code>，则调用 <code>cancelAcquire(node)</code> 清理当前节点：<ul>
<li>设置节点状态为 CANCELLED。</li>
<li>从队列中移除无效节点。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="📐-CLH-队列结构简述"><a href="#📐-CLH-队列结构简述" class="headerlink" title="📐 CLH 队列结构简述"></a>📐 CLH 队列结构简述</h2><p>AQS 使用的是一个<strong>双向链表</strong>构成的队列，每个节点（Node）包含以下信息：</p>
<ul>
<li>当前线程（thread）</li>
<li>前驱节点（prev）</li>
<li>后继节点（next）</li>
<li>节点状态（waitStatus）</li>
<li>节点类型（共享&#x2F;独占）</li>
</ul>
<p>当线程获取锁失败时，会被包装成 Node 插入到队列尾部，并进入阻塞状态。</p>
<hr>
<h2 id="✅-总结一句话：-4"><a href="#✅-总结一句话：-4" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><code>acquireQueued()</code> 是 AQS 中用于实现<strong>线程排队获取锁</strong>的核心方法，它通过自旋 + 阻塞 + 唤醒机制，实现了高效、公平、可中断的锁获取逻辑。</p>
</blockquote>
<hr>
<h2 id="🚀-扩展建议"><a href="#🚀-扩展建议" class="headerlink" title="🚀 扩展建议"></a>🚀 扩展建议</h2><p>如果你对 AQS 感兴趣，还可以继续研究以下几个相关方法和概念：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>release(int arg)</code></td>
<td>释放同步状态（解锁）</td>
</tr>
<tr>
<td><code>tryAcquireShared(int arg)</code> &#x2F; <code>tryReleaseShared(int arg)</code></td>
<td>共享模式下的获取与释放（如 Semaphore）</td>
</tr>
<tr>
<td><code>ConditionObject</code></td>
<td>AQS 对 Condition 的支持，用于实现 wait&#x2F;notify 语义</td>
</tr>
<tr>
<td><code>setHeadAndPropagate(Node node, int propagate)</code></td>
<td>共享模式下传播唤醒</td>
</tr>
</tbody></table>
<hr>
<p>这段代码是 <strong>AQS（AbstractQueuedSynchronizer）</strong> 中的 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法，它是 AQS 实现线程挂起与唤醒机制的核心逻辑之一。</p>
<hr>
<h2 id="🧠-作用：判断当前线程是否应该被“阻塞挂起”"><a href="#🧠-作用：判断当前线程是否应该被“阻塞挂起”" class="headerlink" title="🧠 作用：判断当前线程是否应该被“阻塞挂起”"></a>🧠 作用：判断当前线程是否应该被“阻塞挂起”</h2><p>这个方法的作用是：</p>
<blockquote>
<p>在尝试获取锁失败后，决定当前节点（node）是否应该被挂起（park），以节省 CPU 资源，并等待前驱节点（pred）唤醒自己。</p>
</blockquote>
<p>它主要做三件事：</p>
<ol>
<li>如果前驱节点状态是 <code>SIGNAL</code>，说明它会唤醒当前节点 → 可以安全挂起。</li>
<li>如果前驱节点状态是 <code>CANCELLED</code>（已取消），跳过所有已取消的前驱节点，重新连接链表。</li>
<li>否则（状态为 0 或 PROPAGATE），尝试将前驱节点设为 <code>SIGNAL</code>，并返回 <code>false</code>，表示本次不挂起，下一轮再判断。</li>
</ol>
<hr>
<h2 id="🔁-参数说明"><a href="#🔁-参数说明" class="headerlink" title="🔁 参数说明"></a>🔁 参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>pred</code>：当前节点的前驱节点（predecessor）</li>
<li><code>node</code>：当前线程封装成的节点（正在排队等待获取锁）</li>
</ul>
<hr>
<h2 id="📌-返回值含义"><a href="#📌-返回值含义" class="headerlink" title="📌 返回值含义"></a>📌 返回值含义</h2><ul>
<li><code>true</code>：可以安全地挂起当前线程（调用 <code>park()</code>）</li>
<li><code>false</code>：不能挂起，需要再次尝试获取锁或设置前驱节点状态后再重试</li>
</ul>
<hr>
<h2 id="✅-逐段解析代码"><a href="#✅-逐段解析代码" class="headerlink" title="✅ 逐段解析代码"></a>✅ 逐段解析代码</h2><h3 id="第一步：检查前驱节点的状态（waitStatus）"><a href="#第一步：检查前驱节点的状态（waitStatus）" class="headerlink" title="第一步：检查前驱节点的状态（waitStatus）"></a>第一步：检查前驱节点的状态（waitStatus）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果前驱节点的 <code>waitStatus == SIGNAL</code>：<ul>
<li>表示前驱节点在释放锁时会通知当前节点。</li>
<li>所以当前节点可以安心地挂起等待唤醒。</li>
<li>直接返回 <code>true</code>，表示可以 park。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二步：处理前驱节点被取消的情况（waitStatus-0）"><a href="#第二步：处理前驱节点被取消的情况（waitStatus-0）" class="headerlink" title="第二步：处理前驱节点被取消的情况（waitStatus &gt; 0）"></a>第二步：处理前驱节点被取消的情况（waitStatus &gt; 0）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ws &gt; 0</code> 意味着前驱节点是 <code>CANCELLED</code> 状态（比如线程被中断、超时等）。</li>
<li>这种情况下，需要从队列中“跳过”这些取消的节点，找到一个有效的前驱节点。</li>
<li>然后把当前节点的 <code>prev</code> 指向该有效节点，并更新该节点的 <code>next</code> 指向当前节点。</li>
<li>最终返回 <code>false</code>，让外层继续循环，而不是挂起。</li>
</ul>
<p>📌 <strong>注意</strong>：此时不会立即挂起线程，而是让其重新进入自旋，重新尝试获取锁。</p>
<hr>
<h3 id="第三步：设置前驱节点为-SIGNAL"><a href="#第三步：设置前驱节点为-SIGNAL" class="headerlink" title="第三步：设置前驱节点为 SIGNAL"></a>第三步：设置前驱节点为 <code>SIGNAL</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果前驱节点状态是 0 或 PROPAGATE（共享模式传播），就尝试将其状态改为 <code>SIGNAL</code>。</li>
<li>使用 CAS（原子操作）保证线程安全。</li>
<li>返回 <code>false</code>，表示本轮不能挂起线程，下次再判断。</li>
</ul>
<hr>
<h2 id="📐-Node-waitStatus-的几个关键值"><a href="#📐-Node-waitStatus-的几个关键值" class="headerlink" title="📐 Node.waitStatus 的几个关键值"></a>📐 Node.waitStatus 的几个关键值</h2><table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>默认状态，新加入的节点初始状态</td>
</tr>
<tr>
<td><code>-1 (SIGNAL)</code></td>
<td>当前节点的后继节点需要被唤醒（unpark）</td>
</tr>
<tr>
<td><code>1 (CANCELLED)</code></td>
<td>当前线程被取消（如中断、超时）</td>
</tr>
<tr>
<td><code>-2 (CONDITION)</code></td>
<td>当前节点在条件队列中（用于 ConditionObject）</td>
</tr>
<tr>
<td><code>-3 (PROPAGATE)</code></td>
<td>共享模式下，表示传播唤醒</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔄-流程图示意"><a href="#🔄-流程图示意" class="headerlink" title="🔄 流程图示意"></a>🔄 流程图示意</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[当前节点] ← [前驱节点]</span><br><span class="line">         ↑ waitStatus = ?</span><br><span class="line">         └─ ws == SIGNAL → return true（可挂起）</span><br><span class="line">         └─ ws &gt; 0 → 跳过取消节点，更新 prev/next → return false</span><br><span class="line">         └─ ws == 0 或 PROPAGATE → 设置 SIGNAL → return false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎯-举个例子（ReentrantLock-非公平锁）"><a href="#🎯-举个例子（ReentrantLock-非公平锁）" class="headerlink" title="🎯 举个例子（ReentrantLock 非公平锁）"></a>🎯 举个例子（ReentrantLock 非公平锁）</h2><p>假设有三个线程 T1、T2、T3 依次请求获取 ReentrantLock：</p>
<ol>
<li>T1 成功获取锁。</li>
<li>T2 请求失败，加入 AQS 队列，成为头节点的后继节点。</li>
<li>T3 请求失败，加入队列，成为 T2 的后继节点。</li>
</ol>
<p>当 T3 执行到 <code>acquireQueued()</code> 时：</p>
<ul>
<li>它的前驱节点是 T2。</li>
<li>如果 T2 的 <code>waitStatus == 0</code>，就会通过 <code>compareAndSetWaitStatus(pred, 0, SIGNAL)</code> 把 T2 标记为 SIGNAL。</li>
<li>返回 <code>false</code>，T3 不会立刻挂起，而是再循环一次，直到确认 T2 已经准备好唤醒它。</li>
</ul>
<hr>
<h2 id="🧩-总结一句话："><a href="#🧩-总结一句话：" class="headerlink" title="🧩 总结一句话："></a>🧩 总结一句话：</h2><blockquote>
<p><code>shouldParkAfterFailedAcquire()</code> 是 AQS 控制线程是否应该被挂起的关键逻辑。它通过检查和修改前驱节点的状态（waitStatus），确保线程只在合适的时候被挂起，从而实现高效、公平的并发控制。</p>
</blockquote>
<hr>
<p><code>StampedLock</code> 是 Java 8 引入的一种锁机制，位于 <code>java.util.concurrent.locks</code> 包中。它提供了一种比传统的读写锁（如 <code>ReentrantReadWriteLock</code>）更灵活且可能更高效的替代方案，尤其适用于读操作远多于写操作的场景。与读写锁不同的是，<code>StampedLock</code> 提供了乐观读锁的功能，这使得在某些情况下可以进一步提升性能。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><p><strong>三种锁模式</strong>：<code>StampedLock</code> 支持三种类型的锁模式：</p>
<ul>
<li><strong>写锁（Write Lock）</strong>：独占锁，当一个线程获取了写锁之后，其他任何线程都不能获取读锁或写锁。</li>
<li><strong>读锁（Read Lock）</strong>：共享锁，允许多个线程同时持有读锁，只要没有线程持有写锁。</li>
<li><strong>乐观读锁（Optimistic Read Lock）</strong>：一种非阻塞的读锁，允许其他线程尝试获取写锁。如果在执行期间没有发生写操作，则读操作可以成功；否则需要重试。</li>
</ul>
</li>
<li><p><strong>戳记（Stamp）</strong>：每次获取锁都会返回一个“戳记”，该戳记用于后续的操作验证以及解锁。这种设计使得锁的状态检查和解锁操作更加直观和高效。</p>
</li>
<li><p><strong>不可重入性</strong>：<code>StampedLock</code> 不支持重进入，这意味着如果一个线程已经持有了某个锁，它不能再次获取同一个锁。</p>
</li>
<li><p><strong>无条件的锁降级</strong>：虽然不支持重进入，但是<code>StampedLock</code> 支持从写锁到读锁的有条件降级。</p>
</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p><strong>写锁相关</strong>：</p>
<ul>
<li><code>long writeLock()</code>：获取写锁并返回一个戳记。</li>
<li><code>void unlockWrite(long stamp)</code>：使用指定的戳记释放写锁。</li>
</ul>
</li>
<li><p><strong>读锁相关</strong>：</p>
<ul>
<li><code>long readLock()</code>：获取读锁并返回一个戳记。</li>
<li><code>void unlockRead(long stamp)</code>：使用指定的戳记释放读锁。</li>
</ul>
</li>
<li><p><strong>乐观读锁相关</strong>：</p>
<ul>
<li><code>long tryOptimisticRead()</code>：尝试获取乐观读锁并立即返回一个戳记。</li>
<li><code>boolean validate(long stamp)</code>：验证戳记是否仍然有效，即在此期间是否有写操作发生。</li>
</ul>
</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是一个简单的例子，展示了如何使用 <code>StampedLock</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123; <span class="comment">// 写锁示例</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123; <span class="comment">// 悲观读锁示例</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(x*x + y*y);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">moveIfAtOrigin</span><span class="params">(<span class="type">double</span> newX, <span class="type">double</span> newY)</span> &#123; <span class="comment">// 乐观读锁示例</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">// 可能会失败</span></span><br><span class="line">                stamp = lock.readLock(); <span class="comment">// 如果验证失败，转换为悲观读锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">// 验证</span></span><br><span class="line">                        x = newX;</span><br><span class="line">                        y = newY;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lock.validate(stamp)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Validation failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p><code>StampedLock</code> 特别适合那些读操作远远多于写操作的应用场景，比如缓存、配置管理等。通过使用乐观读锁，可以在很大程度上减少锁竞争，提高程序的并发度。</p>
<p>然而，由于其复杂性和不支持重进入的特点，在使用时需要特别小心，确保正确处理各种情况下的锁获取和释放。对于一些复杂的业务逻辑，可能更适合使用 <code>ReentrantReadWriteLock</code> 或者其他高级同步工具。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Joie</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/')">多线程_锁</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=多线程_锁&amp;url=http://example.com/2025/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E9%94%81/&amp;pic=https://img.picgo.net/2025/07/07/0963a560354758f9ef0c7067907aa1405fffec21d4abeea6.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>多线程<span class="tagsPageCount">9</span></a><a class="post-meta__box__tags" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>并发<span class="tagsPageCount">9</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://origin.picgo.net/2025/08/07/1eb94f064cf74b04865bdaf1b3c8e9be6939674b9205c975.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/05/%E5%8A%9B%E6%89%A3_2025_07_04/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/27/e824b899a9014c086e064650a03315087bf40bd15ea7a77627fc2417becc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">力扣2025_07_04</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/06/%E5%8A%9B%E6%89%A3_2025_07_05/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/27/e824b899a9014c086e064650a03315087bf40bd15ea7a77627fc2417becc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">力扣2025_07_05</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2025/08/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B_AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="多线程_AQS源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/29/aqs-letter-logo-design-on-black-background-aqs-creative-initials-letter-logo-concept-aqs-letter-design-vector23c92936b0e2ac9c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-27</div><div class="title">多线程_AQS源码分析</div></div></a></div><div><a href="/2025/07/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B_CompletableFuture/" title="多线程_CompletableFuture"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/07/14/e16bbae9e8c14ccea5dbca7108afb50f2ce119221e21affb.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-14</div><div class="title">多线程_CompletableFuture</div></div></a></div><div><a href="/2025/07/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B_Threadlocal/" title="多线程_Threadlocal"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://javaguide.cn/assets/1-YS5yhxvD.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-14</div><div class="title">多线程_Threadlocal</div></div></a></div><div><a href="/2025/07/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B/" title="多线程_共享模型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/07/14/jmm706db083f71abac3.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-10</div><div class="title">多线程_共享模型</div></div></a></div><div><a href="/2025/07/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91/" title="多线程_无锁并发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/07/14/97bc61de389a4e3aa6b605bf4df3a3296c4fffa8a9280cb3.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-11</div><div class="title">多线程_无锁并发</div></div></a></div><div><a href="/2025/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="多线程基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/07/04/d024edf10a2542f19a69f198fac4a202e6b996209c5c57bc.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-04</div><div class="title">多线程基础知识</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.picgo.net/2025/06/23/tom09183405464859c2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Joie</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/BenedictTom" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/372204786" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">一、作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">二、使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%88Synchronized-Method%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 同步方法（Synchronized Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88Synchronized-Block%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2. 同步代码块（Synchronized Block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%90%8C%E6%AD%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3. 静态方法同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">三、锁的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%88Reentrant%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">1. 可重入（Reentrant）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%EF%BC%88Non-interruptible%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 不可中断（Non-interruptible）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Non-Fair%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">3. 非公平锁（Non-Fair）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">5.</span> <span class="toc-text">四、底层原理简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">6.</span> <span class="toc-text">五、优缺点对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">7.</span> <span class="toc-text">六、替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">七、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#syn-ed"><span class="toc-number">8.1.</span> <span class="toc-text">syn-ed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81"><span class="toc-number">8.1.1.</span> <span class="toc-text">使用锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">同步块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">同步方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-synchronized-%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">✅ synchronized 锁对象的写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%93%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%8A%A0%E9%94%81%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">🧠 为什么推荐使用一个专用的对象来加锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%BF%99%E6%A0%B7%E5%86%99%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">❗ 不建议这样写：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">✅ 推荐做法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-number">11.</span> <span class="toc-text">📌 实际应用场景举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-number">11.1.</span> <span class="toc-text">场景1：保护共享变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E5%A4%9A%E8%B5%84%E6%BA%90%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">11.2.</span> <span class="toc-text">场景2：多资源同步控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF3%EF%BC%9A%E9%98%B2%E6%AD%A2%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5%E6%B1%A1%E6%9F%93"><span class="toc-number">11.3.</span> <span class="toc-text">场景3：防止类级别的同步污染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%80%BB%E7%BB%93%EF%BC%9A%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E6%98%AF%E5%90%A6%E5%B8%B8%E8%A7%81%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">🔍 总结：锁对象的使用是否常见？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">12.1.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.</span> <span class="toc-text">对象头结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mark-Word-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">Mark Word 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor-%E9%94%81"><span class="toc-number">12.4.</span> <span class="toc-text">Monitor 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">12.5.</span> <span class="toc-text">锁升级机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">锁升级过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%81%8F%E5%90%91%E9%94%81%EF%BC%88Biased-Locking%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">1. 偏向锁（Biased Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">13.1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">13.1.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Lightweight-Locking%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">2. 轻量级锁（Lightweight Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="toc-number">13.2.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">13.2.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">13.2.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Heavyweight-Locking%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">3. 重量级锁（Heavyweight Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="toc-number">13.3.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-number">13.3.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">13.3.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">13.4.</span> <span class="toc-text">锁升级流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Lock-Record%EF%BC%9F"><span class="toc-number">13.5.</span> <span class="toc-text">1. 什么是 Lock Record？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lock-Record-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">13.6.</span> <span class="toc-text">2. Lock Record 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lock-Record-%E5%9C%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.7.</span> <span class="toc-text">3. Lock Record 在锁升级过程中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8B-T1-%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">13.7.1.</span> <span class="toc-text">场景：线程 T1 尝试获取轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8B-T1-%E9%87%8A%E6%94%BE%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">13.7.2.</span> <span class="toc-text">场景：线程 T1 释放轻量级锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Lock-Record-%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">13.8.</span> <span class="toc-text">4. Lock Record 与偏向锁的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88-Lock-Record-%E6%94%BE%E5%9C%A8%E6%A0%88%E4%B8%8A%EF%BC%9F"><span class="toc-number">13.9.</span> <span class="toc-text">5. 为什么 Lock Record 放在栈上？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number">13.10.</span> <span class="toc-text">6. 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-number">13.11.</span> <span class="toc-text">核心答案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%94%81%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B%E4%B8%8E-Mark-Word-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">13.12.</span> <span class="toc-text">详细解析：锁的演变过程与 Mark Word 的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-1-%E6%97%A0%E9%94%81-Normal"><span class="toc-number">13.12.1.</span> <span class="toc-text">阶段 1: 无锁 (Normal)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-2-%E5%81%8F%E5%90%91%E9%94%81-Biased-Locking"><span class="toc-number">13.12.2.</span> <span class="toc-text">阶段 2: 偏向锁 (Biased Locking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-Lightweight-Locking"><span class="toc-number">13.12.3.</span> <span class="toc-text">阶段 3: 轻量级锁 (Lightweight Locking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-4-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81-Heavyweight-Locking-Inflation"><span class="toc-number">13.12.4.</span> <span class="toc-text">阶段 4: 重量级锁 (Heavyweight Locking &#x2F; Inflation)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E4%BD%A0%E7%9A%84%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98"><span class="toc-number">13.13.</span> <span class="toc-text">回答你的具体问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3"><span class="toc-number">13.14.</span> <span class="toc-text">类比理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.15.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">13.16.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E9%87%8D%E5%85%A5%EF%BC%9F"><span class="toc-number">13.17.</span> <span class="toc-text">什么是锁重入？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">13.17.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">13.18.</span> <span class="toc-text">锁计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%87%8D%E5%85%A5%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.19.</span> <span class="toc-text">锁重入的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">13.20.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">14.</span> <span class="toc-text">自旋优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">14.1.</span> <span class="toc-text">自旋锁的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.</span> <span class="toc-text">自旋优化的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">14.2.1.</span> <span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">14.3.</span> <span class="toc-text">在Java中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8-hashCode-%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%81%8F%E5%90%91%E9%94%81%E8%A2%AB%E7%A6%81%E7%94%A8%EF%BC%9F"><span class="toc-number">14.5.</span> <span class="toc-text">为什么调用 hashCode 会导致偏向锁被禁用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">14.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E2%80%9C%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E2%80%9D%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">🧠 为什么需要“批量重偏向”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">16.</span> <span class="toc-text">🔍 批量重偏向的核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">17.</span> <span class="toc-text">📈 批量重偏向的触发条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">17.1.</span> <span class="toc-text">示例流程如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">18.</span> <span class="toc-text">🧩 关键概念总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%A6%82%E4%BD%95%E8%A7%82%E5%AF%9F%E5%92%8C%E6%8E%A7%E5%88%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">⚙️ 如何观察和控制批量重偏向？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E5%90%AF%E7%94%A8%E5%81%8F%E5%90%91%E9%94%81%EF%BC%88Java-8-%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%EF%BC%89%EF%BC%9A"><span class="toc-number">19.1.</span> <span class="toc-text">1. 查看当前是否启用偏向锁（Java 8+ 默认开启）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%81%8F%E5%90%91%E9%94%81%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%EF%BC%88%E9%BB%98%E8%AE%A4%E6%98%AF-4-%E7%A7%92%EF%BC%89%EF%BC%9A"><span class="toc-number">19.2.</span> <span class="toc-text">2. 控制偏向锁延迟启动时间（默认是 4 秒）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E5%81%8F%E5%90%91%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%EF%BC%88%E9%9C%80%E8%A6%81%E5%90%AF%E7%94%A8%E8%AF%8A%E6%96%AD%E9%80%89%E9%A1%B9%EF%BC%89%EF%BC%9A"><span class="toc-number">19.3.</span> <span class="toc-text">3. 查看偏向锁相关的统计信息（需要启用诊断选项）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-number">20.</span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E9%97%AE%E9%A2%98%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="toc-number">21.</span> <span class="toc-text">🔍 问题核心：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AE%80%E7%9F%AD%E5%9B%9E%E7%AD%94%EF%BC%9A"><span class="toc-number">21.1.</span> <span class="toc-text">✅ 简短回答：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80-%E2%89%A0-%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">22.</span> <span class="toc-text">🧠 偏向锁撤销 ≠ 锁升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF%E5%9B%9E%E9%A1%BE"><span class="toc-number">23.</span> <span class="toc-text">🧪 示例场景回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E5%81%8F%E5%90%91%E9%94%81%E6%98%AF%E5%8F%AF%E4%BB%A5%E2%80%9C%E9%87%8D%E6%96%B0%E8%8E%B7%E5%BE%97%E2%80%9D%E7%9A%84%EF%BC%81"><span class="toc-number">24.</span> <span class="toc-text">🔁 偏向锁是可以“重新获得”的！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E6%9B%B4%E6%B8%85%E6%A5%9A%EF%BC%9A"><span class="toc-number">25.</span> <span class="toc-text">📌 举个例子说明更清楚：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E4%BC%9A%E7%9C%9F%E6%AD%A3%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">🧩 什么时候才会真正升级为轻量级锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-1"><span class="toc-number">27.</span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AE%80%E7%9F%AD%E5%9B%9E%E7%AD%94%EF%BC%9A-1"><span class="toc-number">28.</span> <span class="toc-text">✅ 简短回答：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E2%80%9C%E7%AB%8B%E5%88%BB%E5%81%8F%E5%90%91-T2%E2%80%9D%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">🧠 为什么不能“立刻偏向 T2”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E6%92%A4%E9%94%80%E5%92%8C%E9%87%8D%E5%81%8F%E5%90%91%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">29.1.</span> <span class="toc-text">1. 避免频繁撤销和重偏向带来的开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A4%EF%BC%9A%E5%8F%AF%E8%83%BD%E6%98%AF%E5%81%B6%E5%8F%91%E6%80%A7%E7%AB%9E%E4%BA%89%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E4%BD%BF%E7%94%A8"><span class="toc-number">29.2.</span> <span class="toc-text">2. 防止误判：可能是偶发性竞争，而非真正的多线程交替使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E6%9B%B4%E9%AB%98%E6%95%88%EF%BC%9A%E5%87%8F%E5%B0%91-Safepoint-%E6%AC%A1%E6%95%B0"><span class="toc-number">29.3.</span> <span class="toc-text">3. 批量处理更高效：减少 Safepoint 次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-number">30.</span> <span class="toc-text">📈 批量重偏向的工作流程（详细）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E8%A1%A5%E5%85%85%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%92%A4%E9%94%80%E7%89%B9%E5%88%AB%E9%A2%91%E7%B9%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">🧩 补充：如果撤销特别频繁怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80%EF%BC%88Bulk-Revocation%EF%BC%89"><span class="toc-number">31.1.</span> <span class="toc-text">🔥 批量撤销（Bulk Revocation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-%E8%B0%83%E6%95%B4%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">⚙️ 如何查看&#x2F;调整这些参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-2"><span class="toc-number">33.</span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">🧠 什么是偏向锁撤销？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">34.1.</span> <span class="toc-text">📌 关键点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E7%9A%84%E5%85%B8%E5%9E%8B%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">35.</span> <span class="toc-text">🔁 偏向锁撤销的典型触发场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F%EF%BC%9A"><span class="toc-number">36.</span> <span class="toc-text">🧪 场景模拟：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BB%8E-T2-%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-number">37.</span> <span class="toc-text">🚀 偏向锁撤销流程详解（从 T2 的角度）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%A3%80%E6%9F%A5%E5%AF%B9%E8%B1%A1%E5%A4%B4-Mark-Word"><span class="toc-number">37.1.</span> <span class="toc-text">✅ 第一步：检查对象头 Mark Word</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%92%A4%E9%94%80"><span class="toc-number">37.2.</span> <span class="toc-text">✅ 第二步：判断是否可以撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%BF%9B%E5%85%A5-Safepoint%EF%BC%88%E5%85%A8%E5%B1%80%E5%81%9C%E9%A1%BF%EF%BC%89"><span class="toc-number">37.3.</span> <span class="toc-text">✅ 第三步：进入 Safepoint（全局停顿）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">37.4.</span> <span class="toc-text">✅ 第四步：撤销偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E6%81%A2%E5%A4%8D%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%B9%B6%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">37.5.</span> <span class="toc-text">✅ 第五步：恢复线程执行并尝试获取锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E6%92%A4%E9%94%80%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%88%E4%BB%A5-64-%E4%BD%8D-JVM-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">⚙️ 撤销后的状态变化（以 64 位 JVM 为例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80-vs-%E5%8D%95%E4%B8%AA%E6%92%A4%E9%94%80"><span class="toc-number">39.</span> <span class="toc-text">📈 批量撤销 vs 单个撤销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E4%BB%A3%E4%BB%B7%E9%AB%98%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">🎯 为什么偏向锁撤销代价高？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%EF%BC%9A%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E7%9A%84%E5%85%B3%E9%94%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">41.</span> <span class="toc-text">✅ 总结：偏向锁撤销的关键流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E8%A1%A5%E5%85%85%E5%BB%BA%E8%AE%AE"><span class="toc-number">42.</span> <span class="toc-text">💡 补充建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E4%BA%86t1%EF%BC%8Ct2%E8%8E%B7%E5%BE%97%E4%BA%86%E9%94%81%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%98%E6%B2%A1%E5%8D%87%E7%BA%A7%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%82%A3%E6%98%AF%E4%BB%80%E4%B9%88%E9%94%81"><span class="toc-number">43.</span> <span class="toc-text">撤销了t1，t2获得了锁，如果还没升级轻量级锁 那是什么锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%90%8E%E7%9A%84%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-number">43.1.</span> <span class="toc-text">撤销后的锁状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%9C%BA%E6%99%AF%E5%9B%9E%E9%A1%BE"><span class="toc-number">44.</span> <span class="toc-text">🧪 场景回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0%EF%BC%9A"><span class="toc-number">44.1.</span> <span class="toc-text">撤销过程简述：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%92%A4%E9%94%80%E5%90%8E%E7%9A%84%E9%94%81%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">45.</span> <span class="toc-text">🔍 撤销后的锁状态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">45.1.</span> <span class="toc-text">1. 直接进入轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%9D%E6%8C%81%E4%B8%AD%E7%AB%8B%E7%8A%B6%E6%80%81%EF%BC%88Neutral-Bias-State%EF%BC%89%E5%B9%B6%E9%87%8D%E6%96%B0%E5%81%8F%E5%90%91"><span class="toc-number">45.2.</span> <span class="toc-text">2. 保持中立状态（Neutral Bias State）并重新偏向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CAS-%E7%AB%9E%E4%BA%89%E5%A4%B1%E8%B4%A5%E5%90%8E%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">45.3.</span> <span class="toc-text">3. CAS 竞争失败后升级为轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="toc-number">45.4.</span> <span class="toc-text">4. 批量重偏向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%EF%BC%9AT2-%E8%8E%B7%E5%BE%97%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5"><span class="toc-number">46.</span> <span class="toc-text">✅ 总结：T2 获得锁的具体情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A-1"><span class="toc-number">46.1.</span> <span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8%EF%BC%9A"><span class="toc-number">47.</span> <span class="toc-text">✅ 你的问题本质：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%AD%94%E6%A1%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">48.</span> <span class="toc-text">🧠 答案一句话总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">49.</span> <span class="toc-text">🔍 具体分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-1-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80-%E2%89%A0-%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">49.1.</span> <span class="toc-text">📌 1. 偏向锁撤销 ≠ 锁升级为轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-2-%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E6%96%B0%E5%81%8F%E5%90%91%EF%BC%9F"><span class="toc-number">49.2.</span> <span class="toc-text">📌 2. 单个对象是否可以重新偏向？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%9D%A1%E4%BB%B6%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89"><span class="toc-number">49.2.1.</span> <span class="toc-text">✅ 条件一：没有其他线程竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%9D%A1%E4%BB%B6%E4%BA%8C%EF%BC%9A%E8%AF%A5%E7%B1%BB%E5%B0%9A%E6%9C%AA%E8%A7%A6%E5%8F%91%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E6%88%96%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">49.2.2.</span> <span class="toc-text">✅ 条件二：该类尚未触发批量重偏向或批量撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E8%83%BD%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%EF%BC%9F"><span class="toc-number">49.3.</span> <span class="toc-text">📌 3. 什么时候才能批量重偏向？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">50.</span> <span class="toc-text">🧪 示例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">51.</span> <span class="toc-text">📌 总结一下关键区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-number">52.</span> <span class="toc-text">✅ 最后总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%A6%82%E6%9E%9Ct2-%E6%92%A4%E9%94%80%E4%BA%86t1%E7%9A%84%E5%81%8F%E5%90%91%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BC%9A%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%81%8F%E5%90%91-%E5%B9%B6%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%88%E8%A2%ABt1-%E8%AF%B7%E6%B1%82%E4%BA%86%EF%BC%8Ct1%E4%BC%9A%E6%92%A4%E9%94%80t2%E7%9A%84%E5%81%8F%E5%90%91%EF%BC%8C%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%81%8F%E5%90%91%E5%88%B0t1-%E5%B9%B6%E8%AE%A1%E6%95%B0%E3%80%82%E8%BF%99%E4%B8%AA%E7%90%86%E8%A7%A3%E5%AF%B9%E5%90%A7"><span class="toc-number">53.</span> <span class="toc-text">如果如果t2 撤销了t1的偏向，然后会进行一个单对象偏向 并计数，如果后面这个对象又被t1 请求了，t1会撤销t2的偏向，单对象偏向到t1. 并计数。这个理解对吧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">54.</span> <span class="toc-text">✅ 你的理解总结如下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AD%94%E6%A1%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">55.</span> <span class="toc-text">✅ 答案一句话总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%9B%B4%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">56.</span> <span class="toc-text">🧠 更详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-1-%E5%81%8F%E5%90%91%E9%94%81%E6%98%AF%E2%80%9C%E7%BA%BF%E7%A8%8B-epoch%E2%80%9D%E7%BB%91%E5%AE%9A%E7%9A%84"><span class="toc-number">56.1.</span> <span class="toc-text">📌 1. 偏向锁是“线程 + epoch”绑定的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-2-%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%8F%8D%E5%A4%8D%E5%81%8F%E5%90%91%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">56.2.</span> <span class="toc-text">📌 2. 单个对象可以反复偏向不同线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">56.2.1.</span> <span class="toc-text">示例流程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-3-%E7%B1%BB%E6%92%A4%E9%94%80%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">56.3.</span> <span class="toc-text">📌 3. 类撤销计数器的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E6%92%A4%E9%94%80%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">57.</span> <span class="toc-text">📈 撤销计数器与偏向锁状态变化的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%81%E8%AE%B8%E5%8D%95%E5%AF%B9%E8%B1%A1%E9%87%8D%E5%81%8F%E5%90%91%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">⚙️ 补充说明：为什么允许单对象重偏向？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%EF%BC%9A"><span class="toc-number">59.</span> <span class="toc-text">✅ 总结一下你的理解是否正确：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E6%8E%A8%E8%8D%90%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">60.</span> <span class="toc-text">💡 推荐实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%81%87%E8%AE%BE"><span class="toc-number">60.1.</span> <span class="toc-text">1. 偏向锁的基本假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8BB%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E7%BA%BF%E7%A8%8BA%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%9F"><span class="toc-number">60.2.</span> <span class="toc-text">2. 线程B如何检测线程A是否释放锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E6%A3%80%E6%9F%A5Mark-Word%E7%9A%84%E7%BA%BF%E7%A8%8BID"><span class="toc-number">60.2.1.</span> <span class="toc-text">步骤1：检查Mark Word的线程ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%EF%BC%88Revoke%EF%BC%89"><span class="toc-number">60.2.2.</span> <span class="toc-text">步骤2：触发偏向锁撤销（Revoke）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8BA%E6%98%AF%E5%90%A6%E9%80%80%E5%87%BA%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%9F"><span class="toc-number">60.3.</span> <span class="toc-text">3. 关键问题：如何知道线程A是否退出同步块？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9A%82%E5%81%9C%E7%BA%BF%E7%A8%8BA%EF%BC%88STW%EF%BC%89%EF%BC%9F"><span class="toc-number">60.3.1.</span> <span class="toc-text">为什么需要暂停线程A（STW）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">60.4.</span> <span class="toc-text">4. 流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E4%B8%8E%E6%92%A4%E9%94%80"><span class="toc-number">60.5.</span> <span class="toc-text">5. 性能优化：批量重偏向与撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93-1"><span class="toc-number">60.6.</span> <span class="toc-text">6. 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">60.7.</span> <span class="toc-text">关键结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">60.8.</span> <span class="toc-text">详细流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%81%8F%E5%90%91%E9%94%81%E5%9C%BA%E6%99%AF%E4%B8%8B-Lock-Record-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">60.8.1.</span> <span class="toc-text">1. 偏向锁场景下 Lock Record 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8BB%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E9%94%81%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-number">60.8.2.</span> <span class="toc-text">2. 线程B如何检测锁是否释放？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84-Lock-Record"><span class="toc-number">60.8.3.</span> <span class="toc-text">3. 轻量级锁场景下的 Lock Record</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%8F%E5%90%91%E9%94%81%E4%B8%8D%E7%AB%8B%E5%8D%B3%E6%B8%85%E9%99%A4-Mark-Word-%E7%9A%84%E7%BA%BF%E7%A8%8BID%EF%BC%9F"><span class="toc-number">60.9.</span> <span class="toc-text">为什么偏向锁不立即清除 Mark Word 的线程ID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96"><span class="toc-number">60.10.</span> <span class="toc-text">示例代码与内存变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">60.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">61.</span> <span class="toc-text">1. 轻量级锁的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80%EF%BC%88%E5%8D%87%E7%BA%A7%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="toc-number">62.</span> <span class="toc-text">2. 轻量级锁的撤销（升级为重量级锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">62.1.</span> <span class="toc-text">2.1 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%92%A4%E9%94%80%E6%B5%81%E7%A8%8B"><span class="toc-number">62.2.</span> <span class="toc-text">2.2 撤销流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-vs-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">63.</span> <span class="toc-text">3. 轻量级锁 vs 重量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">64.</span> <span class="toc-text">4. 示例代码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">65.</span> <span class="toc-text">5. 关键点总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%E4%BB%A5%E4%B8%8B%E6%98%AF%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">66.</span> <span class="toc-text">精确地描述轻量级锁升级为重量级锁的过程。以下是详细分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA-1"><span class="toc-number">66.1.</span> <span class="toc-text">关键结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">66.2.</span> <span class="toc-text">完整流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81%EF%BC%88%E7%BA%BF%E7%A8%8BA%E6%8C%81%E6%9C%89%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="toc-number">66.2.1.</span> <span class="toc-text">1. 初始状态（线程A持有轻量级锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8BB%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%88%E8%A7%A6%E5%8F%91%E9%94%81%E8%86%A8%E8%83%80%EF%BC%89"><span class="toc-number">66.2.2.</span> <span class="toc-text">2. 线程B尝试获取锁（触发锁膨胀）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%81%E8%86%A8%E8%83%80%EF%BC%88%E5%8D%87%E7%BA%A7%E4%B8%BA%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="toc-number">66.2.3.</span> <span class="toc-text">3. 锁膨胀（升级为重量级锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E7%82%B9%E6%BE%84%E6%B8%85"><span class="toc-number">66.2.4.</span> <span class="toc-text">4. 关键点澄清</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">66.3.</span> <span class="toc-text">流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9F"><span class="toc-number">66.4.</span> <span class="toc-text">为什么需要重量级锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">66.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">67.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">68.</span> <span class="toc-text">🧠 锁消除的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E5%89%8D%E6%8F%90%EF%BC%9A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%88Escape-Analysis%EF%BC%89"><span class="toc-number">69.</span> <span class="toc-text">🔍 锁消除的前提：逃逸分析（Escape Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">69.1.</span> <span class="toc-text">逃逸分析的三种状态：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-number">70.</span> <span class="toc-text">🧪 示例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E9%94%81%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%B6%88%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">70.1.</span> <span class="toc-text">示例 1：锁可以被消除的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E9%94%81%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%B6%88%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">70.2.</span> <span class="toc-text">示例 2：锁不能被消除的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">⚙️ 如何开启锁消除？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">72.</span> <span class="toc-text">📈 性能影响与适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-3"><span class="toc-number">73.</span> <span class="toc-text">✅ 总结一句话：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">73.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">73.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">73.3.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">73.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%8F%8F%E8%BF%B0"><span class="toc-number">73.5.</span> <span class="toc-text">模式描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">73.6.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">73.7.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Park-%E5%92%8C-Unpark-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">73.8.</span> <span class="toc-text">Park 和 Unpark 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">73.9.</span> <span class="toc-text">LockSupport 提供的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">73.10.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">73.11.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%EF%BC%88Deadlock%EF%BC%89"><span class="toc-number">73.12.</span> <span class="toc-text">1. 死锁（Deadlock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B4%BB%E9%94%81%EF%BC%88Livelock%EF%BC%89"><span class="toc-number">73.13.</span> <span class="toc-text">2. 活锁（Livelock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A5%A5%E9%A5%BF%EF%BC%88Starvation%EF%BC%89"><span class="toc-number">73.14.</span> <span class="toc-text">3. 饥饿（Starvation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">73.15.</span> <span class="toc-text">一、基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%EF%BC%9ALock"><span class="toc-number">73.15.1.</span> <span class="toc-text">1. 核心接口：Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">73.15.2.</span> <span class="toc-text">2. 锁的实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">73.16.</span> <span class="toc-text">二、具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ReentrantLock-%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82"><span class="toc-number">73.16.1.</span> <span class="toc-text">1. ReentrantLock 设计细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReentrantReadWriteLock-%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82"><span class="toc-number">73.16.2.</span> <span class="toc-text">2. ReentrantReadWriteLock 设计细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-StampedLock-%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82"><span class="toc-number">73.16.3.</span> <span class="toc-text">3. StampedLock 设计细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8"><span class="toc-number">73.17.</span> <span class="toc-text">三、场景应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-ReentrantLock-%E6%9B%BF%E4%BB%A3-synchronized"><span class="toc-number">73.17.1.</span> <span class="toc-text">1. 使用 ReentrantLock 替代 synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-ReadWriteLock-%E5%9C%A8%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">73.17.2.</span> <span class="toc-text">2. 使用 ReadWriteLock 在读多写少的情况下提高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-StampedLock-%E5%9C%A8%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E4%B8%94%E9%80%82%E5%90%88%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">73.17.3.</span> <span class="toc-text">3. 使用 StampedLock 在读多写少且适合乐观锁的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">74.</span> <span class="toc-text">ReentrantLock原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9AAQS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">🧠 背景知识：AQS 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">76.</span> <span class="toc-text">🔍 方法签名解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-%E6%96%B9%E6%B3%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">77.</span> <span class="toc-text">📦 方法作用总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">78.</span> <span class="toc-text">🔁 主要流程详解（逐行分析）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">78.1.</span> <span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E5%BE%AA%E7%8E%AF%E4%BD%93%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">78.2.</span> <span class="toc-text">🔁 循环体说明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E7%9A%84%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9-p"><span class="toc-number">78.2.1.</span> <span class="toc-text">1. 获取当前节点的前驱节点 p</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%88%E5%8F%AA%E6%9C%89%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%89%8D%E6%9C%89%E8%B5%84%E6%A0%BC%E6%8A%A2%E9%94%81%EF%BC%89"><span class="toc-number">78.2.2.</span> <span class="toc-text">2. 尝试获取锁（只有头节点的下一个节点才有资格抢锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">78.2.3.</span> <span class="toc-text">3. 获取失败后的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-shouldParkAfterFailedAcquire-p-node"><span class="toc-number">78.2.3.1.</span> <span class="toc-text">a. shouldParkAfterFailedAcquire(p, node)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-parkAndCheckInterrupt"><span class="toc-number">78.2.3.2.</span> <span class="toc-text">b. parkAndCheckInterrupt()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%91-finally-%E5%9D%97%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">78.3.</span> <span class="toc-text">🛑 finally 块中的异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%90-CLH-%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0"><span class="toc-number">79.</span> <span class="toc-text">📐 CLH 队列结构简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-4"><span class="toc-number">80.</span> <span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E6%89%A9%E5%B1%95%E5%BB%BA%E8%AE%AE"><span class="toc-number">81.</span> <span class="toc-text">🚀 扩展建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E8%A2%AB%E2%80%9C%E9%98%BB%E5%A1%9E%E6%8C%82%E8%B5%B7%E2%80%9D"><span class="toc-number">82.</span> <span class="toc-text">🧠 作用：判断当前线程是否应该被“阻塞挂起”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">83.</span> <span class="toc-text">🔁 参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%90%AB%E4%B9%89"><span class="toc-number">84.</span> <span class="toc-text">📌 返回值含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%80%90%E6%AE%B5%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81"><span class="toc-number">85.</span> <span class="toc-text">✅ 逐段解析代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%A3%80%E6%9F%A5%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88waitStatus%EF%BC%89"><span class="toc-number">85.1.</span> <span class="toc-text">第一步：检查前驱节点的状态（waitStatus）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%A4%84%E7%90%86%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E8%A2%AB%E5%8F%96%E6%B6%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88waitStatus-0%EF%BC%89"><span class="toc-number">85.2.</span> <span class="toc-text">第二步：处理前驱节点被取消的情况（waitStatus &gt; 0）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E4%B8%BA-SIGNAL"><span class="toc-number">85.3.</span> <span class="toc-text">第三步：设置前驱节点为 SIGNAL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%90-Node-waitStatus-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%80%BC"><span class="toc-number">86.</span> <span class="toc-text">📐 Node.waitStatus 的几个关键值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA%E6%84%8F"><span class="toc-number">87.</span> <span class="toc-text">🔄 流程图示意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%89"><span class="toc-number">88.</span> <span class="toc-text">🎯 举个例子（ReentrantLock 非公平锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-number">89.</span> <span class="toc-text">🧩 总结一句话：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">89.1.</span> <span class="toc-text">主要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">89.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">89.3.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">89.4.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/26/Redis_List/" title="Redis_List"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/07/1eb94f064cf74b04865bdaf1b3c8e9be6939674b9205c975.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis_List"/></a><div class="content"><a class="title" href="/2025/09/26/Redis_List/" title="Redis_List">Redis_List</a><time datetime="2025-09-26T06:03:11.297Z" title="Created 2025-09-26 14:03:11">2025-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/25/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/" title="算法_常见排序及复杂度比较"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/31/data_st36d19cecfce34426.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法_常见排序及复杂度比较"/></a><div class="content"><a class="title" href="/2025/09/25/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/" title="算法_常见排序及复杂度比较">算法_常见排序及复杂度比较</a><time datetime="2025-09-25T08:32:37.098Z" title="Created 2025-09-25 16:32:37">2025-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/25/Spring_Async/" title="Spring Async 异步编程详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/09/25/asyncabc674a8cbe370a0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Async 异步编程详解"/></a><div class="content"><a class="title" href="/2025/09/25/Spring_Async/" title="Spring Async 异步编程详解">Spring Async 异步编程详解</a><time datetime="2025-09-25T02:57:07.010Z" title="Created 2025-09-25 10:57:07">2025-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/23/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95_2020_9_23/" title="面试记录_2025_6_27"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/08/07/202012111639381648986755c150cff23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试记录_2025_6_27"/></a><div class="content"><a class="title" href="/2025/09/23/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95_2020_9_23/" title="面试记录_2025_6_27">面试记录_2025_6_27</a><time datetime="2025-09-23T01:35:50.929Z" title="Created 2025-09-23 09:35:50">2025-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/21/Python_%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python装饰器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://origin.picgo.net/2025/09/25/deco4918756a582fd2b8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python装饰器"/></a><div class="content"><a class="title" href="/2025/09/21/Python_%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python装饰器">Python装饰器</a><time datetime="2025-09-20T16:00:33.502Z" title="Created 2025-09-21 00:00:33">2025-09-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Joie" target="_blank">Joie</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">92</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">40</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">29</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">个人主页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://benedicttom.github.io/home/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AMQP/" style="font-size: 0.88rem;">AMQP<sup>1</sup></a><a href="/tags/CI-CD/" style="font-size: 0.88rem;">CI/CD<sup>1</sup></a><a href="/tags/ElasticSearch/" style="font-size: 0.88rem;">ElasticSearch<sup>3</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/Http/" style="font-size: 0.88rem;">Http<sup>2</sup></a><a href="/tags/I-O/" style="font-size: 0.88rem;">I/O<sup>2</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>9</sup></a><a href="/tags/MongoDB/" style="font-size: 0.88rem;">MongoDB<sup>1</sup></a><a href="/tags/Mysql/" style="font-size: 0.88rem;">Mysql<sup>2</sup></a><a href="/tags/ORM/" style="font-size: 0.88rem;">ORM<sup>3</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>5</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>7</sup></a><a href="/tags/Redisson/" style="font-size: 0.88rem;">Redisson<sup>1</sup></a><a href="/tags/Rpc/" style="font-size: 0.88rem;">Rpc<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>3</sup></a><a href="/tags/Spring-Cloud/" style="font-size: 0.88rem;">Spring Cloud<sup>5</sup></a><a href="/tags/Spring-Data/" style="font-size: 0.88rem;">Spring Data<sup>5</sup></a><a href="/tags/Swagger/" style="font-size: 0.88rem;">Swagger<sup>2</sup></a><a href="/tags/%E4%B8%9A%E5%8A%A1/" style="font-size: 0.88rem;">业务<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" style="font-size: 0.88rem;">云原生<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 0.88rem;">八股<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">分布式锁<sup>1</sup></a><a href="/tags/%E5%8A%9B%E6%89%A3/" style="font-size: 0.88rem;">力扣<sup>10</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>9</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 0.88rem;">定时任务<sup>3</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>9</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">开发工具<sup>2</sup></a><a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">异步编程<sup>1</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">推荐<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/" style="font-size: 0.88rem;">权限校验<sup>4</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>1</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 0.88rem;">树<sup>1</sup></a><a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">消息队列<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>2</sup></a><a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 0.88rem;">缓存<sup>3</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 0.88rem;">运维<sup>2</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>3</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Joie 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>